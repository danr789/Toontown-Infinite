1565844244
3 3
16 libp3parametrics 4 UKlv 12 panda3d.core 
251
272 8 is_valid 0 6 523 25 ParametricCurve::is_valid 0 1 1 164
/**
 * Returns true if the curve is defined.  This base class function always
 * returns true; derived classes might override this to sometimes return
 * false.
 */
51
virtual bool ParametricCurve::is_valid(void) const;

273 9 get_max_t 0 6 523 26 ParametricCurve::get_max_t 0 1 2 237
/**
 * Returns the upper bound of t for the entire curve.  The curve is defined in
 * the range 0.0f <= t <= get_max_t().  This base class function always
 * returns 1.0f; derived classes might override this to return something else.
 */
59
virtual PN_stdfloat ParametricCurve::get_max_t(void) const;

274 14 set_curve_type 0 4 523 31 ParametricCurve::set_curve_type 0 1 3 389
/**
 * Sets the flag indicating the use to which the curve is intended to be put.
 * This flag is optional and only serves to provide a hint to the egg reader
 * and writer code; it has no effect on the curve's behavior.
 *
 * Setting the curve type also sets the num_dimensions to 3 or 1 according to
 * the type.
 *
 * THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.
 */
47
void ParametricCurve::set_curve_type(int type);

275 14 get_curve_type 0 4 523 31 ParametricCurve::get_curve_type 0 1 4 91
/**
 * Returns the flag indicating the use to which the curve is intended to be
 * put.
 */
48
int ParametricCurve::get_curve_type(void) const;

276 18 set_num_dimensions 0 4 523 35 ParametricCurve::set_num_dimensions 0 1 5 324
/**
 * Specifies the number of significant dimensions in the curve's vertices.
 * This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three
 * dimensions; time curves should always have one dimension.  This only serves
 * as a hint to the mopath editor, and also controls how the curve is written
 * out.
 */
50
void ParametricCurve::set_num_dimensions(int num);

277 18 get_num_dimensions 0 4 523 35 ParametricCurve::get_num_dimensions 0 1 6 267
/**
 * Returns the number of significant dimensions in the curve's vertices, as
 * set by a previous call to set_num_dimensions().  This is only a hint as to
 * how the curve is intended to be used; the actual number of dimensions of
 * any curve is always three.
 */
52
int ParametricCurve::get_num_dimensions(void) const;

278 11 calc_length 0 4 523 28 ParametricCurve::calc_length 0 2 7 8 188
/**
 * Approximates the length of the entire curve to within a few decimal places.
 */

/**
 * Approximates the length of the curve segment from parametric time 'from' to
 * time 'to'.
 */
135
PN_stdfloat ParametricCurve::calc_length(void) const;
PN_stdfloat ParametricCurve::calc_length(PN_stdfloat from, PN_stdfloat to) const;

279 11 find_length 0 4 523 28 ParametricCurve::find_length 0 1 9 396
/**
 * Returns the parametric value corresponding to the indicated distance along
 * the curve from the starting parametric value.
 *
 * This is the inverse of calc_length(): rather than determining the length
 * along the curve between two parametric points, it determines the position
 * in parametric time of a point n units along the curve.
 *
 * The search distance must not be negative.
 */
95
PN_stdfloat ParametricCurve::find_length(PN_stdfloat start_t, PN_stdfloat length_offset) const;

280 9 get_point 0 6 523 26 ParametricCurve::get_point 0 1 10 0
83
virtual bool ParametricCurve::get_point(PN_stdfloat t, LVecBase3 &point) const = 0;

281 11 get_tangent 0 6 523 28 ParametricCurve::get_tangent 0 1 11 0
87
virtual bool ParametricCurve::get_tangent(PN_stdfloat t, LVecBase3 &tangent) const = 0;

282 6 get_pt 0 6 523 23 ParametricCurve::get_pt 0 1 12 0
100
virtual bool ParametricCurve::get_pt(PN_stdfloat t, LVecBase3 &point, LVecBase3 &tangent) const = 0;

283 14 get_2ndtangent 0 6 523 31 ParametricCurve::get_2ndtangent 0 1 13 0
91
virtual bool ParametricCurve::get_2ndtangent(PN_stdfloat t, LVecBase3 &tangent2) const = 0;

284 12 adjust_point 0 6 523 29 ParametricCurve::adjust_point 0 1 14 144
/**
 * Recomputes the curve such that it passes through the point (px, py, pz) at
 * time t, but keeps the same tangent value at that point.
 */
106
virtual bool ParametricCurve::adjust_point(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz);

285 14 adjust_tangent 0 6 523 31 ParametricCurve::adjust_tangent 0 1 15 129
/**
 * Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,
 * but keeps the same position at the point.
 */
108
virtual bool ParametricCurve::adjust_tangent(PN_stdfloat t, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz);

286 9 adjust_pt 0 6 523 26 ParametricCurve::adjust_pt 0 1 16 116
/**
 * Recomputes the curve such that it passes through the point (px, py, pz)
 * with the tangent (tx, ty, tz).
 */
151
virtual bool ParametricCurve::adjust_pt(PN_stdfloat t, PN_stdfloat px, PN_stdfloat py, PN_stdfloat pz, PN_stdfloat tx, PN_stdfloat ty, PN_stdfloat tz);

287 9 recompute 0 6 523 26 ParametricCurve::recompute 0 1 17 115
/**
 * Recalculates the curve, if necessary.  Returns true if the resulting curve
 * is valid, false otherwise.
 */
46
virtual bool ParametricCurve::recompute(void);

288 6 stitch 0 6 523 23 ParametricCurve::stitch 0 1 18 259
/**
 * Regenerates this curve as one long curve: the first curve connected end-to-
 * end with the second one.  Either a or b may be the same as 'this'.
 *
 * Returns true if successful, false on failure or if the curve type does not
 * support stitching.
 */
89
virtual bool ParametricCurve::stitch(ParametricCurve const *a, ParametricCurve const *b);

289 9 write_egg 0 4 523 26 ParametricCurve::write_egg 0 2 19 20 281
/**
 * Writes an egg description of the nurbs curve to the specified output file.
 * Returns true if the file is successfully written.
 */

/**
 * Writes an egg description of the nurbs curve to the specified output
 * stream.  Returns true if the file is successfully written.
 */
186
bool ParametricCurve::write_egg(Filename filename, CoordinateSystem cs = ::CS_default);
bool ParametricCurve::write_egg(std::ostream &out, Filename const &filename, CoordinateSystem cs);

290 14 get_class_type 0 4 523 31 ParametricCurve::get_class_type 0 1 21 0
56
static TypeHandle ParametricCurve::get_class_type(void);

291 14 get_class_type 0 4 525 29 CubicCurveseg::get_class_type 0 1 22 0
54
static TypeHandle CubicCurveseg::get_class_type(void);

292 25 ParametricCurveCollection 0 4 526 52 ParametricCurveCollection::ParametricCurveCollection 0 2 23 24 10
/**
 *
 */
165
ParametricCurveCollection::ParametricCurveCollection(void);
inline ParametricCurveCollection::ParametricCurveCollection(ParametricCurveCollection const &) = default;

293 9 add_curve 0 4 526 36 ParametricCurveCollection::add_curve 0 2 25 26 192
/**
 * Adds a new ParametricCurve to the collection at the indicated index.
 * @deprecated Use insert_curve(index, curve) instead.
 */

/**
 * Adds a new ParametricCurve to the collection.
 */
144
void ParametricCurveCollection::add_curve(ParametricCurve *curve);
void ParametricCurveCollection::add_curve(ParametricCurve *curve, int index);

294 12 insert_curve 0 4 526 39 ParametricCurveCollection::insert_curve 0 1 27 79
/**
 * Adds a new ParametricCurve to the collection at the indicated index.
 */
88
void ParametricCurveCollection::insert_curve(std::size_t index, ParametricCurve *curve);

295 10 add_curves 0 4 526 37 ParametricCurveCollection::add_curves 0 1 28 120
/**
 * Adds all the curves found in the scene graph rooted at the given node.
 * Returns the number of curves found.
 */
59
int ParametricCurveCollection::add_curves(PandaNode *node);

296 12 remove_curve 0 4 526 39 ParametricCurveCollection::remove_curve 0 2 29 30 255
/**
 * Removes the indicated ParametricCurve from the collection.  Returns true if
 * the curve was removed, false if it was not a member of the collection.
 */

/**
 * Removes the indicated ParametricCurve from the collection, by its index
 * number.
 */
134
bool ParametricCurveCollection::remove_curve(ParametricCurve *curve);
void ParametricCurveCollection::remove_curve(std::size_t index);

297 9 set_curve 0 4 526 36 ParametricCurveCollection::set_curve 0 1 31 94
/**
 * Replaces the indicated ParametricCurve from the collection, by its index
 * number.
 */
85
void ParametricCurveCollection::set_curve(std::size_t index, ParametricCurve *curve);

298 9 has_curve 0 4 526 36 ParametricCurveCollection::has_curve 0 1 32 104
/**
 * Returns true if the indicated ParametricCurve appears in this collection,
 * false otherwise.
 */
72
bool ParametricCurveCollection::has_curve(ParametricCurve *curve) const;

299 5 clear 0 4 526 32 ParametricCurveCollection::clear 0 1 33 60
/**
 * Removes all ParametricCurves from the collection.
 */
44
void ParametricCurveCollection::clear(void);

300 15 clear_timewarps 0 4 526 42 ParametricCurveCollection::clear_timewarps 0 1 34 63
/**
 * Removes all the timewarp curves from the collection.
 */
54
void ParametricCurveCollection::clear_timewarps(void);

301 14 get_num_curves 0 4 526 41 ParametricCurveCollection::get_num_curves 0 1 35 68
/**
 * Returns the number of ParametricCurves in the collection.
 */
65
inline int ParametricCurveCollection::get_num_curves(void) const;

302 9 get_curve 0 4 526 36 ParametricCurveCollection::get_curve 0 1 36 61
/**
 * Returns the nth ParametricCurve in the collection.
 */
78
inline ParametricCurve *ParametricCurveCollection::get_curve(int index) const;

303 13 get_xyz_curve 0 4 526 40 ParametricCurveCollection::get_xyz_curve 0 1 37 95
/**
 * Returns the first XYZ curve in the collection, if any, or NULL if there are
 * none.
 */
70
ParametricCurve *ParametricCurveCollection::get_xyz_curve(void) const;

304 13 get_hpr_curve 0 4 526 40 ParametricCurveCollection::get_hpr_curve 0 1 38 95
/**
 * Returns the first HPR curve in the collection, if any, or NULL if there are
 * none.
 */
70
ParametricCurve *ParametricCurveCollection::get_hpr_curve(void) const;

305 17 get_default_curve 0 4 526 44 ParametricCurveCollection::get_default_curve 0 1 39 180
/**
 * If there is an XYZ curve in the collection, returns it; otherwise, returns
 * the first curve whose type is unspecified.  Returns NULL if no curve meets
 * the criteria.
 */
74
ParametricCurve *ParametricCurveCollection::get_default_curve(void) const;

306 17 get_num_timewarps 0 4 526 44 ParametricCurveCollection::get_num_timewarps 0 1 40 67
/**
 * Returns the number of timewarp curves in the collection.
 */
61
int ParametricCurveCollection::get_num_timewarps(void) const;

307 18 get_timewarp_curve 0 4 526 45 ParametricCurveCollection::get_timewarp_curve 0 1 41 60
/**
 * Returns the nth timewarp curve in the collection.
 */
76
ParametricCurve *ParametricCurveCollection::get_timewarp_curve(int n) const;

308 9 get_max_t 0 4 526 36 ParametricCurveCollection::get_max_t 0 1 42 170
/**
 * Returns the maximum T value associated with the *last* curve in the
 * collection.  Normally, this will be either the XYZ or HPR curve, or a
 * timewarp curve.
 */
68
inline PN_stdfloat ParametricCurveCollection::get_max_t(void) const;

309 0 0 0 0 0 0 0 0
0

310 0 0 0 0 0 0 0 0
0

311 9 make_even 0 4 526 36 ParametricCurveCollection::make_even 0 1 43 539
/**
 * Discards all existing timewarp curves and recomputes a new timewarp curve
 * that maps distance along the curve to parametric time, so that the distance
 * between any two points in parametric time is proportional to the
 * approximate distance of those same two points along the XYZ curve.
 *
 * segments_per_unit represents the number of segments to take per each unit
 * of parametric time of the original XYZ curve.
 *
 * The new timewarp curve (and thus, the apparent range of the collection)
 * will range from 0 to max_t.
 */
92
void ParametricCurveCollection::make_even(PN_stdfloat max_t, PN_stdfloat segments_per_unit);

312 12 face_forward 0 4 526 39 ParametricCurveCollection::face_forward 0 1 44 179
/**
 * Discards the existing HPR curve and generates a new one that looks in the
 * direction of travel along the XYZ curve, based on the XYZ curve's tangent
 * at each point.
 */
76
void ParametricCurveCollection::face_forward(PN_stdfloat segments_per_unit);

313 11 reset_max_t 0 4 526 38 ParametricCurveCollection::reset_max_t 0 1 45 277
/**
 * Adjusts the apparent length of the curve by applying a new timewarp that
 * maps the range [0..max_t] to the range [0..get_max_t()].  After this call,
 * the curve collection will contain one more timewarp curve, and get_max_t()
 * will return the given max_t value.
 */
63
void ParametricCurveCollection::reset_max_t(PN_stdfloat max_t);

314 8 evaluate 0 4 526 35 ParametricCurveCollection::evaluate 0 2 46 47 943
/**
 * Computes the position and rotation represented by the first XYZ and HPR
 * curves in the collection at the given point t, after t has been modified by
 * all the timewarp curves in the collection applied in sequence, from back to
 * front.
 *
 * Returns true if the point is valid (i.e.  t is within the bounds indicated
 * by all the timewarp curves and within the bounds of the curves themselves),
 * or false otherwise.
 */

/**
 * Computes the transform matrix representing translation to the position
 * indicated by the first XYZ curve in the collection and the rotation
 * indicated by the first HPR curve in the collection, after t has been
 * modified by all the timewarp curves in the collection applied in sequence,
 * from back to front.
 *
 * Returns true if the point is valid (i.e.  t is within the bounds indicated
 * by all the timewarp curves and within the bounds of the curves themselves),
 * or false otherwise.
 */
211
bool ParametricCurveCollection::evaluate(PN_stdfloat t, LVecBase3 &xyz, LVecBase3 &hpr) const;
bool ParametricCurveCollection::evaluate(PN_stdfloat t, LMatrix4 &result, CoordinateSystem cs = ::CS_default) const;

315 10 evaluate_t 0 4 526 37 ParametricCurveCollection::evaluate_t 0 1 48 219
/**
 * Determines the value of t that should be passed to the XYZ and HPR curves,
 * after applying the given value of t to all the timewarps.  Return -1.0f if
 * the value of t exceeds one of the timewarps' ranges.
 */
71
PN_stdfloat ParametricCurveCollection::evaluate_t(PN_stdfloat t) const;

316 12 evaluate_xyz 0 4 526 39 ParametricCurveCollection::evaluate_xyz 0 1 49 69
/**
 * Computes only the XYZ part of the curves.  See evaluate().
 */
89
inline bool ParametricCurveCollection::evaluate_xyz(PN_stdfloat t, LVecBase3 &xyz) const;

317 12 evaluate_hpr 0 4 526 39 ParametricCurveCollection::evaluate_hpr 0 1 50 69
/**
 * Computes only the HPR part of the curves.  See evaluate().
 */
89
inline bool ParametricCurveCollection::evaluate_hpr(PN_stdfloat t, LVecBase3 &hpr) const;

318 10 adjust_xyz 0 4 526 37 ParametricCurveCollection::adjust_xyz 0 2 51 52 418
/**
 * Adjust the XYZ curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */

/**
 * Adjust the XYZ curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */
191
inline bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
bool ParametricCurveCollection::adjust_xyz(PN_stdfloat t, LVecBase3 const &xyz);

319 10 adjust_hpr 0 4 526 37 ParametricCurveCollection::adjust_hpr 0 2 53 54 418
/**
 * Adjust the HPR curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */

/**
 * Adjust the HPR curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */
191
inline bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, PN_stdfloat h, PN_stdfloat p, PN_stdfloat r);
bool ParametricCurveCollection::adjust_hpr(PN_stdfloat t, LVecBase3 const &xyz);

320 9 recompute 0 4 526 36 ParametricCurveCollection::recompute 0 1 55 153
/**
 * Ensures all the curves are freshly computed and up-to-date.  Returns true
 * if everything is valid, false if at least one curve is incorrect.
 */
48
bool ParametricCurveCollection::recompute(void);

321 6 stitch 0 4 526 33 ParametricCurveCollection::stitch 0 1 56 262
/**
 * Regenerates this curve as one long curve: the first curve connected end-to-
 * end with the second one.  Either a or b may be the same as 'this'.  This
 * will lose any timewarps on the input curves.
 *
 * Returns true if successful, false on failure.
 */
111
bool ParametricCurveCollection::stitch(ParametricCurveCollection const *a, ParametricCurveCollection const *b);

322 6 output 0 4 526 33 ParametricCurveCollection::output 0 1 57 114
/**
 * Writes a brief one-line description of the ParametricCurveCollection to the
 * indicated output stream.
 */
64
void ParametricCurveCollection::output(std::ostream &out) const;

323 5 write 0 4 526 32 ParametricCurveCollection::write 0 1 58 119
/**
 * Writes a complete multi-line description of the ParametricCurveCollection
 * to the indicated output stream.
 */
85
void ParametricCurveCollection::write(std::ostream &out, int indent_level = 0) const;

324 9 write_egg 0 4 526 36 ParametricCurveCollection::write_egg 0 2 59 60 328
/**
 * Writes an egg description of all the nurbs curves in the collection to the
 * specified output file.  Returns true if the file is successfully written.
 */

/**
 * Writes an egg description of all the nurbs curves in the collection to the
 * specified output stream.  Returns true if the file is successfully written.
 */
206
bool ParametricCurveCollection::write_egg(Filename filename, CoordinateSystem cs = ::CS_default);
bool ParametricCurveCollection::write_egg(std::ostream &out, Filename const &filename, CoordinateSystem cs);

325 11 CurveFitter 0 4 531 24 CurveFitter::CurveFitter 0 2 61 62 10
/**
 *
 */
95
CurveFitter::CurveFitter(void);
inline CurveFitter::CurveFitter(CurveFitter const &) = default;

326 12 ~CurveFitter 0 4 531 25 CurveFitter::~CurveFitter 0 0 10
/**
 *
 */
32
CurveFitter::~CurveFitter(void);

327 5 reset 0 4 531 18 CurveFitter::reset 0 1 63 114
/**
 * Removes all the data points previously added to the CurveFitter, and
 * initializes it for a new curve.
 */
30
void CurveFitter::reset(void);

328 7 add_xyz 0 4 531 20 CurveFitter::add_xyz 0 1 64 36
/**
 * Adds a single sample xyz.
 */
63
void CurveFitter::add_xyz(PN_stdfloat t, LVecBase3 const &xyz);

329 7 add_hpr 0 4 531 20 CurveFitter::add_hpr 0 1 65 36
/**
 * Adds a single sample hpr.
 */
63
void CurveFitter::add_hpr(PN_stdfloat t, LVecBase3 const &hpr);

330 11 add_xyz_hpr 0 4 531 24 CurveFitter::add_xyz_hpr 0 1 66 57
/**
 * Adds a single sample xyz & hpr simultaneously.
 */
89
void CurveFitter::add_xyz_hpr(PN_stdfloat t, LVecBase3 const &xyz, LVecBase3 const &hpr);

331 15 get_num_samples 0 4 531 28 CurveFitter::get_num_samples 0 1 67 68
/**
 * Returns the number of sample points that have been added.
 */
45
int CurveFitter::get_num_samples(void) const;

332 12 get_sample_t 0 4 531 25 CurveFitter::get_sample_t 0 1 68 64
/**
 * Returns the parametric value of the nth sample added.
 */
51
PN_stdfloat CurveFitter::get_sample_t(int n) const;

333 14 get_sample_xyz 0 4 531 27 CurveFitter::get_sample_xyz 0 1 69 62
/**
 * Returns the point in space of the nth sample added.
 */
51
LVecBase3 CurveFitter::get_sample_xyz(int n) const;

334 14 get_sample_hpr 0 4 531 27 CurveFitter::get_sample_hpr 0 1 70 59
/**
 * Returns the orientation of the nth sample added.
 */
51
LVecBase3 CurveFitter::get_sample_hpr(int n) const;

335 18 get_sample_tangent 0 4 531 31 CurveFitter::get_sample_tangent 0 1 71 143
/**
 * Returns the tangent associated with the nth sample added.  This is only
 * meaningful if compute_tangents() has already been called.
 */
55
LVecBase3 CurveFitter::get_sample_tangent(int n) const;

336 14 remove_samples 0 4 531 27 CurveFitter::remove_samples 0 1 72 108
/**
 * Eliminates all samples from index begin, up to but not including index end,
 * from the database.
 */
53
void CurveFitter::remove_samples(int begin, int end);

337 6 sample 0 4 531 19 CurveFitter::sample 0 1 73 223
/**
 * Generates a series of data points by sampling the given curve (or xyz/hpr
 * curves) the indicated number of times.  The sampling is made evenly in
 * parametric time, and then the timewarps, if any, are applied.
 */
71
void CurveFitter::sample(ParametricCurveCollection *curves, int count);

338 8 wrap_hpr 0 4 531 21 CurveFitter::wrap_hpr 0 1 74 165
/**
 * Resets each HPR data point so that the maximum delta between any two
 * consecutive points is 180 degrees, which should prevent incorrect HPR
 * wrapping.
 */
33
void CurveFitter::wrap_hpr(void);

339 11 sort_points 0 4 531 24 CurveFitter::sort_points 0 1 75 115
/**
 * Sorts all the data points in order by parametric time, in case they were
 * added in an incorrect order.
 */
36
void CurveFitter::sort_points(void);

340 8 desample 0 4 531 21 CurveFitter::desample 0 1 76 175
/**
 * Removes sample points in order to reduce the complexity of a sampled curve.
 * Keeps one out of every factor samples.  Also keeps the first and the last
 * samples.
 */
47
void CurveFitter::desample(PN_stdfloat factor);

341 16 compute_tangents 0 4 531 29 CurveFitter::compute_tangents 0 1 77 231
/**
 * Once a set of points has been built, and prior to calling MakeHermite() or
 * MakeNurbs(), ComputeTangents() must be called to set up the tangents
 * correctly (unless the tangents were defined as the points were added).
 */
54
void CurveFitter::compute_tangents(PN_stdfloat scale);

342 12 make_hermite 0 4 531 25 CurveFitter::make_hermite 0 1 78 72
/**
 * Converts the current set of data points into a Hermite curve.
 */
77
PointerTo< ParametricCurveCollection > CurveFitter::make_hermite(void) const;

343 10 make_nurbs 0 4 531 23 CurveFitter::make_nurbs 0 1 79 134
/**
 * Converts the current set of data points into a NURBS curve.  This gives a
 * smoother curve than produced by MakeHermite().
 */
75
PointerTo< ParametricCurveCollection > CurveFitter::make_nurbs(void) const;

344 6 output 0 4 531 19 CurveFitter::output 0 1 80 10
/**
 *
 */
50
void CurveFitter::output(std::ostream &out) const;

345 5 write 0 4 531 18 CurveFitter::write 0 1 81 10
/**
 *
 */
49
void CurveFitter::write(std::ostream &out) const;

346 14 get_class_type 0 4 531 27 CurveFitter::get_class_type 0 1 82 0
52
static TypeHandle CurveFitter::get_class_type(void);

347 14 PiecewiseCurve 0 4 532 30 PiecewiseCurve::PiecewiseCurve 0 1 83 10
/**
 *
 */
37
PiecewiseCurve::PiecewiseCurve(void);

348 14 get_class_type 0 4 532 30 PiecewiseCurve::get_class_type 0 1 84 0
55
static TypeHandle PiecewiseCurve::get_class_type(void);

349 12 HermiteCurve 0 4 533 26 HermiteCurve::HermiteCurve 0 2 85 86 92
/**
 *
 */

/**
 * Constructs a Hermite from the indicated (possibly non-hermite) curve.
 */
88
HermiteCurve::HermiteCurve(void);
HermiteCurve::HermiteCurve(ParametricCurve const &pc);

350 11 get_num_cvs 0 4 533 25 HermiteCurve::get_num_cvs 0 1 87 51
/**
 * Returns the number of CV's in the curve.
 */
42
int HermiteCurve::get_num_cvs(void) const;

351 9 insert_cv 0 4 533 23 HermiteCurve::insert_cv 0 1 88 547
/**
 * Inserts a new CV at the given parametric point along the curve.  If this
 * parametric point is already on the curve, the CV is assigned an index
 * between its two neighbors and the indices of all following CV's are
 * incremented by 1; its in and out tangents are chosen to keep the curve
 * consistent.  If the new parametric point is beyond the end of the existing
 * curve, the curve is extended to meet it and the new CV's position, in
 * tangent, and out tangent are set to zero.
 *
 * The index number of the new CV is returned.
 */
43
int HermiteCurve::insert_cv(PN_stdfloat t);

352 9 append_cv 0 4 533 23 HermiteCurve::append_cv 0 2 89 90 149
/**
 * Adds a new CV to the end of the curve.  The new CV is given initial in/out
 * tangents of 0.  The return value is the index of the new CV.
 */
149
int HermiteCurve::append_cv(int type, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline int HermiteCurve::append_cv(int type, LVecBase3 const &v);

353 9 remove_cv 0 4 533 23 HermiteCurve::remove_cv 0 1 91 100
/**
 * Removes the given CV from the curve.  Returns true if the CV existed, false
 * otherwise.
 */
36
bool HermiteCurve::remove_cv(int n);

354 14 remove_all_cvs 0 4 533 28 HermiteCurve::remove_all_cvs 0 1 92 43
/**
 * Removes all CV's from the curve.
 */
40
void HermiteCurve::remove_all_cvs(void);

355 11 set_cv_type 0 4 533 25 HermiteCurve::set_cv_type 0 1 93 544
/**
 * Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,
 * HC_G1, or HC_SMOOTH.
 *
 * Other than HC_CUT, these have no effect on the actual curve; it remains up
 * to user software to impose the constraints these imply.
 *
 * HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints
 * on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH
 * forces the tangents to be identical.  Setting type type to HC_G1 or
 * HC_SMOOTH may adjust the out tangent to match the in tangent.
 */
48
bool HermiteCurve::set_cv_type(int n, int type);

356 12 set_cv_point 0 4 533 26 HermiteCurve::set_cv_point 0 2 94 95 43
/**
 * Changes the given CV's position.
 */
151
bool HermiteCurve::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline bool HermiteCurve::set_cv_point(int n, LVecBase3 const &v);

357 9 set_cv_in 0 4 533 23 HermiteCurve::set_cv_in 0 2 96 97 121
/**
 * Changes the given CV's in tangent.  Depending on the continuity type, this
 * may also adjust the out tangent.
 */
145
bool HermiteCurve::set_cv_in(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline bool HermiteCurve::set_cv_in(int n, LVecBase3 const &v);

358 10 set_cv_out 0 4 533 24 HermiteCurve::set_cv_out 0 2 98 99 121
/**
 * Changes the given CV's out tangent.  Depending on the continuity type, this
 * may also adjust the in tangent.
 */
147
bool HermiteCurve::set_cv_out(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline bool HermiteCurve::set_cv_out(int n, LVecBase3 const &v);

359 13 set_cv_tstart 0 4 533 27 HermiteCurve::set_cv_tstart 0 1 100 103
/**
 * Changes the given CV's parametric starting time.  This may affect the shape
 * of the curve.
 */
60
bool HermiteCurve::set_cv_tstart(int n, PN_stdfloat tstart);

360 11 set_cv_name 0 4 533 25 HermiteCurve::set_cv_name 0 1 101 60
/**
 * Changes the name associated with a particular CV.
 */
56
bool HermiteCurve::set_cv_name(int n, char const *name);

361 11 get_cv_type 0 4 533 25 HermiteCurve::get_cv_type 0 1 102 120
/**
 * Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or
 * HC_SMOOTH, or 0 if there is no such CV.
 */
43
int HermiteCurve::get_cv_type(int n) const;

362 12 get_cv_point 0 4 533 26 HermiteCurve::get_cv_point 0 2 103 104 48
/**
 * Returns the position of the given CV.
 */
117
LVecBase3 const &HermiteCurve::get_cv_point(int n) const;
void HermiteCurve::get_cv_point(int n, LVecBase3 &v) const;

363 9 get_cv_in 0 4 533 23 HermiteCurve::get_cv_in 0 2 105 106 50
/**
 * Returns the in tangent of the given CV.
 */
111
LVecBase3 const &HermiteCurve::get_cv_in(int n) const;
void HermiteCurve::get_cv_in(int n, LVecBase3 &v) const;

364 10 get_cv_out 0 4 533 24 HermiteCurve::get_cv_out 0 2 107 108 51
/**
 * Returns the out tangent of the given CV.
 */
113
LVecBase3 const &HermiteCurve::get_cv_out(int n) const;
void HermiteCurve::get_cv_out(int n, LVecBase3 &v) const;

365 13 get_cv_tstart 0 4 533 27 HermiteCurve::get_cv_tstart 0 1 109 74
/**
 * Returns the starting point in parametric space of the given CV.
 */
53
PN_stdfloat HermiteCurve::get_cv_tstart(int n) const;

366 11 get_cv_name 0 4 533 25 HermiteCurve::get_cv_name 0 1 110 53
/**
 * Returns the name of the given CV, or NULL.
 */
51
std::string HermiteCurve::get_cv_name(int n) const;

367 8 write_cv 0 4 533 22 HermiteCurve::write_cv 0 1 111 10
/**
 *
 */
60
void HermiteCurve::write_cv(std::ostream &out, int n) const;

368 14 get_class_type 0 4 533 28 HermiteCurve::get_class_type 0 1 112 0
53
static TypeHandle HermiteCurve::get_class_type(void);

369 20 ~NurbsCurveInterface 0 6 534 41 NurbsCurveInterface::~NurbsCurveInterface 0 0 10
/**
 *
 */
56
virtual NurbsCurveInterface::~NurbsCurveInterface(void);

370 9 set_order 0 6 534 30 NurbsCurveInterface::set_order 0 1 113 0
59
virtual void NurbsCurveInterface::set_order(int order) = 0;

371 9 get_order 0 6 534 30 NurbsCurveInterface::get_order 0 1 114 0
59
virtual int NurbsCurveInterface::get_order(void) const = 0;

372 11 get_num_cvs 0 6 534 32 NurbsCurveInterface::get_num_cvs 0 1 115 0
61
virtual int NurbsCurveInterface::get_num_cvs(void) const = 0;

373 13 get_num_knots 0 6 534 34 NurbsCurveInterface::get_num_knots 0 1 116 0
63
virtual int NurbsCurveInterface::get_num_knots(void) const = 0;

374 9 insert_cv 0 6 534 30 NurbsCurveInterface::insert_cv 0 1 117 0
63
virtual bool NurbsCurveInterface::insert_cv(PN_stdfloat t) = 0;

375 9 append_cv 0 4 534 30 NurbsCurveInterface::append_cv 0 3 118 119 120 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
213
inline int NurbsCurveInterface::append_cv(PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline int NurbsCurveInterface::append_cv(LVecBase3 const &v);
inline int NurbsCurveInterface::append_cv(LVecBase4 const &v);

376 9 remove_cv 0 6 534 30 NurbsCurveInterface::remove_cv 0 1 121 0
55
virtual bool NurbsCurveInterface::remove_cv(int n) = 0;

377 14 remove_all_cvs 0 6 534 35 NurbsCurveInterface::remove_all_cvs 0 1 122 0
59
virtual void NurbsCurveInterface::remove_all_cvs(void) = 0;

378 12 set_cv_point 0 4 534 33 NurbsCurveInterface::set_cv_point 0 2 123 124 174
/**
 * Repositions the indicated CV.  Returns true if successful, false otherwise.
 */

/**
 * Repositions the indicated CV.  Returns true if successful, false otherwise.
 */
172
inline bool NurbsCurveInterface::set_cv_point(int n, PN_stdfloat x, PN_stdfloat y, PN_stdfloat z);
inline bool NurbsCurveInterface::set_cv_point(int n, LVecBase3 const &v);

379 12 get_cv_point 0 4 534 33 NurbsCurveInterface::get_cv_point 0 1 125 52
/**
 * Returns the position of the indicated CV.
 */
64
inline LVecBase3 NurbsCurveInterface::get_cv_point(int n) const;

380 13 set_cv_weight 0 4 534 34 NurbsCurveInterface::set_cv_weight 0 1 126 94
/**
 * Sets the weight of the indicated CV without affecting its position in 3-d
 * space.
 */
62
bool NurbsCurveInterface::set_cv_weight(int n, PN_stdfloat w);

381 13 get_cv_weight 0 4 534 34 NurbsCurveInterface::get_cv_weight 0 1 127 50
/**
 * Returns the weight of the indicated CV.
 */
67
inline PN_stdfloat NurbsCurveInterface::get_cv_weight(int n) const;

382 6 set_cv 0 6 534 27 NurbsCurveInterface::set_cv 0 1 128 0
72
virtual bool NurbsCurveInterface::set_cv(int n, LVecBase4 const &v) = 0;

383 6 get_cv 0 6 534 27 NurbsCurveInterface::get_cv 0 1 129 0
63
virtual LVecBase4 NurbsCurveInterface::get_cv(int n) const = 0;

384 8 set_knot 0 6 534 29 NurbsCurveInterface::set_knot 0 1 130 0
69
virtual bool NurbsCurveInterface::set_knot(int n, PN_stdfloat t) = 0;

385 8 get_knot 0 6 534 29 NurbsCurveInterface::get_knot 0 1 131 0
67
virtual PN_stdfloat NurbsCurveInterface::get_knot(int n) const = 0;

386 8 write_cv 0 4 534 29 NurbsCurveInterface::write_cv 0 1 132 10
/**
 *
 */
67
void NurbsCurveInterface::write_cv(std::ostream &out, int n) const;

387 14 get_class_type 0 4 534 35 NurbsCurveInterface::get_class_type 0 1 133 0
60
static TypeHandle NurbsCurveInterface::get_class_type(void);

388 24 upcast_to_PiecewiseCurve 0 12 535 36 NurbsCurve::upcast_to_PiecewiseCurve 0 1 137 40
upcast from NurbsCurve to PiecewiseCurve
59
PiecewiseCurve *NurbsCurve::upcast_to_PiecewiseCurve(void);

389 22 downcast_to_NurbsCurve 0 12 532 38 PiecewiseCurve::downcast_to_NurbsCurve 0 0 42
downcast from PiecewiseCurve to NurbsCurve
57
NurbsCurve *PiecewiseCurve::downcast_to_NurbsCurve(void);

390 29 upcast_to_NurbsCurveInterface 0 12 535 41 NurbsCurve::upcast_to_NurbsCurveInterface 0 1 138 45
upcast from NurbsCurve to NurbsCurveInterface
69
NurbsCurveInterface *NurbsCurve::upcast_to_NurbsCurveInterface(void);

391 22 downcast_to_NurbsCurve 0 12 534 43 NurbsCurveInterface::downcast_to_NurbsCurve 0 0 47
downcast from NurbsCurveInterface to NurbsCurve
62
NurbsCurve *NurbsCurveInterface::downcast_to_NurbsCurve(void);

392 10 NurbsCurve 0 4 535 22 NurbsCurve::NurbsCurve 0 2 134 135 188
/**
 *
 */

/**
 * Constructs a NURBS curve equivalent to the indicated (possibly non-NURBS)
 * curve.
 */

/**
 * Constructs a NURBS curve according to the indicated NURBS parameters.
 */
80
NurbsCurve::NurbsCurve(void);
NurbsCurve::NurbsCurve(ParametricCurve const &pc);

393 11 ~NurbsCurve 0 6 535 23 NurbsCurve::~NurbsCurve 0 0 10
/**
 *
 */
38
virtual NurbsCurve::~NurbsCurve(void);

394 14 get_class_type 0 4 535 26 NurbsCurve::get_class_type 0 1 136 0
51
static TypeHandle NurbsCurve::get_class_type(void);

395 11 get_start_t 0 4 536 29 NurbsCurveResult::get_start_t 0 1 140 81
/**
 * Returns the first legal value of t on the curve.  Usually this is 0.0.
 */
61
inline PN_stdfloat NurbsCurveResult::get_start_t(void) const;

396 9 get_end_t 0 4 536 27 NurbsCurveResult::get_end_t 0 1 141 58
/**
 * Returns the last legal value of t on the curve.
 */
59
inline PN_stdfloat NurbsCurveResult::get_end_t(void) const;

397 10 eval_point 0 4 536 28 NurbsCurveResult::eval_point 0 1 142 158
/**
 * Computes the point on the curve corresponding to the indicated value in
 * parametric time.  Returns true if the t value is valid, false otherwise.
 */
74
inline bool NurbsCurveResult::eval_point(PN_stdfloat t, LVecBase3 &point);

398 12 eval_tangent 0 4 536 30 NurbsCurveResult::eval_tangent 0 1 143 193
/**
 * Computes the tangent to the curve at the indicated point in parametric
 * time.  This tangent vector will not necessarily be normalized, and could be
 * zero.  See also eval_point().
 */
78
inline bool NurbsCurveResult::eval_tangent(PN_stdfloat t, LVecBase3 &tangent);

399 19 eval_extended_point 0 4 536 37 NurbsCurveResult::eval_extended_point 0 1 144 145
/**
 * Evaluates the curve in n-dimensional space according to the extended
 * vertices associated with the curve in the indicated dimension.
 */
79
inline PN_stdfloat NurbsCurveResult::eval_extended_point(PN_stdfloat t, int d);

400 20 eval_extended_points 0 4 536 38 NurbsCurveResult::eval_extended_points 0 1 145 248
/**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */
111
inline bool NurbsCurveResult::eval_extended_points(PN_stdfloat t, int d, PN_stdfloat result[], int num_values);

401 16 get_num_segments 0 4 536 34 NurbsCurveResult::get_num_segments 0 1 146 170
/**
 * Returns the number of piecewise continuous segments within the curve.  This
 * number is usually not important unless you plan to call
 * eval_segment_point().
 */
58
inline int NurbsCurveResult::get_num_segments(void) const;

402 18 eval_segment_point 0 4 536 36 NurbsCurveResult::eval_segment_point 0 1 147 637
/**
 * Evaluates the point on the curve corresponding to the indicated value in
 * parametric time within the indicated curve segment.  t should be in the
 * range [0, 1].
 *
 * The curve is internally represented as a number of connected (or possibly
 * unconnected) piecewise continuous segments.  The exact number of segments
 * for a particular curve depends on the knot vector, and is returned by
 * get_num_segments().  Normally, eval_point() is used to evaluate a point
 * along the continuous curve, but when you care more about local continuity,
 * you can use eval_segment_point() to evaluate the points along each segment.
 */
94
void NurbsCurveResult::eval_segment_point(int segment, PN_stdfloat t, LVecBase3 &point) const;

403 20 eval_segment_tangent 0 4 536 38 NurbsCurveResult::eval_segment_tangent 0 1 148 207
/**
 * As eval_segment_point, but computes the tangent to the curve at the
 * indicated point.  The tangent vector will not necessarily be normalized,
 * and could be zero, particularly at the endpoints.
 */
98
void NurbsCurveResult::eval_segment_tangent(int segment, PN_stdfloat t, LVecBase3 &tangent) const;

404 27 eval_segment_extended_point 0 4 536 45 NurbsCurveResult::eval_segment_extended_point 0 1 149 145
/**
 * Evaluates the curve in n-dimensional space according to the extended
 * vertices associated with the curve in the indicated dimension.
 */
99
PN_stdfloat NurbsCurveResult::eval_segment_extended_point(int segment, PN_stdfloat t, int d) const;

405 28 eval_segment_extended_points 0 4 536 46 NurbsCurveResult::eval_segment_extended_points 0 1 150 248
/**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */
131
void NurbsCurveResult::eval_segment_extended_points(int segment, PN_stdfloat t, int d, PN_stdfloat result[], int num_values) const;

406 13 get_segment_t 0 4 536 31 NurbsCurveResult::get_segment_t 0 1 151 217
/**
 * Accepts a t value in the range [0, 1], and assumed to be relative to the
 * indicated segment (as in eval_segment_point()), and returns the
 * corresponding t value in the entire curve (as in eval_point()).
 */
85
inline PN_stdfloat NurbsCurveResult::get_segment_t(int segment, PN_stdfloat t) const;

407 15 adaptive_sample 0 4 536 33 NurbsCurveResult::adaptive_sample 0 1 152 330
/**
 * Determines the set of subdivisions necessary to approximate the curve with
 * a set of linear segments, no point of which is farther than tolerance units
 * from the actual curve.
 *
 * After this call, you may walk through the resulting set of samples with
 * get_num_samples(), get_sample_t(), and get_sample_point().
 */
62
void NurbsCurveResult::adaptive_sample(PN_stdfloat tolerance);

408 15 get_num_samples 0 4 536 33 NurbsCurveResult::get_num_samples 0 1 153 102
/**
 * Returns the number of sample points generated by the previous call to
 * adaptive_sample().
 */
57
inline int NurbsCurveResult::get_num_samples(void) const;

409 12 get_sample_t 0 4 536 30 NurbsCurveResult::get_sample_t 0 1 154 110
/**
 * Returns the t value of the nth sample point generated by the previous call
 * to adaptive_sample().
 */
63
inline PN_stdfloat NurbsCurveResult::get_sample_t(int n) const;

410 16 get_sample_point 0 4 536 34 NurbsCurveResult::get_sample_point 0 1 155 252
/**
 * Returns the point on the curve of the nth sample point generated by the
 * previous call to adaptive_sample().
 *
 * For tangents, or extended points, you should use get_sample_t() and pass it
 * into eval_tangent() or eval_extended_point().
 */
70
inline LPoint3 const &NurbsCurveResult::get_sample_point(int n) const;

411 16 NurbsCurveResult 0 4 536 34 NurbsCurveResult::NurbsCurveResult 0 1 139 174
/**
 * The constructor automatically builds up the result as the product of the
 * indicated set of basis matrices and the indicated table of control vertex
 * positions.
 */
78
inline NurbsCurveResult::NurbsCurveResult(NurbsCurveResult const &) = default;

412 19 NurbsCurveEvaluator 0 4 537 40 NurbsCurveEvaluator::NurbsCurveEvaluator 0 2 156 157 10
/**
 *
 */
135
NurbsCurveEvaluator::NurbsCurveEvaluator(void);
inline NurbsCurveEvaluator::NurbsCurveEvaluator(NurbsCurveEvaluator const &) = default;

413 9 set_order 0 4 537 30 NurbsCurveEvaluator::set_order 0 1 158 224
/**
 * Sets the order of the curve.  This resets the knot vector to the default
 * knot vector for the number of vertices.
 *
 * The order must be 1, 2, 3, or 4, and the value is one more than the degree
 * of the curve.
 */
54
inline void NurbsCurveEvaluator::set_order(int order);

414 9 get_order 0 4 537 30 NurbsCurveEvaluator::get_order 0 1 159 83
/**
 * Returns the order of the curve as set by a previous call to set_order().
 */
54
inline int NurbsCurveEvaluator::get_order(void) const;

415 5 reset 0 4 537 26 NurbsCurveEvaluator::reset 0 1 160 231
/**
 * Resets all the vertices and knots to their default values, and sets the
 * curve up with the indicated number of vertices.  You must then call
 * set_vertex() repeatedly to fill in all of the vertex values appropriately.
 */
50
void NurbsCurveEvaluator::reset(int num_vertices);

416 16 get_num_vertices 0 4 537 37 NurbsCurveEvaluator::get_num_vertices 0 1 161 122
/**
 * Returns the number of control vertices in the curve.  This is the number
 * passed to the last call to reset().
 */
61
inline int NurbsCurveEvaluator::get_num_vertices(void) const;

417 10 set_vertex 0 4 537 31 NurbsCurveEvaluator::set_vertex 0 2 162 163 441
/**
 * Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous
 * space.  In this form, the first three components of the vertex should
 * already have been scaled by the fourth component, which is the homogeneous
 * weight.
 */

/**
 * Sets the nth control vertex of the curve.  This flavor sets the vertex as a
 * 3-d coordinate and a weight; the 3-d coordinate values are implicitly
 * scaled up by the weight factor.
 */
179
inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase4 const &vertex);
inline void NurbsCurveEvaluator::set_vertex(int i, LVecBase3 const &vertex, PN_stdfloat weight = 1.0);

418 10 get_vertex 0 4 537 31 NurbsCurveEvaluator::get_vertex 0 2 164 165 202
/**
 * Returns the nth control vertex of the curve, relative to its indicated
 * coordinate space.
 */

/**
 * Returns the nth control vertex of the curve, relative to the given
 * coordinate space.
 */
156
inline LVecBase4 const &NurbsCurveEvaluator::get_vertex(int i) const;
inline LVecBase4 NurbsCurveEvaluator::get_vertex(int i, NodePath const &rel_to) const;

419 16 set_vertex_space 0 4 537 37 NurbsCurveEvaluator::set_vertex_space 0 2 166 167 792
/**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty NodePath, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a fixed NodePath, which is always the same
 * NodePath.  Also see setting the space as a path string, which can specify a
 * different NodePath for different instances of the curve.
 */

/**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty string, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a string, which describes the path to find the
 * node relative to the rel_to NodePath when the curve is evaluated.
 */
164
inline void NurbsCurveEvaluator::set_vertex_space(int i, NodePath const &space);
inline void NurbsCurveEvaluator::set_vertex_space(int i, std::string const &space);

420 16 get_vertex_space 0 4 537 37 NurbsCurveEvaluator::get_vertex_space 0 1 168 107
/**
 * Returns the coordinate space of the nth control vertex of the curve,
 * expressed as a NodePath.
 */
84
NodePath NurbsCurveEvaluator::get_vertex_space(int i, NodePath const &rel_to) const;

421 19 set_extended_vertex 0 4 537 40 NurbsCurveEvaluator::set_extended_vertex 0 1 169 768
/**
 * Sets an n-dimensional vertex value.  This allows definition of a NURBS
 * surface or curve in a sparse n-dimensional space, typically used for
 * associating additional properties (like color or joint membership) with
 * each vertex of a surface.
 *
 * The value d is an arbitrary integer value and specifies the dimension of
 * question for this particular vertex.  Any number of dimensions may be
 * specified, and they need not be consecutive.  If a value for a given
 * dimension is not specified, is it implicitly 0.0.
 *
 * The value is implicitly scaled by the homogenous weight value--that is, the
 * fourth component of the value passed to set_vertex().  This means the
 * ordinary vertex must be set first, before the extended vertices can be set.
 */
86
inline void NurbsCurveEvaluator::set_extended_vertex(int i, int d, PN_stdfloat value);

422 19 get_extended_vertex 0 4 537 40 NurbsCurveEvaluator::get_extended_vertex 0 1 170 172
/**
 * Returns an n-dimensional vertex value.  See set_extended_vertex().  This
 * returns the value set for the indicated dimension, or 0.0 if nothing has
 * been set.
 */
80
inline PN_stdfloat NurbsCurveEvaluator::get_extended_vertex(int i, int d) const;

423 21 set_extended_vertices 0 4 537 42 NurbsCurveEvaluator::set_extended_vertices 0 1 171 259
/**
 * Simultaneously sets several extended values in the slots d through (d +
 * num_values - 1) from the num_values elements of the indicated array.  This
 * is equivalent to calling set_extended_vertex() num_values times.  See
 * set_extended_vertex().
 */
106
void NurbsCurveEvaluator::set_extended_vertices(int i, int d, PN_stdfloat const values[], int num_values);

424 13 get_num_knots 0 4 537 34 NurbsCurveEvaluator::get_num_knots 0 1 172 117
/**
 * Returns the number of knot values in the curve.  This is based on the
 * number of vertices and the order.
 */
58
inline int NurbsCurveEvaluator::get_num_knots(void) const;

425 8 set_knot 0 4 537 29 NurbsCurveEvaluator::set_knot 0 1 173 184
/**
 * Sets the value of the nth knot.  Each knot value should be greater than or
 * equal to the preceding value.  If no knot values are set, a default knot
 * vector is supplied.
 */
60
void NurbsCurveEvaluator::set_knot(int i, PN_stdfloat knot);

426 8 get_knot 0 4 537 29 NurbsCurveEvaluator::get_knot 0 1 174 45
/**
 * Returns the value of the nth knot.
 */
55
PN_stdfloat NurbsCurveEvaluator::get_knot(int i) const;

427 15 normalize_knots 0 4 537 36 NurbsCurveEvaluator::normalize_knots 0 1 175 95
/**
 * Normalizes the knot sequence so that the parametric range of the curve is 0
 * .. 1.
 */
48
void NurbsCurveEvaluator::normalize_knots(void);

428 16 get_num_segments 0 4 537 37 NurbsCurveEvaluator::get_num_segments 0 1 176 114
/**
 * Returns the number of piecewise continuous segments in the curve.  This is
 * based on the knot vector.
 */
61
inline int NurbsCurveEvaluator::get_num_segments(void) const;

429 8 evaluate 0 4 537 29 NurbsCurveEvaluator::evaluate 0 2 177 178 447
/**
 * Returns a NurbsCurveResult object that represents the result of applying
 * the knots to all of the current values of the vertices, transformed into
 * the indicated coordinate space.
 */

/**
 * Returns a NurbsCurveResult object that represents the result of applying
 * the knots to all of the current values of the vertices, transformed into
 * the indicated coordinate space, and then further transformed by the
 * indicated matrix.
 */
215
PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to = NodePath()) const;
PointerTo< NurbsCurveResult > NurbsCurveEvaluator::evaluate(NodePath const &rel_to, LMatrix4 const &mat) const;

430 6 output 0 4 537 27 NurbsCurveEvaluator::output 0 1 179 10
/**
 *
 */
58
void NurbsCurveEvaluator::output(std::ostream &out) const;

431 11 get_start_u 0 4 538 31 NurbsSurfaceResult::get_start_u 0 1 181 83
/**
 * Returns the first legal value of u on the surface.  Usually this is 0.0.
 */
63
inline PN_stdfloat NurbsSurfaceResult::get_start_u(void) const;

432 9 get_end_u 0 4 538 29 NurbsSurfaceResult::get_end_u 0 1 182 60
/**
 * Returns the last legal value of u on the surface.
 */
61
inline PN_stdfloat NurbsSurfaceResult::get_end_u(void) const;

433 11 get_start_v 0 4 538 31 NurbsSurfaceResult::get_start_v 0 1 183 83
/**
 * Returns the first legal value of v on the surface.  Usually this is 0.0.
 */
63
inline PN_stdfloat NurbsSurfaceResult::get_start_v(void) const;

434 9 get_end_v 0 4 538 29 NurbsSurfaceResult::get_end_v 0 1 184 60
/**
 * Returns the last legal value of v on the surface.
 */
61
inline PN_stdfloat NurbsSurfaceResult::get_end_v(void) const;

435 10 eval_point 0 4 538 30 NurbsSurfaceResult::eval_point 0 1 185 168
/**
 * Computes the point on the surface corresponding to the indicated value in
 * parametric time.  Returns true if the u, v values are valid, false
 * otherwise.
 */
91
inline bool NurbsSurfaceResult::eval_point(PN_stdfloat u, PN_stdfloat v, LVecBase3 &point);

436 11 eval_normal 0 4 538 31 NurbsSurfaceResult::eval_normal 0 1 186 193
/**
 * Computes the normal to the surface at the indicated point in parametric
 * time.  This normal vector will not necessarily be normalized, and could be
 * zero.  See also eval_point().
 */
93
inline bool NurbsSurfaceResult::eval_normal(PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal);

437 19 eval_extended_point 0 4 538 39 NurbsSurfaceResult::eval_extended_point 0 1 187 149
/**
 * Evaluates the surface in n-dimensional space according to the extended
 * vertices associated with the surface in the indicated dimension.
 */
96
inline PN_stdfloat NurbsSurfaceResult::eval_extended_point(PN_stdfloat u, PN_stdfloat v, int d);

438 20 eval_extended_points 0 4 538 40 NurbsSurfaceResult::eval_extended_points 0 1 188 248
/**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */
128
inline bool NurbsSurfaceResult::eval_extended_points(PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values);

439 18 get_num_u_segments 0 4 538 38 NurbsSurfaceResult::get_num_u_segments 0 1 189 191
/**
 * Returns the number of piecewise continuous segments within the surface in
 * the U direction.  This number is usually not important unless you plan to
 * call eval_segment_point().
 */
62
inline int NurbsSurfaceResult::get_num_u_segments(void) const;

440 18 get_num_v_segments 0 4 538 38 NurbsSurfaceResult::get_num_v_segments 0 1 190 191
/**
 * Returns the number of piecewise continuous segments within the surface in
 * the V direction.  This number is usually not important unless you plan to
 * call eval_segment_point().
 */
62
inline int NurbsSurfaceResult::get_num_v_segments(void) const;

441 18 eval_segment_point 0 4 538 38 NurbsSurfaceResult::eval_segment_point 0 1 191 656
/**
 * Evaluates the point on the surface corresponding to the indicated value in
 * parametric time within the indicated surface segment.  u and v should be in
 * the range [0, 1].
 *
 * The surface is internally represented as a number of connected (or possibly
 * unconnected) piecewise continuous segments.  The exact number of segments
 * for a particular surface depends on the knot vector, and is returned by
 * get_num_segments().  Normally, eval_point() is used to evaluate a point
 * along the continuous surface, but when you care more about local
 * continuity, you can use eval_segment_point() to evaluate the points along
 * each segment.
 */
114
void NurbsSurfaceResult::eval_segment_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &point) const;

442 19 eval_segment_normal 0 4 538 39 NurbsSurfaceResult::eval_segment_normal 0 1 192 176
/**
 * As eval_segment_point, but computes the normal to the surface at the
 * indicated point.  The normal vector will not necessarily be normalized, and
 * could be zero.
 */
116
void NurbsSurfaceResult::eval_segment_normal(int ui, int vi, PN_stdfloat u, PN_stdfloat v, LVecBase3 &normal) const;

443 27 eval_segment_extended_point 0 4 538 47 NurbsSurfaceResult::eval_segment_extended_point 0 1 193 149
/**
 * Evaluates the surface in n-dimensional space according to the extended
 * vertices associated with the surface in the indicated dimension.
 */
119
PN_stdfloat NurbsSurfaceResult::eval_segment_extended_point(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d) const;

444 28 eval_segment_extended_points 0 4 538 48 NurbsSurfaceResult::eval_segment_extended_points 0 1 194 248
/**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */
151
void NurbsSurfaceResult::eval_segment_extended_points(int ui, int vi, PN_stdfloat u, PN_stdfloat v, int d, PN_stdfloat result[], int num_values) const;

445 13 get_segment_u 0 4 538 33 NurbsSurfaceResult::get_segment_u 0 1 195 219
/**
 * Accepts a u value in the range [0, 1], and assumed to be relative to the
 * indicated segment (as in eval_segment_point()), and returns the
 * corresponding u value in the entire surface (as in eval_point()).
 */
82
inline PN_stdfloat NurbsSurfaceResult::get_segment_u(int ui, PN_stdfloat u) const;

446 13 get_segment_v 0 4 538 33 NurbsSurfaceResult::get_segment_v 0 1 196 219
/**
 * Accepts a v value in the range [0, 1], and assumed to be relative to the
 * indicated segment (as in eval_segment_point()), and returns the
 * corresponding v value in the entire surface (as in eval_point()).
 */
82
inline PN_stdfloat NurbsSurfaceResult::get_segment_v(int vi, PN_stdfloat v) const;

447 18 NurbsSurfaceResult 0 4 538 38 NurbsSurfaceResult::NurbsSurfaceResult 0 1 180 174
/**
 * The constructor automatically builds up the result as the product of the
 * indicated set of basis matrices and the indicated table of control vertex
 * positions.
 */
84
inline NurbsSurfaceResult::NurbsSurfaceResult(NurbsSurfaceResult const &) = default;

448 21 NurbsSurfaceEvaluator 0 4 539 44 NurbsSurfaceEvaluator::NurbsSurfaceEvaluator 0 2 197 198 10
/**
 *
 */
145
NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(void);
inline NurbsSurfaceEvaluator::NurbsSurfaceEvaluator(NurbsSurfaceEvaluator const &) = default;

449 11 set_u_order 0 4 539 34 NurbsSurfaceEvaluator::set_u_order 0 1 199 247
/**
 * Sets the order of the surface in the U direction.  This resets the knot
 * vector to the default knot vector for the number of vertices.
 *
 * The order must be 1, 2, 3, or 4, and the value is one more than the degree
 * of the surface.
 */
60
inline void NurbsSurfaceEvaluator::set_u_order(int u_order);

450 11 get_u_order 0 4 539 34 NurbsSurfaceEvaluator::get_u_order 0 1 200 109
/**
 * Returns the order of the surface in the U direction as set by a previous
 * call to set_u_order().
 */
58
inline int NurbsSurfaceEvaluator::get_u_order(void) const;

451 11 set_v_order 0 4 539 34 NurbsSurfaceEvaluator::set_v_order 0 1 201 247
/**
 * Sets the order of the surface in the V direction.  This resets the knot
 * vector to the default knot vector for the number of vertices.
 *
 * The order must be 1, 2, 3, or 4, and the value is one more than the degree
 * of the surface.
 */
60
inline void NurbsSurfaceEvaluator::set_v_order(int v_order);

452 11 get_v_order 0 4 539 34 NurbsSurfaceEvaluator::get_v_order 0 1 202 109
/**
 * Returns the order of the surface in the V direction as set by a previous
 * call to set_v_order().
 */
58
inline int NurbsSurfaceEvaluator::get_v_order(void) const;

453 5 reset 0 4 539 28 NurbsSurfaceEvaluator::reset 0 1 203 233
/**
 * Resets all the vertices and knots to their default values, and sets the
 * surface up with the indicated number of vertices.  You must then call
 * set_vertex() repeatedly to fill in all of the vertex values appropriately.
 */
74
void NurbsSurfaceEvaluator::reset(int num_u_vertices, int num_v_vertices);

454 18 get_num_u_vertices 0 4 539 41 NurbsSurfaceEvaluator::get_num_u_vertices 0 1 204 142
/**
 * Returns the number of control vertices in the U direction on the surface.
 * This is the number passed to the last call to reset().
 */
65
inline int NurbsSurfaceEvaluator::get_num_u_vertices(void) const;

455 18 get_num_v_vertices 0 4 539 41 NurbsSurfaceEvaluator::get_num_v_vertices 0 1 205 142
/**
 * Returns the number of control vertices in the V direction on the surface.
 * This is the number passed to the last call to reset().
 */
65
inline int NurbsSurfaceEvaluator::get_num_v_vertices(void) const;

456 10 set_vertex 0 4 539 33 NurbsSurfaceEvaluator::set_vertex 0 2 206 207 445
/**
 * Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous
 * space.  In this form, the first three components of the vertex should
 * already have been scaled by the fourth component, which is the homogeneous
 * weight.
 */

/**
 * Sets the nth control vertex of the surface.  This flavor sets the vertex as
 * a 3-d coordinate and a weight; the 3-d coordinate values are implicitly
 * scaled up by the weight factor.
 */
201
inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase4 const &vertex);
inline void NurbsSurfaceEvaluator::set_vertex(int ui, int vi, LVecBase3 const &vertex, PN_stdfloat weight = 1.0);

457 10 get_vertex 0 4 539 33 NurbsSurfaceEvaluator::get_vertex 0 2 208 209 206
/**
 * Returns the nth control vertex of the surface, relative to its indicated
 * coordinate space.
 */

/**
 * Returns the nth control vertex of the surface, relative to the given
 * coordinate space.
 */
178
inline LVecBase4 const &NurbsSurfaceEvaluator::get_vertex(int ui, int vi) const;
inline LVecBase4 NurbsSurfaceEvaluator::get_vertex(int ui, int vi, NodePath const &rel_to) const;

458 16 set_vertex_space 0 4 539 39 NurbsSurfaceEvaluator::set_vertex_space 0 2 210 211 796
/**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty NodePath, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a fixed NodePath, which is always the same
 * NodePath.  Also see setting the space as a path string, which can specify a
 * different NodePath for different instances of the surface.
 */

/**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty string, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a string, which describes the path to find the
 * node relative to the rel_to NodePath when the surface is evaluated.
 */
186
inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, NodePath const &space);
inline void NurbsSurfaceEvaluator::set_vertex_space(int ui, int vi, std::string const &space);

459 16 get_vertex_space 0 4 539 39 NurbsSurfaceEvaluator::get_vertex_space 0 1 212 109
/**
 * Returns the coordinate space of the nth control vertex of the surface,
 * expressed as a NodePath.
 */
95
NodePath NurbsSurfaceEvaluator::get_vertex_space(int ui, int vi, NodePath const &rel_to) const;

460 19 set_extended_vertex 0 4 539 42 NurbsSurfaceEvaluator::set_extended_vertex 0 1 213 770
/**
 * Sets an n-dimensional vertex value.  This allows definition of a NURBS
 * surface or surface in a sparse n-dimensional space, typically used for
 * associating additional properties (like color or joint membership) with
 * each vertex of a surface.
 *
 * The value d is an arbitrary integer value and specifies the dimension of
 * question for this particular vertex.  Any number of dimensions may be
 * specified, and they need not be consecutive.  If a value for a given
 * dimension is not specified, is it implicitly 0.0.
 *
 * The value is implicitly scaled by the homogenous weight value--that is, the
 * fourth component of the value passed to set_vertex().  This means the
 * ordinary vertex must be set first, before the extended vertices can be set.
 */
97
inline void NurbsSurfaceEvaluator::set_extended_vertex(int ui, int vi, int d, PN_stdfloat value);

461 19 get_extended_vertex 0 4 539 42 NurbsSurfaceEvaluator::get_extended_vertex 0 1 214 172
/**
 * Returns an n-dimensional vertex value.  See set_extended_vertex().  This
 * returns the value set for the indicated dimension, or 0.0 if nothing has
 * been set.
 */
91
inline PN_stdfloat NurbsSurfaceEvaluator::get_extended_vertex(int ui, int vi, int d) const;

462 21 set_extended_vertices 0 4 539 44 NurbsSurfaceEvaluator::set_extended_vertices 0 1 215 259
/**
 * Simultaneously sets several extended values in the slots d through (d +
 * num_values - 1) from the num_values elements of the indicated array.  This
 * is equivalent to calling set_extended_vertex() num_values times.  See
 * set_extended_vertex().
 */
117
void NurbsSurfaceEvaluator::set_extended_vertices(int ui, int vi, int d, PN_stdfloat const values[], int num_values);

463 15 get_num_u_knots 0 4 539 38 NurbsSurfaceEvaluator::get_num_u_knots 0 1 216 138
/**
 * Returns the number of knot values in the surface in the U direction.  This
 * is based on the number of vertices and the order.
 */
62
inline int NurbsSurfaceEvaluator::get_num_u_knots(void) const;

464 10 set_u_knot 0 4 539 33 NurbsSurfaceEvaluator::set_u_knot 0 1 217 184
/**
 * Sets the value of the nth knot.  Each knot value should be greater than or
 * equal to the preceding value.  If no knot values are set, a default knot
 * vector is supplied.
 */
64
void NurbsSurfaceEvaluator::set_u_knot(int i, PN_stdfloat knot);

465 10 get_u_knot 0 4 539 33 NurbsSurfaceEvaluator::get_u_knot 0 1 218 45
/**
 * Returns the value of the nth knot.
 */
59
PN_stdfloat NurbsSurfaceEvaluator::get_u_knot(int i) const;

466 17 normalize_u_knots 0 4 539 40 NurbsSurfaceEvaluator::normalize_u_knots 0 1 219 116
/**
 * Normalizes the knot sequence so that the parametric range of the surface in
 * the U direction is 0 .. 1.
 */
52
void NurbsSurfaceEvaluator::normalize_u_knots(void);

467 15 get_num_v_knots 0 4 539 38 NurbsSurfaceEvaluator::get_num_v_knots 0 1 220 138
/**
 * Returns the number of knot values in the surface in the V direction.  This
 * is based on the number of vertices and the order.
 */
62
inline int NurbsSurfaceEvaluator::get_num_v_knots(void) const;

468 10 set_v_knot 0 4 539 33 NurbsSurfaceEvaluator::set_v_knot 0 1 221 184
/**
 * Sets the value of the nth knot.  Each knot value should be greater than or
 * equal to the preceding value.  If no knot values are set, a default knot
 * vector is supplied.
 */
64
void NurbsSurfaceEvaluator::set_v_knot(int i, PN_stdfloat knot);

469 10 get_v_knot 0 4 539 33 NurbsSurfaceEvaluator::get_v_knot 0 1 222 45
/**
 * Returns the value of the nth knot.
 */
59
PN_stdfloat NurbsSurfaceEvaluator::get_v_knot(int i) const;

470 17 normalize_v_knots 0 4 539 40 NurbsSurfaceEvaluator::normalize_v_knots 0 1 223 116
/**
 * Normalizes the knot sequence so that the parametric range of the surface in
 * the U direction is 0 .. 1.
 */
52
void NurbsSurfaceEvaluator::normalize_v_knots(void);

471 18 get_num_u_segments 0 4 539 41 NurbsSurfaceEvaluator::get_num_u_segments 0 1 224 135
/**
 * Returns the number of piecewise continuous segments in the surface in the U
 * direction.  This is based on the knot vector.
 */
65
inline int NurbsSurfaceEvaluator::get_num_u_segments(void) const;

472 18 get_num_v_segments 0 4 539 41 NurbsSurfaceEvaluator::get_num_v_segments 0 1 225 135
/**
 * Returns the number of piecewise continuous segments in the surface in the V
 * direction.  This is based on the knot vector.
 */
65
inline int NurbsSurfaceEvaluator::get_num_v_segments(void) const;

473 8 evaluate 0 4 539 31 NurbsSurfaceEvaluator::evaluate 0 1 226 196
/**
 * Returns a NurbsSurfaceResult object that represents the result of applying
 * the knots to all of the current values of the vertices, transformed into
 * the indicated coordinate space.
 */
107
PointerTo< NurbsSurfaceResult > NurbsSurfaceEvaluator::evaluate(NodePath const &rel_to = NodePath()) const;

474 6 output 0 4 539 29 NurbsSurfaceEvaluator::output 0 1 227 10
/**
 *
 */
60
void NurbsSurfaceEvaluator::output(std::ostream &out) const;

475 0 0 0 0 0 0 0 0
0

476 0 0 0 0 0 0 0 0
0

477 8 RopeNode 0 4 541 18 RopeNode::RopeNode 0 1 228 22
/**
 *
 */

/**
 *
 */
53
explicit RopeNode::RopeNode(std::string const &name);

478 9 set_curve 0 4 541 19 RopeNode::set_curve 0 1 229 65
/**
 * Sets the particular curve represented by the RopeNode.
 */
60
inline void RopeNode::set_curve(NurbsCurveEvaluator *curve);

479 9 get_curve 0 4 541 19 RopeNode::get_curve 0 1 230 57
/**
 * Returns the curve represented by the RopeNode.
 */
60
inline NurbsCurveEvaluator *RopeNode::get_curve(void) const;

480 15 set_render_mode 0 4 541 25 RopeNode::set_render_mode 0 1 231 130
/**
 * Specifies the method used to render the rope.  The simplest is RM_thread,
 * which just draws a one-pixel line segment.
 */
72
inline void RopeNode::set_render_mode(RopeNode::RenderMode render_mode);

481 15 get_render_mode 0 4 541 25 RopeNode::get_render_mode 0 1 232 78
/**
 * Returns the method used to render the rope.  See set_render_mode().
 */
66
inline RopeNode::RenderMode RopeNode::get_render_mode(void) const;

482 11 set_uv_mode 0 4 541 21 RopeNode::set_uv_mode 0 1 233 72
/**
 * Specifies the algorithm to use to generate UV's for the rope.
 */
60
inline void RopeNode::set_uv_mode(RopeNode::UVMode uv_mode);

483 11 get_uv_mode 0 4 541 21 RopeNode::get_uv_mode 0 1 234 70
/**
 * Returns the algorithm to use to generate UV's for the rope.
 */
58
inline RopeNode::UVMode RopeNode::get_uv_mode(void) const;

484 16 set_uv_direction 0 4 541 26 RopeNode::set_uv_direction 0 1 235 115
/**
 * Specify true to vary the U coordinate down the length of the rope, or false
 * to vary the V coordinate.
 */
56
inline void RopeNode::set_uv_direction(bool u_dominant);

485 16 get_uv_direction 0 4 541 26 RopeNode::get_uv_direction 0 1 236 124
/**
 * Returns true if the rope runs down the U coordinate of the texture, or
 * false if it runs down the V coordinate.
 */
51
inline bool RopeNode::get_uv_direction(void) const;

486 12 set_uv_scale 0 4 541 22 RopeNode::set_uv_scale 0 1 237 206
/**
 * Specifies an additional scaling factor to apply to generated UV's along the
 * rope.  This scale factor is applied in whichever direction is along the
 * rope, as specified by set_uv_direction().
 */
54
inline void RopeNode::set_uv_scale(PN_stdfloat scale);

487 12 get_uv_scale 0 4 541 22 RopeNode::get_uv_scale 0 1 238 78
/**
 * Returns the scaling factor to apply to generated UV's for the rope.
 */
54
inline PN_stdfloat RopeNode::get_uv_scale(void) const;

488 15 set_normal_mode 0 4 541 25 RopeNode::set_normal_mode 0 1 239 192
/**
 * Specifies the kind of normals to generate for the rope.  This is only
 * applicable when the RenderMode is set to RM_tube; in the other render
 * modes, normals are never generated.
 */
72
inline void RopeNode::set_normal_mode(RopeNode::NormalMode normal_mode);

489 15 get_normal_mode 0 4 541 25 RopeNode::get_normal_mode 0 1 240 131
/**
 * Returns the kind of normals to generate for the rope.  This is only
 * applicable when the RenderMode is set to RM_tube.
 */
66
inline RopeNode::NormalMode RopeNode::get_normal_mode(void) const;

490 11 set_tube_up 0 4 541 21 RopeNode::set_tube_up 0 1 241 419
/**
 * Specifies a normal vector, generally perpendicular to the main axis of the
 * starting point of the curve, that controls the "top" of the curve, when
 * RenderMode is RM_tube.  This is used to orient the vertices that make up
 * the tube.  If this vector is too nearly parallel with the starting
 * direction of the curve, there may be a tendency for the whole tube to
 * gimble-lock around its primary axis.
 */
59
inline void RopeNode::set_tube_up(LVector3 const &tube_up);

491 11 get_tube_up 0 4 541 21 RopeNode::get_tube_up 0 1 242 127
/**
 * Returns the normal vector used to control the "top" of the curve, when
 * RenderMode is RM_tube.  See set_tube_up().
 */
57
inline LVector3 const &RopeNode::get_tube_up(void) const;

492 20 set_use_vertex_color 0 4 541 30 RopeNode::set_use_vertex_color 0 1 243 351
/**
 * Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
 * color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,
 * respectively, of the extended vertex values, where n is the value returned
 * by get_vertex_color_dimension().  Use
 * NurbsCurveEvaluator::set_extended_vertex() to set these values.
 */
54
inline void RopeNode::set_use_vertex_color(bool flag);

493 20 get_use_vertex_color 0 4 541 30 RopeNode::get_use_vertex_color 0 1 244 76
/**
 * Returns the "use vertex color" flag.  See set_use_vertex_color().
 */
55
inline bool RopeNode::get_use_vertex_color(void) const;

494 26 get_vertex_color_dimension 0 4 541 36 RopeNode::get_vertex_color_dimension 0 1 245 221
/**
 * Returns the numeric extended dimension in which the color components should
 * be found.  See NurbsCurveEvaluator::set_extended_vertex().
 *
 * The color components will be expected at (n, n + 1, n + 2, n + 3).
 */
61
static inline int RopeNode::get_vertex_color_dimension(void);

495 14 set_num_subdiv 0 4 541 24 RopeNode::set_num_subdiv 0 1 246 154
/**
 * Specifies the number of subdivisions per cubic segment (that is, per unique
 * knot value) to draw in a fixed uniform tesselation of the curve.
 */
53
inline void RopeNode::set_num_subdiv(int num_subdiv);

496 14 get_num_subdiv 0 4 541 24 RopeNode::get_num_subdiv 0 1 247 98
/**
 * Returns the number of subdivisions per cubic segment to draw.  See
 * set_num_subdiv().
 */
48
inline int RopeNode::get_num_subdiv(void) const;

497 14 set_num_slices 0 4 541 24 RopeNode::set_num_slices 0 1 248 404
/**
 * Specifies the number of radial subdivisions to make if RenderMode is
 * RM_tube.  It is ignored in the other render modes.
 *
 * Increasing this number increases the roundness of a cross-section of the
 * tube.  The minimum value for a dimensional tube is 3; setting it to 2 will
 * get you a thin piece of tape (which is similar to RM_billboard, except it
 * won't rotate to face the camera).
 */
53
inline void RopeNode::set_num_slices(int num_slices);

498 14 get_num_slices 0 4 541 24 RopeNode::get_num_slices 0 1 249 153
/**
 * Returns the number of radial subdivisions to make if RenderMode is RM_tube.
 * It is ignored in the other render modes.  See set_num_slices().
 */
48
inline int RopeNode::get_num_slices(void) const;

499 24 set_use_vertex_thickness 0 4 541 34 RopeNode::set_use_vertex_thickness 0 1 250 418
/**
 * Sets the "use vertex thickness" flag.  When this is true, the vertex
 * thickness is assumed to be stored as the dimension
 * get_vertex_thickness_dimension(), of the extended vertex values.  Use
 * NurbsCurveEvaluator::set_extended_vertex() to set these values.
 *
 * In this mode, the overall thickness is also applied as a scale to the
 * vertex thickness.  Not all render modes support vertex thickness.
 */
58
inline void RopeNode::set_use_vertex_thickness(bool flag);

500 24 get_use_vertex_thickness 0 4 541 34 RopeNode::get_use_vertex_thickness 0 1 251 84
/**
 * Returns the "use vertex thickness" flag.  See set_use_vertex_thickness().
 */
59
inline bool RopeNode::get_use_vertex_thickness(void) const;

501 30 get_vertex_thickness_dimension 0 4 541 40 RopeNode::get_vertex_thickness_dimension 0 1 252 151
/**
 * Returns the numeric extended dimension in which the thickness component
 * should be found.  See NurbsCurveEvaluator::set_extended_vertex().
 */
65
static inline int RopeNode::get_vertex_thickness_dimension(void);

502 13 set_thickness 0 4 541 23 RopeNode::set_thickness 0 1 253 236
/**
 * Specifies the thickness of the rope, in pixels or in spatial units,
 * depending on the render mode.  See set_render_mode().
 *
 * The thickness may also be specified on a per-vertex basis.  See
 * set_use_vertex_thickness().
 */
59
inline void RopeNode::set_thickness(PN_stdfloat thickness);

503 13 get_thickness 0 4 541 23 RopeNode::get_thickness 0 1 254 67
/**
 * Returns the thickness of the rope.  See set_thickness().
 */
55
inline PN_stdfloat RopeNode::get_thickness(void) const;

504 10 set_matrix 0 4 541 20 RopeNode::set_matrix 0 1 255 207
/**
 * Specifies an optional matrix which is used to transform each control vertex
 * after it has been transformed into the RopeNode's coordinate space, but
 * before the polygon vertices are generated.
 */
57
inline void RopeNode::set_matrix(LMatrix4 const &matrix);

505 12 clear_matrix 0 4 541 22 RopeNode::clear_matrix 0 1 256 67
/**
 * Resets the node's matrix to identity.  See set_matrix().
 */
41
inline void RopeNode::clear_matrix(void);

506 10 has_matrix 0 4 541 20 RopeNode::has_matrix 0 1 257 92
/**
 * Returns true if the node has a matrix set, false otherwise.  See
 * set_matrix().
 */
45
inline bool RopeNode::has_matrix(void) const;

507 10 get_matrix 0 4 541 20 RopeNode::get_matrix 0 1 258 206
/**
 * Returns the optional matrix which is used to transform each control vertex
 * after it has been transformed into the RopeNode's coordinate space, but
 * before the polygon vertices are generated.
 */
56
inline LMatrix4 const &RopeNode::get_matrix(void) const;

508 11 reset_bound 0 4 541 21 RopeNode::reset_bound 0 1 259 206
/**
 * Recomputes the bounding volume.  This is normally called automatically, but
 * it must occasionally be called explicitly when the curve has changed
 * properties outside of this node's knowledge.
 */
51
void RopeNode::reset_bound(NodePath const &rel_to);

509 14 get_class_type 0 4 541 24 RopeNode::get_class_type 0 1 260 0
49
static TypeHandle RopeNode::get_class_type(void);

510 9 ~RopeNode 0 4 541 19 RopeNode::~RopeNode 0 0 0
26
RopeNode::~RopeNode(void);

511 9 SheetNode 0 4 553 20 SheetNode::SheetNode 0 1 261 22
/**
 *
 */

/**
 *
 */
55
explicit SheetNode::SheetNode(std::string const &name);

512 11 set_surface 0 4 553 22 SheetNode::set_surface 0 1 262 68
/**
 * Sets the particular surface represented by the SheetNode.
 */
67
inline void SheetNode::set_surface(NurbsSurfaceEvaluator *surface);

513 11 get_surface 0 4 553 22 SheetNode::get_surface 0 1 263 60
/**
 * Returns the surface represented by the SheetNode.
 */
65
inline NurbsSurfaceEvaluator *SheetNode::get_surface(void) const;

514 20 set_use_vertex_color 0 4 553 31 SheetNode::set_use_vertex_color 0 1 264 269
/**
 * Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
 * color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,
 * of the extended vertex values.  Use
 * NurbsCurveEvaluator::set_extended_vertex() to set these values.
 */
55
inline void SheetNode::set_use_vertex_color(bool flag);

515 20 get_use_vertex_color 0 4 553 31 SheetNode::get_use_vertex_color 0 1 265 76
/**
 * Returns the "use vertex color" flag.  See set_use_vertex_color().
 */
56
inline bool SheetNode::get_use_vertex_color(void) const;

516 16 set_num_u_subdiv 0 4 553 27 SheetNode::set_num_u_subdiv 0 1 266 178
/**
 * Specifies the number of subdivisions per cubic segment (that is, per unique
 * knot value) to draw in a fixed uniform tesselation of the surface in the U
 * direction.
 */
58
inline void SheetNode::set_num_u_subdiv(int num_u_subdiv);

517 16 get_num_u_subdiv 0 4 553 27 SheetNode::get_num_u_subdiv 0 1 267 119
/**
 * Returns the number of subdivisions per cubic segment to draw in the U
 * direction.  See set_num_u_subdiv().
 */
51
inline int SheetNode::get_num_u_subdiv(void) const;

518 16 set_num_v_subdiv 0 4 553 27 SheetNode::set_num_v_subdiv 0 1 268 178
/**
 * Specifies the number of subdivisions per cubic segment (that is, per unique
 * knot value) to draw in a fixed uniform tesselation of the surface in the V
 * direction.
 */
58
inline void SheetNode::set_num_v_subdiv(int num_v_subdiv);

519 16 get_num_v_subdiv 0 4 553 27 SheetNode::get_num_v_subdiv 0 1 269 119
/**
 * Returns the number of subdivisions per cubic segment to draw in the V
 * direction.  See set_num_v_subdiv().
 */
51
inline int SheetNode::get_num_v_subdiv(void) const;

520 11 reset_bound 0 4 553 22 SheetNode::reset_bound 0 1 270 208
/**
 * Recomputes the bounding volume.  This is normally called automatically, but
 * it must occasionally be called explicitly when the surface has changed
 * properties outside of this node's knowledge.
 */
52
void SheetNode::reset_bound(NodePath const &rel_to);

521 14 get_class_type 0 4 553 25 SheetNode::get_class_type 0 1 271 0
50
static TypeHandle SheetNode::get_class_type(void);

522 10 ~SheetNode 0 4 553 21 SheetNode::~SheetNode 0 0 0
28
SheetNode::~SheetNode(void);

271
1 0 0 6 3 546 0 0 164 /**
 * Returns true if the curve is defined.  This base class function always
 * returns true; derived classes might override this to sometimes return
 * false.
 */ 1 4 this 3 554  
2 0 0 6 4 529 0 0 237 /**
 * Returns the upper bound of t for the entire curve.  The curve is defined in
 * the range 0.0f <= t <= get_max_t().  This base class function always
 * returns 1.0f; derived classes might override this to return something else.
 */ 1 4 this 3 554  
3 0 0 4 5 556 0 0 389 /**
 * Sets the flag indicating the use to which the curve is intended to be put.
 * This flag is optional and only serves to provide a hint to the egg reader
 * and writer code; it has no effect on the curve's behavior.
 *
 * Setting the curve type also sets the num_dimensions to 3 or 1 according to
 * the type.
 *
 * THis flag may have one of the values PCT_XYZ, PCT_HPR, or PCT_T.
 */ 2 4 this 3 528  4 type 1 540  
4 0 0 6 6 540 0 0 91 /**
 * Returns the flag indicating the use to which the curve is intended to be
 * put.
 */ 1 4 this 3 554  
5 0 0 4 7 556 0 0 324 /**
 * Specifies the number of significant dimensions in the curve's vertices.
 * This should be one of 1, 2, or 3. Normally, XYZ and HPR curves have three
 * dimensions; time curves should always have one dimension.  This only serves
 * as a hint to the mopath editor, and also controls how the curve is written
 * out.
 */ 2 4 this 3 528  3 num 1 540  
6 0 0 6 8 540 0 0 267 /**
 * Returns the number of significant dimensions in the curve's vertices, as
 * set by a previous call to set_num_dimensions().  This is only a hint as to
 * how the curve is intended to be used; the actual number of dimensions of
 * any curve is always three.
 */ 1 4 this 3 554  
7 0 0 6 9 529 0 0 86 /**
 * Approximates the length of the entire curve to within a few decimal places.
 */ 1 4 this 3 554  
8 0 0 6 9 529 0 0 100 /**
 * Approximates the length of the curve segment from parametric time 'from' to
 * time 'to'.
 */ 3 4 this 3 554  4 from 1 529  2 to 1 529  
9 0 0 6 10 529 0 0 396 /**
 * Returns the parametric value corresponding to the indicated distance along
 * the curve from the starting parametric value.
 *
 * This is the inverse of calc_length(): rather than determining the length
 * along the curve between two parametric points, it determines the position
 * in parametric time of a point n units along the curve.
 *
 * The search distance must not be negative.
 */ 3 4 this 3 554  7 start_t 1 529  13 length_offset 1 529  
10 0 0 6 11 546 0 0 0 3 4 this 3 554  1 t 1 529  5 point 1 557  
11 0 0 6 12 546 0 0 0 3 4 this 3 554  1 t 1 529  7 tangent 1 557  
12 0 0 6 13 546 0 0 0 4 4 this 3 554  1 t 1 529  5 point 1 557  7 tangent 1 557  
13 0 0 6 14 546 0 0 0 3 4 this 3 554  1 t 1 529  8 tangent2 1 557  
14 0 0 6 15 546 0 0 144 /**
 * Recomputes the curve such that it passes through the point (px, py, pz) at
 * time t, but keeps the same tangent value at that point.
 */ 5 4 this 3 528  1 t 1 529  2 px 1 529  2 py 1 529  2 pz 1 529  
15 0 0 6 16 546 0 0 129 /**
 * Recomputes the curve such that it has the tangent (tx, ty, tz) at time t,
 * but keeps the same position at the point.
 */ 5 4 this 3 528  1 t 1 529  2 tx 1 529  2 ty 1 529  2 tz 1 529  
16 0 0 6 17 546 0 0 116 /**
 * Recomputes the curve such that it passes through the point (px, py, pz)
 * with the tangent (tx, ty, tz).
 */ 8 4 this 3 528  1 t 1 529  2 px 1 529  2 py 1 529  2 pz 1 529  2 tx 1 529  2 ty 1 529  2 tz 1 529  
17 0 0 6 18 546 0 0 115 /**
 * Recalculates the curve, if necessary.  Returns true if the resulting curve
 * is valid, false otherwise.
 */ 1 4 this 3 528  
18 0 0 6 19 546 0 0 259 /**
 * Regenerates this curve as one long curve: the first curve connected end-to-
 * end with the second one.  Either a or b may be the same as 'this'.
 *
 * Returns true if successful, false on failure or if the curve type does not
 * support stitching.
 */ 3 4 this 3 528  1 a 1 554  1 b 1 554  
19 0 0 6 20 546 0 0 138 /**
 * Writes an egg description of the nurbs curve to the specified output file.
 * Returns true if the file is successfully written.
 */ 3 4 this 3 528  8 filename 1 560  2 cs 1 562  
20 0 0 6 20 546 0 0 141 /**
 * Writes an egg description of the nurbs curve to the specified output
 * stream.  Returns true if the file is successfully written.
 */ 4 4 this 3 528  3 out 1 563  8 filename 1 565  2 cs 1 562  
21 0 0 7 21 568 0 0 0 0 
22 0 0 7 23 568 0 0 0 0 
23 0 0 7 26 569 0 0 10 /**
 *
 */ 0 
24 0 0 7 26 569 0 0 0 1 6 param0 0 570  
25 0 0 4 27 556 0 0 56 /**
 * Adds a new ParametricCurve to the collection.
 */ 2 4 this 3 569  5 curve 1 528  
26 0 0 4 27 556 0 0 134 /**
 * Adds a new ParametricCurve to the collection at the indicated index.
 * @deprecated Use insert_curve(index, curve) instead.
 */ 3 4 this 3 569  5 curve 1 528  5 index 1 540  
27 0 0 4 28 556 0 0 79 /**
 * Adds a new ParametricCurve to the collection at the indicated index.
 */ 3 4 this 3 569  5 index 1 572  5 curve 1 528  
28 0 0 6 29 540 0 0 120 /**
 * Adds all the curves found in the scene graph rooted at the given node.
 * Returns the number of curves found.
 */ 2 4 this 3 569  4 node 1 574  
29 0 0 6 30 546 0 0 160 /**
 * Removes the indicated ParametricCurve from the collection.  Returns true if
 * the curve was removed, false if it was not a member of the collection.
 */ 2 4 this 3 569  5 curve 1 528  
30 0 0 4 30 556 0 0 93 /**
 * Removes the indicated ParametricCurve from the collection, by its index
 * number.
 */ 2 4 this 3 569  5 index 1 572  
31 0 0 4 31 556 0 0 94 /**
 * Replaces the indicated ParametricCurve from the collection, by its index
 * number.
 */ 3 4 this 3 569  5 index 1 572  5 curve 1 528  
32 0 0 6 32 546 0 0 104 /**
 * Returns true if the indicated ParametricCurve appears in this collection,
 * false otherwise.
 */ 2 4 this 3 570  5 curve 1 528  
33 0 0 4 33 556 0 0 60 /**
 * Removes all ParametricCurves from the collection.
 */ 1 4 this 3 569  
34 0 0 4 34 556 0 0 63 /**
 * Removes all the timewarp curves from the collection.
 */ 1 4 this 3 569  
35 0 0 6 35 540 0 0 68 /**
 * Returns the number of ParametricCurves in the collection.
 */ 1 4 this 3 570  
36 0 0 7 36 528 0 0 61 /**
 * Returns the nth ParametricCurve in the collection.
 */ 2 4 this 3 570  5 index 1 540  
37 0 0 7 38 528 0 0 95 /**
 * Returns the first XYZ curve in the collection, if any, or NULL if there are
 * none.
 */ 1 4 this 3 570  
38 0 0 7 39 528 0 0 95 /**
 * Returns the first HPR curve in the collection, if any, or NULL if there are
 * none.
 */ 1 4 this 3 570  
39 0 0 7 40 528 0 0 180 /**
 * If there is an XYZ curve in the collection, returns it; otherwise, returns
 * the first curve whose type is unspecified.  Returns NULL if no curve meets
 * the criteria.
 */ 1 4 this 3 570  
40 0 0 6 41 540 0 0 67 /**
 * Returns the number of timewarp curves in the collection.
 */ 1 4 this 3 570  
41 0 0 7 42 528 0 0 60 /**
 * Returns the nth timewarp curve in the collection.
 */ 2 4 this 3 570  1 n 1 540  
42 0 0 6 44 529 0 0 170 /**
 * Returns the maximum T value associated with the *last* curve in the
 * collection.  Normally, this will be either the XYZ or HPR curve, or a
 * timewarp curve.
 */ 1 4 this 3 570  
43 0 0 4 56 556 0 0 539 /**
 * Discards all existing timewarp curves and recomputes a new timewarp curve
 * that maps distance along the curve to parametric time, so that the distance
 * between any two points in parametric time is proportional to the
 * approximate distance of those same two points along the XYZ curve.
 *
 * segments_per_unit represents the number of segments to take per each unit
 * of parametric time of the original XYZ curve.
 *
 * The new timewarp curve (and thus, the apparent range of the collection)
 * will range from 0 to max_t.
 */ 3 4 this 3 569  5 max_t 1 529  17 segments_per_unit 1 529  
44 0 0 4 57 556 0 0 179 /**
 * Discards the existing HPR curve and generates a new one that looks in the
 * direction of travel along the XYZ curve, based on the XYZ curve's tangent
 * at each point.
 */ 2 4 this 3 569  17 segments_per_unit 1 529  
45 0 0 4 58 556 0 0 277 /**
 * Adjusts the apparent length of the curve by applying a new timewarp that
 * maps the range [0..max_t] to the range [0..get_max_t()].  After this call,
 * the curve collection will contain one more timewarp curve, and get_max_t()
 * will return the given max_t value.
 */ 2 4 this 3 569  5 max_t 1 529  
46 0 0 6 59 546 0 0 508 /**
 * Computes the transform matrix representing translation to the position
 * indicated by the first XYZ curve in the collection and the rotation
 * indicated by the first HPR curve in the collection, after t has been
 * modified by all the timewarp curves in the collection applied in sequence,
 * from back to front.
 *
 * Returns true if the point is valid (i.e.  t is within the bounds indicated
 * by all the timewarp curves and within the bounds of the curves themselves),
 * or false otherwise.
 */ 4 4 this 3 570  1 t 1 529  6 result 1 575  2 cs 1 562  
47 0 0 6 59 546 0 0 433 /**
 * Computes the position and rotation represented by the first XYZ and HPR
 * curves in the collection at the given point t, after t has been modified by
 * all the timewarp curves in the collection applied in sequence, from back to
 * front.
 *
 * Returns true if the point is valid (i.e.  t is within the bounds indicated
 * by all the timewarp curves and within the bounds of the curves themselves),
 * or false otherwise.
 */ 4 4 this 3 570  1 t 1 529  3 xyz 1 557  3 hpr 1 557  
48 0 0 6 60 529 0 0 219 /**
 * Determines the value of t that should be passed to the XYZ and HPR curves,
 * after applying the given value of t to all the timewarps.  Return -1.0f if
 * the value of t exceeds one of the timewarps' ranges.
 */ 2 4 this 3 570  1 t 1 529  
49 0 0 6 61 546 0 0 69 /**
 * Computes only the XYZ part of the curves.  See evaluate().
 */ 3 4 this 3 570  1 t 1 529  3 xyz 1 557  
50 0 0 6 62 546 0 0 69 /**
 * Computes only the HPR part of the curves.  See evaluate().
 */ 3 4 this 3 570  1 t 1 529  3 hpr 1 557  
51 0 0 6 63 546 0 0 208 /**
 * Adjust the XYZ curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */ 3 4 this 3 569  1 t 1 529  3 xyz 1 576  
52 0 0 6 63 546 0 0 208 /**
 * Adjust the XYZ curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */ 5 4 this 3 569  1 t 1 529  1 x 1 529  1 y 1 529  1 z 1 529  
53 0 0 6 64 546 0 0 208 /**
 * Adjust the HPR curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */ 3 4 this 3 569  1 t 1 529  3 xyz 1 576  
54 0 0 6 64 546 0 0 208 /**
 * Adjust the HPR curve at the indicated time to the new value.  The curve
 * shape will change correspondingly.  Returns true if successful, false if
 * unable to make the adjustment for some reason.
 */ 5 4 this 3 569  1 t 1 529  1 h 1 529  1 p 1 529  1 r 1 529  
55 0 0 6 65 546 0 0 153 /**
 * Ensures all the curves are freshly computed and up-to-date.  Returns true
 * if everything is valid, false if at least one curve is incorrect.
 */ 1 4 this 3 569  
56 0 0 6 66 546 0 0 262 /**
 * Regenerates this curve as one long curve: the first curve connected end-to-
 * end with the second one.  Either a or b may be the same as 'this'.  This
 * will lose any timewarps on the input curves.
 *
 * Returns true if successful, false on failure.
 */ 3 4 this 3 569  1 a 1 570  1 b 1 570  
57 0 0 4 67 556 0 0 114 /**
 * Writes a brief one-line description of the ParametricCurveCollection to the
 * indicated output stream.
 */ 2 4 this 3 570  3 out 1 563  
58 0 0 4 68 556 0 0 119 /**
 * Writes a complete multi-line description of the ParametricCurveCollection
 * to the indicated output stream.
 */ 3 4 this 3 570  3 out 1 563  12 indent_level 1 540  
59 0 0 6 69 546 0 0 162 /**
 * Writes an egg description of all the nurbs curves in the collection to the
 * specified output file.  Returns true if the file is successfully written.
 */ 3 4 this 3 569  8 filename 1 560  2 cs 1 562  
60 0 0 6 69 546 0 0 164 /**
 * Writes an egg description of all the nurbs curves in the collection to the
 * specified output stream.  Returns true if the file is successfully written.
 */ 4 4 this 3 569  3 out 1 563  8 filename 1 565  2 cs 1 562  
61 0 0 7 71 578 326 0 10 /**
 *
 */ 0 
62 0 0 7 71 578 326 0 0 1 6 param0 0 579  
63 0 0 4 73 556 0 0 114 /**
 * Removes all the data points previously added to the CurveFitter, and
 * initializes it for a new curve.
 */ 1 4 this 3 578  
64 0 0 4 74 556 0 0 36 /**
 * Adds a single sample xyz.
 */ 3 4 this 3 578  1 t 1 529  3 xyz 1 576  
65 0 0 4 75 556 0 0 36 /**
 * Adds a single sample hpr.
 */ 3 4 this 3 578  1 t 1 529  3 hpr 1 576  
66 0 0 4 76 556 0 0 57 /**
 * Adds a single sample xyz & hpr simultaneously.
 */ 4 4 this 3 578  1 t 1 529  3 xyz 1 576  3 hpr 1 576  
67 0 0 6 77 540 0 0 68 /**
 * Returns the number of sample points that have been added.
 */ 1 4 this 3 579  
68 0 0 6 78 529 0 0 64 /**
 * Returns the parametric value of the nth sample added.
 */ 2 4 this 3 579  1 n 1 540  
69 0 0 7 79 557 0 0 62 /**
 * Returns the point in space of the nth sample added.
 */ 2 4 this 3 579  1 n 1 540  
70 0 0 7 80 557 0 0 59 /**
 * Returns the orientation of the nth sample added.
 */ 2 4 this 3 579  1 n 1 540  
71 0 0 7 81 557 0 0 143 /**
 * Returns the tangent associated with the nth sample added.  This is only
 * meaningful if compute_tangents() has already been called.
 */ 2 4 this 3 579  1 n 1 540  
72 0 0 4 82 556 0 0 108 /**
 * Eliminates all samples from index begin, up to but not including index end,
 * from the database.
 */ 3 4 this 3 578  5 begin 1 540  3 end 1 540  
73 0 0 4 83 556 0 0 223 /**
 * Generates a series of data points by sampling the given curve (or xyz/hpr
 * curves) the indicated number of times.  The sampling is made evenly in
 * parametric time, and then the timewarps, if any, are applied.
 */ 3 4 this 3 578  6 curves 1 569  5 count 1 540  
74 0 0 4 84 556 0 0 165 /**
 * Resets each HPR data point so that the maximum delta between any two
 * consecutive points is 180 degrees, which should prevent incorrect HPR
 * wrapping.
 */ 1 4 this 3 578  
75 0 0 4 85 556 0 0 115 /**
 * Sorts all the data points in order by parametric time, in case they were
 * added in an incorrect order.
 */ 1 4 this 3 578  
76 0 0 4 86 556 0 0 175 /**
 * Removes sample points in order to reduce the complexity of a sampled curve.
 * Keeps one out of every factor samples.  Also keeps the first and the last
 * samples.
 */ 2 4 this 3 578  6 factor 1 529  
77 0 0 4 87 556 0 0 231 /**
 * Once a set of points has been built, and prior to calling MakeHermite() or
 * MakeNurbs(), ComputeTangents() must be called to set up the tangents
 * correctly (unless the tangents were defined as the points were added).
 */ 2 4 this 3 578  5 scale 1 529  
78 0 0 7 88 569 0 0 72 /**
 * Converts the current set of data points into a Hermite curve.
 */ 1 4 this 3 579  
79 0 0 7 89 569 0 0 134 /**
 * Converts the current set of data points into a NURBS curve.  This gives a
 * smoother curve than produced by MakeHermite().
 */ 1 4 this 3 579  
80 0 0 4 90 556 0 0 10 /**
 *
 */ 2 4 this 3 579  3 out 1 563  
81 0 0 4 91 556 0 0 10 /**
 *
 */ 2 4 this 3 579  3 out 1 563  
82 0 0 7 92 568 0 0 0 0 
83 0 0 7 94 581 0 0 10 /**
 *
 */ 0 
84 0 0 7 95 568 0 0 0 0 
85 0 0 7 97 582 0 0 10 /**
 *
 */ 0 
86 0 0 7 97 582 0 0 80 /**
 * Constructs a Hermite from the indicated (possibly non-hermite) curve.
 */ 1 2 pc 1 554  
87 0 0 6 98 540 0 0 51 /**
 * Returns the number of CV's in the curve.
 */ 1 4 this 3 583  
88 0 0 6 99 540 0 0 547 /**
 * Inserts a new CV at the given parametric point along the curve.  If this
 * parametric point is already on the curve, the CV is assigned an index
 * between its two neighbors and the indices of all following CV's are
 * incremented by 1; its in and out tangents are chosen to keep the curve
 * consistent.  If the new parametric point is beyond the end of the existing
 * curve, the curve is extended to meet it and the new CV's position, in
 * tangent, and out tangent are set to zero.
 *
 * The index number of the new CV is returned.
 */ 2 4 this 3 582  1 t 1 529  
89 0 0 6 100 540 0 0 0 3 4 this 3 582  4 type 1 540  1 v 1 576  
90 0 0 6 100 540 0 0 149 /**
 * Adds a new CV to the end of the curve.  The new CV is given initial in/out
 * tangents of 0.  The return value is the index of the new CV.
 */ 5 4 this 3 582  4 type 1 540  1 x 1 529  1 y 1 529  1 z 1 529  
91 0 0 6 101 546 0 0 100 /**
 * Removes the given CV from the curve.  Returns true if the CV existed, false
 * otherwise.
 */ 2 4 this 3 582  1 n 1 540  
92 0 0 4 102 556 0 0 43 /**
 * Removes all CV's from the curve.
 */ 1 4 this 3 582  
93 0 0 6 103 546 0 0 544 /**
 * Changes the given CV's continuity type.  Legal values are HC_CUT, HC_FREE,
 * HC_G1, or HC_SMOOTH.
 *
 * Other than HC_CUT, these have no effect on the actual curve; it remains up
 * to user software to impose the constraints these imply.
 *
 * HC_CUT implies a disconnection of the curve; HC_FREE imposes no constraints
 * on the tangents; HC_G1 forces the tangents to be collinear, and HC_SMOOTH
 * forces the tangents to be identical.  Setting type type to HC_G1 or
 * HC_SMOOTH may adjust the out tangent to match the in tangent.
 */ 3 4 this 3 582  1 n 1 540  4 type 1 540  
94 0 0 6 104 546 0 0 0 3 4 this 3 582  1 n 1 540  1 v 1 576  
95 0 0 6 104 546 0 0 43 /**
 * Changes the given CV's position.
 */ 5 4 this 3 582  1 n 1 540  1 x 1 529  1 y 1 529  1 z 1 529  
96 0 0 6 105 546 0 0 0 3 4 this 3 582  1 n 1 540  1 v 1 576  
97 0 0 6 105 546 0 0 121 /**
 * Changes the given CV's in tangent.  Depending on the continuity type, this
 * may also adjust the out tangent.
 */ 5 4 this 3 582  1 n 1 540  1 x 1 529  1 y 1 529  1 z 1 529  
98 0 0 6 106 546 0 0 0 3 4 this 3 582  1 n 1 540  1 v 1 576  
99 0 0 6 106 546 0 0 121 /**
 * Changes the given CV's out tangent.  Depending on the continuity type, this
 * may also adjust the in tangent.
 */ 5 4 this 3 582  1 n 1 540  1 x 1 529  1 y 1 529  1 z 1 529  
100 0 0 6 107 546 0 0 103 /**
 * Changes the given CV's parametric starting time.  This may affect the shape
 * of the curve.
 */ 3 4 this 3 582  1 n 1 540  6 tstart 1 529  
101 0 0 6 108 546 0 0 60 /**
 * Changes the name associated with a particular CV.
 */ 3 4 this 3 582  1 n 1 540  4 name 1 585  
102 0 0 6 109 540 0 0 120 /**
 * Returns the given CV's continuity type, HC_CUT, HC_FREE, HC_G1, or
 * HC_SMOOTH, or 0 if there is no such CV.
 */ 2 4 this 3 583  1 n 1 540  
103 0 0 6 110 576 0 0 48 /**
 * Returns the position of the given CV.
 */ 2 4 this 3 583  1 n 1 540  
104 0 0 4 110 556 0 0 0 3 4 this 3 583  1 n 1 540  1 v 1 557  
105 0 0 6 111 576 0 0 50 /**
 * Returns the in tangent of the given CV.
 */ 2 4 this 3 583  1 n 1 540  
106 0 0 4 111 556 0 0 0 3 4 this 3 583  1 n 1 540  1 v 1 557  
107 0 0 6 112 576 0 0 51 /**
 * Returns the out tangent of the given CV.
 */ 2 4 this 3 583  1 n 1 540  
108 0 0 4 112 556 0 0 0 3 4 this 3 583  1 n 1 540  1 v 1 557  
109 0 0 6 113 529 0 0 74 /**
 * Returns the starting point in parametric space of the given CV.
 */ 2 4 this 3 583  1 n 1 540  
110 0 0 6 114 585 0 0 53 /**
 * Returns the name of the given CV, or NULL.
 */ 2 4 this 3 583  1 n 1 540  
111 0 0 4 115 556 0 0 10 /**
 *
 */ 3 4 this 3 583  3 out 1 563  1 n 1 540  
112 0 0 7 116 568 0 0 0 0 
113 0 0 4 119 556 0 0 0 2 4 this 3 586  5 order 1 540  
114 0 0 6 120 540 0 0 0 1 4 this 3 587  
115 0 0 6 121 540 0 0 0 1 4 this 3 587  
116 0 0 6 122 540 0 0 0 1 4 this 3 587  
117 0 0 6 123 546 0 0 0 2 4 this 3 586  1 t 1 529  
118 0 0 6 124 540 0 0 10 /**
 *
 */ 2 4 this 3 586  1 v 1 576  
119 0 0 6 124 540 0 0 10 /**
 *
 */ 2 4 this 3 586  1 v 1 589  
120 0 0 6 124 540 0 0 10 /**
 *
 */ 4 4 this 3 586  1 x 1 529  1 y 1 529  1 z 1 529  
121 0 0 6 125 546 0 0 0 2 4 this 3 586  1 n 1 540  
122 0 0 4 126 556 0 0 0 1 4 this 3 586  
123 0 0 6 127 546 0 0 86 /**
 * Repositions the indicated CV.  Returns true if successful, false otherwise.
 */ 3 4 this 3 586  1 n 1 540  1 v 1 576  
124 0 0 6 127 546 0 0 86 /**
 * Repositions the indicated CV.  Returns true if successful, false otherwise.
 */ 5 4 this 3 586  1 n 1 540  1 x 1 529  1 y 1 529  1 z 1 529  
125 0 0 7 128 557 0 0 52 /**
 * Returns the position of the indicated CV.
 */ 2 4 this 3 587  1 n 1 540  
126 0 0 6 129 546 0 0 94 /**
 * Sets the weight of the indicated CV without affecting its position in 3-d
 * space.
 */ 3 4 this 3 586  1 n 1 540  1 w 1 529  
127 0 0 6 130 529 0 0 50 /**
 * Returns the weight of the indicated CV.
 */ 2 4 this 3 587  1 n 1 540  
128 0 0 6 131 546 0 0 0 3 4 this 3 586  1 n 1 540  1 v 1 589  
129 0 0 7 132 593 0 0 0 2 4 this 3 587  1 n 1 540  
130 0 0 6 133 546 0 0 0 3 4 this 3 586  1 n 1 540  1 t 1 529  
131 0 0 6 134 529 0 0 0 2 4 this 3 587  1 n 1 540  
132 0 0 4 137 556 0 0 10 /**
 *
 */ 3 4 this 3 587  3 out 1 563  1 n 1 540  
133 0 0 7 138 568 0 0 0 0 
134 0 0 7 144 594 393 0 10 /**
 *
 */ 0 
135 0 0 7 144 594 393 0 94 /**
 * Constructs a NURBS curve equivalent to the indicated (possibly non-NURBS)
 * curve.
 */ 1 2 pc 1 554  
136 0 0 7 146 568 0 0 0 0 
137 0 0 7 140 581 0 0 0 1 4 this 3 594  
138 0 0 6 142 586 0 0 0 1 4 this 3 594  
139 0 0 7 166 597 0 0 0 1 6 param0 0 595  
140 0 0 6 148 529 0 0 81 /**
 * Returns the first legal value of t on the curve.  Usually this is 0.0.
 */ 1 4 this 3 595  
141 0 0 6 149 529 0 0 58 /**
 * Returns the last legal value of t on the curve.
 */ 1 4 this 3 595  
142 0 0 6 150 546 0 0 158 /**
 * Computes the point on the curve corresponding to the indicated value in
 * parametric time.  Returns true if the t value is valid, false otherwise.
 */ 3 4 this 3 597  1 t 1 529  5 point 1 557  
143 0 0 6 151 546 0 0 193 /**
 * Computes the tangent to the curve at the indicated point in parametric
 * time.  This tangent vector will not necessarily be normalized, and could be
 * zero.  See also eval_point().
 */ 3 4 this 3 597  1 t 1 529  7 tangent 1 557  
144 0 0 6 152 529 0 0 145 /**
 * Evaluates the curve in n-dimensional space according to the extended
 * vertices associated with the curve in the indicated dimension.
 */ 3 4 this 3 597  1 t 1 529  1 d 1 540  
145 0 0 6 153 546 0 0 248 /**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */ 5 4 this 3 597  1 t 1 529  1 d 1 540  6 result 1 598  10 num_values 1 540  
146 0 0 6 154 540 0 0 170 /**
 * Returns the number of piecewise continuous segments within the curve.  This
 * number is usually not important unless you plan to call
 * eval_segment_point().
 */ 1 4 this 3 595  
147 0 0 4 155 556 0 0 637 /**
 * Evaluates the point on the curve corresponding to the indicated value in
 * parametric time within the indicated curve segment.  t should be in the
 * range [0, 1].
 *
 * The curve is internally represented as a number of connected (or possibly
 * unconnected) piecewise continuous segments.  The exact number of segments
 * for a particular curve depends on the knot vector, and is returned by
 * get_num_segments().  Normally, eval_point() is used to evaluate a point
 * along the continuous curve, but when you care more about local continuity,
 * you can use eval_segment_point() to evaluate the points along each segment.
 */ 4 4 this 3 595  7 segment 1 540  1 t 1 529  5 point 1 557  
148 0 0 4 156 556 0 0 207 /**
 * As eval_segment_point, but computes the tangent to the curve at the
 * indicated point.  The tangent vector will not necessarily be normalized,
 * and could be zero, particularly at the endpoints.
 */ 4 4 this 3 595  7 segment 1 540  1 t 1 529  7 tangent 1 557  
149 0 0 6 157 529 0 0 145 /**
 * Evaluates the curve in n-dimensional space according to the extended
 * vertices associated with the curve in the indicated dimension.
 */ 4 4 this 3 595  7 segment 1 540  1 t 1 529  1 d 1 540  
150 0 0 4 158 556 0 0 248 /**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */ 6 4 this 3 595  7 segment 1 540  1 t 1 529  1 d 1 540  6 result 1 598  10 num_values 1 540  
151 0 0 6 159 529 0 0 217 /**
 * Accepts a t value in the range [0, 1], and assumed to be relative to the
 * indicated segment (as in eval_segment_point()), and returns the
 * corresponding t value in the entire curve (as in eval_point()).
 */ 3 4 this 3 595  7 segment 1 540  1 t 1 529  
152 0 0 4 160 556 0 0 330 /**
 * Determines the set of subdivisions necessary to approximate the curve with
 * a set of linear segments, no point of which is farther than tolerance units
 * from the actual curve.
 *
 * After this call, you may walk through the resulting set of samples with
 * get_num_samples(), get_sample_t(), and get_sample_point().
 */ 2 4 this 3 597  9 tolerance 1 529  
153 0 0 6 161 540 0 0 102 /**
 * Returns the number of sample points generated by the previous call to
 * adaptive_sample().
 */ 1 4 this 3 595  
154 0 0 6 162 529 0 0 110 /**
 * Returns the t value of the nth sample point generated by the previous call
 * to adaptive_sample().
 */ 2 4 this 3 595  1 n 1 540  
155 0 0 6 163 599 0 0 252 /**
 * Returns the point on the curve of the nth sample point generated by the
 * previous call to adaptive_sample().
 *
 * For tangents, or extended points, you should use get_sample_t() and pass it
 * into eval_tangent() or eval_extended_point().
 */ 2 4 this 3 595  1 n 1 540  
156 0 0 7 168 545 0 0 10 /**
 *
 */ 0 
157 0 0 7 168 545 0 0 0 1 6 param0 0 603  
158 0 0 4 169 556 0 0 224 /**
 * Sets the order of the curve.  This resets the knot vector to the default
 * knot vector for the number of vertices.
 *
 * The order must be 1, 2, 3, or 4, and the value is one more than the degree
 * of the curve.
 */ 2 4 this 3 545  5 order 1 540  
159 0 0 6 170 540 0 0 83 /**
 * Returns the order of the curve as set by a previous call to set_order().
 */ 1 4 this 3 603  
160 0 0 4 171 556 0 0 231 /**
 * Resets all the vertices and knots to their default values, and sets the
 * curve up with the indicated number of vertices.  You must then call
 * set_vertex() repeatedly to fill in all of the vertex values appropriately.
 */ 2 4 this 3 545  12 num_vertices 1 540  
161 0 0 6 172 540 0 0 122 /**
 * Returns the number of control vertices in the curve.  This is the number
 * passed to the last call to reset().
 */ 1 4 this 3 603  
162 0 0 4 173 556 0 0 194 /**
 * Sets the nth control vertex of the curve.  This flavor sets the vertex as a
 * 3-d coordinate and a weight; the 3-d coordinate values are implicitly
 * scaled up by the weight factor.
 */ 4 4 this 3 545  1 i 1 540  6 vertex 1 576  6 weight 1 529  
163 0 0 4 173 556 0 0 245 /**
 * Sets the nth control vertex of the curve, as a vertex in 4-d homogeneous
 * space.  In this form, the first three components of the vertex should
 * already have been scaled by the fourth component, which is the homogeneous
 * weight.
 */ 3 4 this 3 545  1 i 1 540  6 vertex 1 589  
164 0 0 6 174 589 0 0 102 /**
 * Returns the nth control vertex of the curve, relative to its indicated
 * coordinate space.
 */ 2 4 this 3 603  1 i 1 540  
165 0 0 7 174 593 0 0 98 /**
 * Returns the nth control vertex of the curve, relative to the given
 * coordinate space.
 */ 3 4 this 3 603  1 i 1 540  6 rel_to 1 605  
166 0 0 4 176 556 0 0 429 /**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty NodePath, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a fixed NodePath, which is always the same
 * NodePath.  Also see setting the space as a path string, which can specify a
 * different NodePath for different instances of the curve.
 */ 3 4 this 3 545  1 i 1 540  5 space 1 605  
167 0 0 4 176 556 0 0 361 /**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty string, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a string, which describes the path to find the
 * node relative to the rel_to NodePath when the curve is evaluated.
 */ 3 4 this 3 545  1 i 1 540  5 space 1 585  
168 0 0 7 177 608 0 0 107 /**
 * Returns the coordinate space of the nth control vertex of the curve,
 * expressed as a NodePath.
 */ 3 4 this 3 603  1 i 1 540  6 rel_to 1 605  
169 0 0 4 178 556 0 0 768 /**
 * Sets an n-dimensional vertex value.  This allows definition of a NURBS
 * surface or curve in a sparse n-dimensional space, typically used for
 * associating additional properties (like color or joint membership) with
 * each vertex of a surface.
 *
 * The value d is an arbitrary integer value and specifies the dimension of
 * question for this particular vertex.  Any number of dimensions may be
 * specified, and they need not be consecutive.  If a value for a given
 * dimension is not specified, is it implicitly 0.0.
 *
 * The value is implicitly scaled by the homogenous weight value--that is, the
 * fourth component of the value passed to set_vertex().  This means the
 * ordinary vertex must be set first, before the extended vertices can be set.
 */ 4 4 this 3 545  1 i 1 540  1 d 1 540  5 value 1 529  
170 0 0 6 179 529 0 0 172 /**
 * Returns an n-dimensional vertex value.  See set_extended_vertex().  This
 * returns the value set for the indicated dimension, or 0.0 if nothing has
 * been set.
 */ 3 4 this 3 603  1 i 1 540  1 d 1 540  
171 0 0 4 180 556 0 0 259 /**
 * Simultaneously sets several extended values in the slots d through (d +
 * num_values - 1) from the num_values elements of the indicated array.  This
 * is equivalent to calling set_extended_vertex() num_values times.  See
 * set_extended_vertex().
 */ 5 4 this 3 545  1 i 1 540  1 d 1 540  6 values 1 609  10 num_values 1 540  
172 0 0 6 181 540 0 0 117 /**
 * Returns the number of knot values in the curve.  This is based on the
 * number of vertices and the order.
 */ 1 4 this 3 603  
173 0 0 4 182 556 0 0 184 /**
 * Sets the value of the nth knot.  Each knot value should be greater than or
 * equal to the preceding value.  If no knot values are set, a default knot
 * vector is supplied.
 */ 3 4 this 3 545  1 i 1 540  4 knot 1 529  
174 0 0 6 183 529 0 0 45 /**
 * Returns the value of the nth knot.
 */ 2 4 this 3 603  1 i 1 540  
175 0 0 4 185 556 0 0 95 /**
 * Normalizes the knot sequence so that the parametric range of the curve is 0
 * .. 1.
 */ 1 4 this 3 545  
176 0 0 6 186 540 0 0 114 /**
 * Returns the number of piecewise continuous segments in the curve.  This is
 * based on the knot vector.
 */ 1 4 this 3 603  
177 0 0 7 187 597 0 0 194 /**
 * Returns a NurbsCurveResult object that represents the result of applying
 * the knots to all of the current values of the vertices, transformed into
 * the indicated coordinate space.
 */ 2 4 this 3 603  6 rel_to 1 605  
178 0 0 7 187 597 0 0 251 /**
 * Returns a NurbsCurveResult object that represents the result of applying
 * the knots to all of the current values of the vertices, transformed into
 * the indicated coordinate space, and then further transformed by the
 * indicated matrix.
 */ 3 4 this 3 603  6 rel_to 1 605  3 mat 1 611  
179 0 0 4 188 556 0 0 10 /**
 *
 */ 2 4 this 3 603  3 out 1 563  
180 0 0 7 206 614 0 0 0 1 6 param0 0 612  
181 0 0 6 190 529 0 0 83 /**
 * Returns the first legal value of u on the surface.  Usually this is 0.0.
 */ 1 4 this 3 612  
182 0 0 6 191 529 0 0 60 /**
 * Returns the last legal value of u on the surface.
 */ 1 4 this 3 612  
183 0 0 6 192 529 0 0 83 /**
 * Returns the first legal value of v on the surface.  Usually this is 0.0.
 */ 1 4 this 3 612  
184 0 0 6 193 529 0 0 60 /**
 * Returns the last legal value of v on the surface.
 */ 1 4 this 3 612  
185 0 0 6 194 546 0 0 168 /**
 * Computes the point on the surface corresponding to the indicated value in
 * parametric time.  Returns true if the u, v values are valid, false
 * otherwise.
 */ 4 4 this 3 614  1 u 1 529  1 v 1 529  5 point 1 557  
186 0 0 6 195 546 0 0 193 /**
 * Computes the normal to the surface at the indicated point in parametric
 * time.  This normal vector will not necessarily be normalized, and could be
 * zero.  See also eval_point().
 */ 4 4 this 3 614  1 u 1 529  1 v 1 529  6 normal 1 557  
187 0 0 6 196 529 0 0 149 /**
 * Evaluates the surface in n-dimensional space according to the extended
 * vertices associated with the surface in the indicated dimension.
 */ 4 4 this 3 614  1 u 1 529  1 v 1 529  1 d 1 540  
188 0 0 6 197 546 0 0 248 /**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */ 6 4 this 3 614  1 u 1 529  1 v 1 529  1 d 1 540  6 result 1 598  10 num_values 1 540  
189 0 0 6 198 540 0 0 191 /**
 * Returns the number of piecewise continuous segments within the surface in
 * the U direction.  This number is usually not important unless you plan to
 * call eval_segment_point().
 */ 1 4 this 3 612  
190 0 0 6 199 540 0 0 191 /**
 * Returns the number of piecewise continuous segments within the surface in
 * the V direction.  This number is usually not important unless you plan to
 * call eval_segment_point().
 */ 1 4 this 3 612  
191 0 0 4 200 556 0 0 656 /**
 * Evaluates the point on the surface corresponding to the indicated value in
 * parametric time within the indicated surface segment.  u and v should be in
 * the range [0, 1].
 *
 * The surface is internally represented as a number of connected (or possibly
 * unconnected) piecewise continuous segments.  The exact number of segments
 * for a particular surface depends on the knot vector, and is returned by
 * get_num_segments().  Normally, eval_point() is used to evaluate a point
 * along the continuous surface, but when you care more about local
 * continuity, you can use eval_segment_point() to evaluate the points along
 * each segment.
 */ 6 4 this 3 612  2 ui 1 540  2 vi 1 540  1 u 1 529  1 v 1 529  5 point 1 557  
192 0 0 4 201 556 0 0 176 /**
 * As eval_segment_point, but computes the normal to the surface at the
 * indicated point.  The normal vector will not necessarily be normalized, and
 * could be zero.
 */ 6 4 this 3 612  2 ui 1 540  2 vi 1 540  1 u 1 529  1 v 1 529  6 normal 1 557  
193 0 0 6 202 529 0 0 149 /**
 * Evaluates the surface in n-dimensional space according to the extended
 * vertices associated with the surface in the indicated dimension.
 */ 6 4 this 3 612  2 ui 1 540  2 vi 1 540  1 u 1 529  1 v 1 529  1 d 1 540  
194 0 0 4 203 556 0 0 248 /**
 * Simultaneously performs eval_extended_point on a contiguous sequence of
 * dimensions.  The dimensions evaluated are d through (d + num_values - 1);
 * the results are filled into the num_values elements in the indicated result
 * array.
 */ 8 4 this 3 612  2 ui 1 540  2 vi 1 540  1 u 1 529  1 v 1 529  1 d 1 540  6 result 1 598  10 num_values 1 540  
195 0 0 6 204 529 0 0 219 /**
 * Accepts a u value in the range [0, 1], and assumed to be relative to the
 * indicated segment (as in eval_segment_point()), and returns the
 * corresponding u value in the entire surface (as in eval_point()).
 */ 3 4 this 3 612  2 ui 1 540  1 u 1 529  
196 0 0 6 205 529 0 0 219 /**
 * Accepts a v value in the range [0, 1], and assumed to be relative to the
 * indicated segment (as in eval_segment_point()), and returns the
 * corresponding v value in the entire surface (as in eval_point()).
 */ 3 4 this 3 612  2 vi 1 540  1 v 1 529  
197 0 0 7 208 615 0 0 10 /**
 *
 */ 0 
198 0 0 7 208 615 0 0 0 1 6 param0 0 616  
199 0 0 4 209 556 0 0 247 /**
 * Sets the order of the surface in the U direction.  This resets the knot
 * vector to the default knot vector for the number of vertices.
 *
 * The order must be 1, 2, 3, or 4, and the value is one more than the degree
 * of the surface.
 */ 2 4 this 3 615  7 u_order 1 540  
200 0 0 6 210 540 0 0 109 /**
 * Returns the order of the surface in the U direction as set by a previous
 * call to set_u_order().
 */ 1 4 this 3 616  
201 0 0 4 211 556 0 0 247 /**
 * Sets the order of the surface in the V direction.  This resets the knot
 * vector to the default knot vector for the number of vertices.
 *
 * The order must be 1, 2, 3, or 4, and the value is one more than the degree
 * of the surface.
 */ 2 4 this 3 615  7 v_order 1 540  
202 0 0 6 212 540 0 0 109 /**
 * Returns the order of the surface in the V direction as set by a previous
 * call to set_v_order().
 */ 1 4 this 3 616  
203 0 0 4 213 556 0 0 233 /**
 * Resets all the vertices and knots to their default values, and sets the
 * surface up with the indicated number of vertices.  You must then call
 * set_vertex() repeatedly to fill in all of the vertex values appropriately.
 */ 3 4 this 3 615  14 num_u_vertices 1 540  14 num_v_vertices 1 540  
204 0 0 6 214 540 0 0 142 /**
 * Returns the number of control vertices in the U direction on the surface.
 * This is the number passed to the last call to reset().
 */ 1 4 this 3 616  
205 0 0 6 215 540 0 0 142 /**
 * Returns the number of control vertices in the V direction on the surface.
 * This is the number passed to the last call to reset().
 */ 1 4 this 3 616  
206 0 0 4 216 556 0 0 196 /**
 * Sets the nth control vertex of the surface.  This flavor sets the vertex as
 * a 3-d coordinate and a weight; the 3-d coordinate values are implicitly
 * scaled up by the weight factor.
 */ 5 4 this 3 615  2 ui 1 540  2 vi 1 540  6 vertex 1 576  6 weight 1 529  
207 0 0 4 216 556 0 0 247 /**
 * Sets the nth control vertex of the surface, as a vertex in 4-d homogeneous
 * space.  In this form, the first three components of the vertex should
 * already have been scaled by the fourth component, which is the homogeneous
 * weight.
 */ 4 4 this 3 615  2 ui 1 540  2 vi 1 540  6 vertex 1 589  
208 0 0 6 217 589 0 0 104 /**
 * Returns the nth control vertex of the surface, relative to its indicated
 * coordinate space.
 */ 3 4 this 3 616  2 ui 1 540  2 vi 1 540  
209 0 0 7 217 593 0 0 100 /**
 * Returns the nth control vertex of the surface, relative to the given
 * coordinate space.
 */ 4 4 this 3 616  2 ui 1 540  2 vi 1 540  6 rel_to 1 605  
210 0 0 4 218 556 0 0 431 /**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty NodePath, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a fixed NodePath, which is always the same
 * NodePath.  Also see setting the space as a path string, which can specify a
 * different NodePath for different instances of the surface.
 */ 4 4 this 3 615  2 ui 1 540  2 vi 1 540  5 space 1 605  
211 0 0 4 218 556 0 0 363 /**
 * Sets the coordinate space of the nth control vertex.  If this is not
 * specified, or is set to an empty string, the nth control vertex is deemed
 * to be in the coordinate space passed to evaluate().
 *
 * This specifies the space as a string, which describes the path to find the
 * node relative to the rel_to NodePath when the surface is evaluated.
 */ 4 4 this 3 615  2 ui 1 540  2 vi 1 540  5 space 1 585  
212 0 0 7 219 608 0 0 109 /**
 * Returns the coordinate space of the nth control vertex of the surface,
 * expressed as a NodePath.
 */ 4 4 this 3 616  2 ui 1 540  2 vi 1 540  6 rel_to 1 605  
213 0 0 4 220 556 0 0 770 /**
 * Sets an n-dimensional vertex value.  This allows definition of a NURBS
 * surface or surface in a sparse n-dimensional space, typically used for
 * associating additional properties (like color or joint membership) with
 * each vertex of a surface.
 *
 * The value d is an arbitrary integer value and specifies the dimension of
 * question for this particular vertex.  Any number of dimensions may be
 * specified, and they need not be consecutive.  If a value for a given
 * dimension is not specified, is it implicitly 0.0.
 *
 * The value is implicitly scaled by the homogenous weight value--that is, the
 * fourth component of the value passed to set_vertex().  This means the
 * ordinary vertex must be set first, before the extended vertices can be set.
 */ 5 4 this 3 615  2 ui 1 540  2 vi 1 540  1 d 1 540  5 value 1 529  
214 0 0 6 221 529 0 0 172 /**
 * Returns an n-dimensional vertex value.  See set_extended_vertex().  This
 * returns the value set for the indicated dimension, or 0.0 if nothing has
 * been set.
 */ 4 4 this 3 616  2 ui 1 540  2 vi 1 540  1 d 1 540  
215 0 0 4 222 556 0 0 259 /**
 * Simultaneously sets several extended values in the slots d through (d +
 * num_values - 1) from the num_values elements of the indicated array.  This
 * is equivalent to calling set_extended_vertex() num_values times.  See
 * set_extended_vertex().
 */ 6 4 this 3 615  2 ui 1 540  2 vi 1 540  1 d 1 540  6 values 1 609  10 num_values 1 540  
216 0 0 6 223 540 0 0 138 /**
 * Returns the number of knot values in the surface in the U direction.  This
 * is based on the number of vertices and the order.
 */ 1 4 this 3 616  
217 0 0 4 224 556 0 0 184 /**
 * Sets the value of the nth knot.  Each knot value should be greater than or
 * equal to the preceding value.  If no knot values are set, a default knot
 * vector is supplied.
 */ 3 4 this 3 615  1 i 1 540  4 knot 1 529  
218 0 0 6 225 529 0 0 45 /**
 * Returns the value of the nth knot.
 */ 2 4 this 3 616  1 i 1 540  
219 0 0 4 227 556 0 0 116 /**
 * Normalizes the knot sequence so that the parametric range of the surface in
 * the U direction is 0 .. 1.
 */ 1 4 this 3 615  
220 0 0 6 228 540 0 0 138 /**
 * Returns the number of knot values in the surface in the V direction.  This
 * is based on the number of vertices and the order.
 */ 1 4 this 3 616  
221 0 0 4 229 556 0 0 184 /**
 * Sets the value of the nth knot.  Each knot value should be greater than or
 * equal to the preceding value.  If no knot values are set, a default knot
 * vector is supplied.
 */ 3 4 this 3 615  1 i 1 540  4 knot 1 529  
222 0 0 6 230 529 0 0 45 /**
 * Returns the value of the nth knot.
 */ 2 4 this 3 616  1 i 1 540  
223 0 0 4 232 556 0 0 116 /**
 * Normalizes the knot sequence so that the parametric range of the surface in
 * the U direction is 0 .. 1.
 */ 1 4 this 3 615  
224 0 0 6 233 540 0 0 135 /**
 * Returns the number of piecewise continuous segments in the surface in the U
 * direction.  This is based on the knot vector.
 */ 1 4 this 3 616  
225 0 0 6 234 540 0 0 135 /**
 * Returns the number of piecewise continuous segments in the surface in the V
 * direction.  This is based on the knot vector.
 */ 1 4 this 3 616  
226 0 0 7 235 614 0 0 196 /**
 * Returns a NurbsSurfaceResult object that represents the result of applying
 * the knots to all of the current values of the vertices, transformed into
 * the indicated coordinate space.
 */ 2 4 this 3 616  6 rel_to 1 605  
227 0 0 4 236 556 0 0 10 /**
 *
 */ 2 4 this 3 616  3 out 1 563  
228 0 0 7 245 618 510 0 10 /**
 *
 */ 1 4 name 1 585  
229 0 0 4 249 556 0 0 65 /**
 * Sets the particular curve represented by the RopeNode.
 */ 2 4 this 3 618  5 curve 1 545  
230 0 0 7 250 545 0 0 57 /**
 * Returns the curve represented by the RopeNode.
 */ 1 4 this 3 619  
231 0 0 4 251 556 0 0 130 /**
 * Specifies the method used to render the rope.  The simplest is RM_thread,
 * which just draws a one-pixel line segment.
 */ 2 4 this 3 618  11 render_mode 1 542  
232 0 0 6 252 542 0 0 78 /**
 * Returns the method used to render the rope.  See set_render_mode().
 */ 1 4 this 3 619  
233 0 0 4 253 556 0 0 72 /**
 * Specifies the algorithm to use to generate UV's for the rope.
 */ 2 4 this 3 618  7 uv_mode 1 543  
234 0 0 6 254 543 0 0 70 /**
 * Returns the algorithm to use to generate UV's for the rope.
 */ 1 4 this 3 619  
235 0 0 4 255 556 0 0 115 /**
 * Specify true to vary the U coordinate down the length of the rope, or false
 * to vary the V coordinate.
 */ 2 4 this 3 618  10 u_dominant 1 546  
236 0 0 6 256 546 0 0 124 /**
 * Returns true if the rope runs down the U coordinate of the texture, or
 * false if it runs down the V coordinate.
 */ 1 4 this 3 619  
237 0 0 4 257 556 0 0 206 /**
 * Specifies an additional scaling factor to apply to generated UV's along the
 * rope.  This scale factor is applied in whichever direction is along the
 * rope, as specified by set_uv_direction().
 */ 2 4 this 3 618  5 scale 1 529  
238 0 0 6 258 529 0 0 78 /**
 * Returns the scaling factor to apply to generated UV's for the rope.
 */ 1 4 this 3 619  
239 0 0 4 259 556 0 0 192 /**
 * Specifies the kind of normals to generate for the rope.  This is only
 * applicable when the RenderMode is set to RM_tube; in the other render
 * modes, normals are never generated.
 */ 2 4 this 3 618  11 normal_mode 1 544  
240 0 0 6 260 544 0 0 131 /**
 * Returns the kind of normals to generate for the rope.  This is only
 * applicable when the RenderMode is set to RM_tube.
 */ 1 4 this 3 619  
241 0 0 4 261 556 0 0 419 /**
 * Specifies a normal vector, generally perpendicular to the main axis of the
 * starting point of the curve, that controls the "top" of the curve, when
 * RenderMode is RM_tube.  This is used to orient the vertices that make up
 * the tube.  If this vector is too nearly parallel with the starting
 * direction of the curve, there may be a tendency for the whole tube to
 * gimble-lock around its primary axis.
 */ 2 4 this 3 618  7 tube_up 1 621  
242 0 0 6 262 621 0 0 127 /**
 * Returns the normal vector used to control the "top" of the curve, when
 * RenderMode is RM_tube.  See set_tube_up().
 */ 1 4 this 3 619  
243 0 0 4 263 556 0 0 351 /**
 * Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
 * color is assumed to be stored as the dimensions n + 0, n + 1, n + 2, n + 3,
 * respectively, of the extended vertex values, where n is the value returned
 * by get_vertex_color_dimension().  Use
 * NurbsCurveEvaluator::set_extended_vertex() to set these values.
 */ 2 4 this 3 618  4 flag 1 546  
244 0 0 6 264 546 0 0 76 /**
 * Returns the "use vertex color" flag.  See set_use_vertex_color().
 */ 1 4 this 3 619  
245 0 0 6 265 540 0 0 221 /**
 * Returns the numeric extended dimension in which the color components should
 * be found.  See NurbsCurveEvaluator::set_extended_vertex().
 *
 * The color components will be expected at (n, n + 1, n + 2, n + 3).
 */ 0 
246 0 0 4 266 556 0 0 154 /**
 * Specifies the number of subdivisions per cubic segment (that is, per unique
 * knot value) to draw in a fixed uniform tesselation of the curve.
 */ 2 4 this 3 618  10 num_subdiv 1 540  
247 0 0 6 267 540 0 0 98 /**
 * Returns the number of subdivisions per cubic segment to draw.  See
 * set_num_subdiv().
 */ 1 4 this 3 619  
248 0 0 4 268 556 0 0 404 /**
 * Specifies the number of radial subdivisions to make if RenderMode is
 * RM_tube.  It is ignored in the other render modes.
 *
 * Increasing this number increases the roundness of a cross-section of the
 * tube.  The minimum value for a dimensional tube is 3; setting it to 2 will
 * get you a thin piece of tape (which is similar to RM_billboard, except it
 * won't rotate to face the camera).
 */ 2 4 this 3 618  10 num_slices 1 540  
249 0 0 6 269 540 0 0 153 /**
 * Returns the number of radial subdivisions to make if RenderMode is RM_tube.
 * It is ignored in the other render modes.  See set_num_slices().
 */ 1 4 this 3 619  
250 0 0 4 270 556 0 0 418 /**
 * Sets the "use vertex thickness" flag.  When this is true, the vertex
 * thickness is assumed to be stored as the dimension
 * get_vertex_thickness_dimension(), of the extended vertex values.  Use
 * NurbsCurveEvaluator::set_extended_vertex() to set these values.
 *
 * In this mode, the overall thickness is also applied as a scale to the
 * vertex thickness.  Not all render modes support vertex thickness.
 */ 2 4 this 3 618  4 flag 1 546  
251 0 0 6 271 546 0 0 84 /**
 * Returns the "use vertex thickness" flag.  See set_use_vertex_thickness().
 */ 1 4 this 3 619  
252 0 0 6 272 540 0 0 151 /**
 * Returns the numeric extended dimension in which the thickness component
 * should be found.  See NurbsCurveEvaluator::set_extended_vertex().
 */ 0 
253 0 0 4 273 556 0 0 236 /**
 * Specifies the thickness of the rope, in pixels or in spatial units,
 * depending on the render mode.  See set_render_mode().
 *
 * The thickness may also be specified on a per-vertex basis.  See
 * set_use_vertex_thickness().
 */ 2 4 this 3 618  9 thickness 1 529  
254 0 0 6 274 529 0 0 67 /**
 * Returns the thickness of the rope.  See set_thickness().
 */ 1 4 this 3 619  
255 0 0 4 275 556 0 0 207 /**
 * Specifies an optional matrix which is used to transform each control vertex
 * after it has been transformed into the RopeNode's coordinate space, but
 * before the polygon vertices are generated.
 */ 2 4 this 3 618  6 matrix 1 611  
256 0 0 4 276 556 0 0 67 /**
 * Resets the node's matrix to identity.  See set_matrix().
 */ 1 4 this 3 618  
257 0 0 6 277 546 0 0 92 /**
 * Returns true if the node has a matrix set, false otherwise.  See
 * set_matrix().
 */ 1 4 this 3 619  
258 0 0 6 278 611 0 0 206 /**
 * Returns the optional matrix which is used to transform each control vertex
 * after it has been transformed into the RopeNode's coordinate space, but
 * before the polygon vertices are generated.
 */ 1 4 this 3 619  
259 0 0 4 279 556 0 0 206 /**
 * Recomputes the bounding volume.  This is normally called automatically, but
 * it must occasionally be called explicitly when the curve has changed
 * properties outside of this node's knowledge.
 */ 2 4 this 3 618  6 rel_to 1 605  
260 0 0 7 303 568 0 0 0 0 
261 0 0 7 306 622 522 0 10 /**
 *
 */ 1 4 name 1 585  
262 0 0 4 307 556 0 0 68 /**
 * Sets the particular surface represented by the SheetNode.
 */ 2 4 this 3 622  7 surface 1 615  
263 0 0 7 308 615 0 0 60 /**
 * Returns the surface represented by the SheetNode.
 */ 1 4 this 3 623  
264 0 0 4 309 556 0 0 269 /**
 * Sets the "use vertex color" flag.  When this is true, the R, G, B, A vertex
 * color is assumed to be stored as the dimensions 0, 1, 2, 3, respectively,
 * of the extended vertex values.  Use
 * NurbsCurveEvaluator::set_extended_vertex() to set these values.
 */ 2 4 this 3 622  4 flag 1 546  
265 0 0 6 310 546 0 0 76 /**
 * Returns the "use vertex color" flag.  See set_use_vertex_color().
 */ 1 4 this 3 623  
266 0 0 4 311 556 0 0 178 /**
 * Specifies the number of subdivisions per cubic segment (that is, per unique
 * knot value) to draw in a fixed uniform tesselation of the surface in the U
 * direction.
 */ 2 4 this 3 622  12 num_u_subdiv 1 540  
267 0 0 6 312 540 0 0 119 /**
 * Returns the number of subdivisions per cubic segment to draw in the U
 * direction.  See set_num_u_subdiv().
 */ 1 4 this 3 623  
268 0 0 4 313 556 0 0 178 /**
 * Specifies the number of subdivisions per cubic segment (that is, per unique
 * knot value) to draw in a fixed uniform tesselation of the surface in the V
 * direction.
 */ 2 4 this 3 622  12 num_v_subdiv 1 540  
269 0 0 6 314 540 0 0 119 /**
 * Returns the number of subdivisions per cubic segment to draw in the V
 * direction.  See set_num_v_subdiv().
 */ 1 4 this 3 623  
270 0 0 4 315 556 0 0 208 /**
 * Recomputes the bounding volume.  This is normally called automatically, but
 * it must occasionally be called explicitly when the surface has changed
 * properties outside of this node's knowledge.
 */ 2 4 this 3 622  6 rel_to 1 605  
271 0 0 7 316 568 0 0 0 0 
102
523 15 ParametricCurve 0 75777 15 ParametricCurve 15 ParametricCurve 0 0 0 0 0 0 19 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 0 0 1 0 524 0 0 0 0 163
/**
 * A virtual base class for parametric curves.  This encapsulates all curves
 * in 3-d space defined for a single parameter t in the range [0,get_max_t()].
 */

524 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

525 13 CubicCurveseg 0 75777 13 CubicCurveseg 13 CubicCurveseg 0 0 0 0 0 0 1 291 0 0 1 0 523 0 0 0 0 940
/**
 * A CubicCurveseg is any curve that can be completely described by four
 * 4-valued basis vectors, one for each dimension in three-space, and one for
 * the homogeneous coordinate.  This includes Beziers, Hermites, and NURBS.
 *
 * This class encapsulates a single curve segment of the cubic curve.
 * Normally, when we think of Bezier and Hermite curves, we think of a
 * piecewise collection of such segments.
 *
 * Although this class includes methods such as hermite_basis() and
 * nurbs_basis(), to generate a Hermite and NURBS curve segment, respectively,
 * only the final basis vectors are stored: the product of the basis matrix of
 * the corresponding curve type, and its geometry vectors.  This is the
 * minimum information needed to evaluate the curve.  However, the individual
 * CV's that were used to compute these basis vectors are not retained; this
 * might be handled in a subclass (for instance, HermiteCurve).
 */

526 25 ParametricCurveCollection 0 75777 25 ParametricCurveCollection 25 ParametricCurveCollection 0 0 0 1 292 0 6 633 634 635 636 637 638 30 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 311 312 313 314 315 316 317 318 319 320 321 322 323 324 2 658 659 0 1 0 527 0 0 0 0 343
/**
 * This is a set of zero or more ParametricCurves, which may or may not be
 * related.  If they are related, the set should contain no more than one XYZ
 * curve, no more than one HPR curve, and zero or more Timewarp curves, which
 * can then be evaluated as a unit to return a single transformation matrix
 * for a given unit of time.
 */

527 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

528 17 ParametricCurve * 0 8576 17 ParametricCurve * 17 ParametricCurve * 0 0 523 0 0 0 0 0 0 0 0 0 0

529 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 530 0 0 0 0 0 0 0 0 0 0

530 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

531 11 CurveFitter 0 26625 11 CurveFitter 11 CurveFitter 0 0 0 1 325 326 0 20 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 0 0 0 0 0 10
/**
 *
 */

532 14 PiecewiseCurve 0 75777 14 PiecewiseCurve 14 PiecewiseCurve 0 0 0 1 347 0 0 1 348 0 0 1 0 523 0 0 0 0 184
/**
 * A PiecewiseCurve is a curve made up of several curve segments, connected in
 * a head-to-tail fashion.  The length of each curve segment in parametric
 * space is definable.
 */

533 12 HermiteCurve 0 75777 12 HermiteCurve 12 HermiteCurve 0 0 0 1 349 0 0 19 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 0 0 1 0 532 0 0 0 0 421
/**
 * A parametric curve defined by a sequence of control vertices, each with an
 * in and out tangent.
 *
 * This class is actually implemented as a PiecewiseCurve made up of several
 * CubicCurvesegs, each of which is created using the hermite_basis() method.
 * The HermiteCurve class itself keeps its own list of the CV's that are used
 * to define the curve (since the CubicCurveseg class doesn't retain these).
 */

534 19 NurbsCurveInterface 0 26625 19 NurbsCurveInterface 19 NurbsCurveInterface 0 0 0 0 369 0 18 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 2 660 661 0 0 0 0 211
/**
 * This abstract class defines the interface only for a Nurbs-style curve,
 * with knots and coordinates in homogeneous space.
 *
 * The NurbsCurve class inherits both from this and from ParametricCurve.
 */

535 10 NurbsCurve 0 26625 10 NurbsCurve 10 NurbsCurve 0 0 0 1 392 393 0 1 394 0 0 2 3 532 388 389 3 534 390 391 0 0 830
/**
 * A Nonuniform Rational B-Spline.
 *
 * This class is actually implemented as a PiecewiseCurve made up of several
 * CubicCurvesegs, each of which is created using the nurbs_basis() method.
 * The list of CV's and knots is kept here, within the NurbsCurve class.
 *
 * This class is the original Panda-native implementation of a NURBS curve.
 * It is typedeffed as "NurbsCurve" and performs all NURBS curve functions if
 * we do not have the NURBS++ library available.
 *
 * However, if we *do* have the NURBS++ library, another class exists, the
 * NurbsPPCurve, which is a wrapper around that library and provides some
 * additional functionality.  In that case, the other class is typedeffed to
 * "NurbsCurve" instead of this one, and performs most of the NURBS curve
 * functions.  This class then becomes vestigial.
 */

536 16 NurbsCurveResult 0 75777 16 NurbsCurveResult 16 NurbsCurveResult 0 0 0 1 411 0 0 16 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 2 662 663 0 1 0 527 0 0 0 0 453
/**
 * The result of a NurbsCurveEvaluator.  This object represents a curve in a
 * particular coordinate space.  It can return the point and/or tangent to the
 * curve at any point.
 *
 * This is not related to NurbsCurve, CubicCurveseg or any of the
 * ParametricCurve-derived objects in this module.  It is a completely
 * parallel implementation of NURBS curves, and will probably eventually
 * replace the whole ParametricCurve class hierarchy.
 */

537 19 NurbsCurveEvaluator 0 75777 19 NurbsCurveEvaluator 19 NurbsCurveEvaluator 0 0 0 1 412 0 0 18 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 2 664 665 0 1 0 527 0 0 0 0 492
/**
 * This class is an abstraction for evaluating NURBS curves.  It accepts an
 * array of vertices, each of which may be in a different coordinate space (as
 * defined by a NodePath), as well as an optional knot vector.
 *
 * This is not related to NurbsCurve, CubicCurveseg or any of the
 * ParametricCurve-derived objects in this module.  It is a completely
 * parallel implementation of NURBS curves, and will probably eventually
 * replace the whole ParametricCurve class hierarchy.
 */

538 18 NurbsSurfaceResult 0 75777 18 NurbsSurfaceResult 18 NurbsSurfaceResult 0 0 0 1 447 0 0 16 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 0 0 1 0 527 0 0 0 0 191
/**
 * The result of a NurbsSurfaceEvaluator.  This object represents a surface in
 * a particular coordinate space.  It can return the point and/or normal to
 * the surface at any point.
 */

539 21 NurbsSurfaceEvaluator 0 75777 21 NurbsSurfaceEvaluator 21 NurbsSurfaceEvaluator 0 0 0 1 448 0 4 639 640 641 642 26 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 2 666 667 0 1 0 527 0 0 0 0 227
/**
 * This class is an abstraction for evaluating NURBS surfaces.  It accepts an
 * array of vertices, each of which may be in a different coordinate space (as
 * defined by a NodePath), as well as an optional knot vector.
 */

540 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

541 8 RopeNode 0 141313 8 RopeNode 8 RopeNode 0 0 0 1 477 510 15 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 32 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 0 0 1 0 524 0 0 0 3 542 543 544 428
/**
 * This class draws a visible representation of the NURBS curve stored in its
 * NurbsCurveEvaluator.  It automatically recomputes the curve every frame.
 *
 * This is not related to NurbsCurve, CubicCurveseg or any of the
 * ParametricCurve-derived objects in this module.  It is a completely
 * parallel implementation of NURBS curves, and will probably eventually
 * replace the whole ParametricCurve class hierarchy.
 */

542 10 RenderMode 0 794624 20 RopeNode::RenderMode 20 RopeNode::RenderMode 541 0 0 0 0 0 0 0 0 0 4 9 RM_thread 19 RopeNode::RM_thread 59
// Render the rope as a one-pixel thread using a linestrip.
0 7 RM_tape 17 RopeNode::RM_tape 93
// Render the rope as a triangle strip oriented to be perpendicular to the
// tube_up vector.
1 12 RM_billboard 22 RopeNode::RM_billboard 90
// Render the rope as a triangle strip oriented to be perpendicular to the
// view vector.
2 7 RM_tube 17 RopeNode::RM_tube 62
// Render the rope as a hollow tube extruded along its length.
3 0 0

543 6 UVMode 0 794624 16 RopeNode::UVMode 16 RopeNode::UVMode 541 0 0 0 0 0 0 0 0 0 4 7 UV_none 17 RopeNode::UV_none 39
// Don't generate UV's along the curve.
0 13 UV_parametric 23 RopeNode::UV_parametric 69
// Generate UV's based on the parametric coordinates along the curve.
1 11 UV_distance 21 RopeNode::UV_distance 140
// Generate UV's in proportion to spatial distance along the curve, by
// using the distance function to compute the length of each segment.
2 12 UV_distance2 22 RopeNode::UV_distance2 310
// As above, but don't bother to take the square root of each segment.
// The distance is then in proportion to the sum-of-squares of the
// segments along the rope.  If the segments are similar in length, this
// approximates the proportion of UV_distance while avoiding hundreds of
// square root operations.
3 0 0

544 10 NormalMode 0 794624 20 RopeNode::NormalMode 20 RopeNode::NormalMode 541 0 0 0 0 0 0 0 0 0 2 7 NM_none 17 RopeNode::NM_none 26
// Don't generate normals.
0 9 NM_vertex 19 RopeNode::NM_vertex 43
// Generate vertex (smooth-shaded) normals.
1 0 0

545 21 NurbsCurveEvaluator * 0 8576 21 NurbsCurveEvaluator * 21 NurbsCurveEvaluator * 0 0 537 0 0 0 0 0 0 0 0 0 0

546 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

547 14 LVector3 const 0 8832 14 LVector3 const 14 LVector3 const 0 0 548 0 0 0 0 0 0 0 0 0 0

548 8 LVector3 0 2105344 8 LVector3 8 LVector3 0 0 549 0 0 0 0 0 0 0 0 0 0

549 9 LVector3f 0 2048 9 LVector3f 9 LVector3f 0 0 0 0 0 0 0 0 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

550 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 551 0 0 0 0 0 0 0 0 0 0

551 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 552 0 0 0 0 0 0 0 0 0 0

552 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

553 9 SheetNode 0 141313 9 SheetNode 9 SheetNode 0 0 0 1 511 522 0 10 512 513 514 515 516 517 518 519 520 521 0 0 1 0 524 0 0 0 0 447
/**
 * This class draws a visible representation of the NURBS surface stored in
 * its NurbsSurfaceEvaluator.  It automatically recomputes the surface every
 * frame.
 *
 * This is not related to NurbsSurface, CubicSurfaceseg or any of the
 * ParametricSurface-derived objects in this module.  It is a completely
 * parallel implementation of NURBS surfaces, and will probably eventually
 * replace the whole ParametricSurface class hierarchy.
 */

554 23 ParametricCurve const * 0 8576 23 ParametricCurve const * 23 ParametricCurve const * 0 0 555 0 0 0 0 0 0 0 0 0 0

555 21 ParametricCurve const 0 8832 21 ParametricCurve const 21 ParametricCurve const 0 0 523 0 0 0 0 0 0 0 0 0 0

556 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

557 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 558 0 0 0 0 0 0 0 0 0 0

558 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 559 0 0 0 0 0 0 0 0 0 0

559 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

560 10 Filename * 0 8576 10 Filename * 10 Filename * 0 0 561 0 0 0 0 0 0 0 0 0 0

561 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

562 16 CoordinateSystem 0 532480 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

563 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 564 0 0 0 0 0 0 0 0 0 0

564 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

565 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 566 0 0 0 0 0 0 0 0 0 0

566 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 561 0 0 0 0 0 0 0 0 0 0

567 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

568 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 567 0 0 0 0 0 0 0 0 0 0

569 27 ParametricCurveCollection * 0 8576 27 ParametricCurveCollection * 27 ParametricCurveCollection * 0 0 526 0 0 0 0 0 0 0 0 0 0

570 33 ParametricCurveCollection const * 0 8576 33 ParametricCurveCollection const * 33 ParametricCurveCollection const * 0 0 571 0 0 0 0 0 0 0 0 0 0

571 31 ParametricCurveCollection const 0 8832 31 ParametricCurveCollection const 31 ParametricCurveCollection const 0 0 526 0 0 0 0 0 0 0 0 0 0

572 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 573 0 0 0 0 0 0 0 0 0 0

573 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

574 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 524 0 0 0 0 0 0 0 0 0 0

575 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 551 0 0 0 0 0 0 0 0 0 0

576 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 577 0 0 0 0 0 0 0 0 0 0

577 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 558 0 0 0 0 0 0 0 0 0 0

578 13 CurveFitter * 0 8576 13 CurveFitter * 13 CurveFitter * 0 0 531 0 0 0 0 0 0 0 0 0 0

579 19 CurveFitter const * 0 8576 19 CurveFitter const * 19 CurveFitter const * 0 0 580 0 0 0 0 0 0 0 0 0 0

580 17 CurveFitter const 0 8832 17 CurveFitter const 17 CurveFitter const 0 0 531 0 0 0 0 0 0 0 0 0 0

581 16 PiecewiseCurve * 0 8576 16 PiecewiseCurve * 16 PiecewiseCurve * 0 0 532 0 0 0 0 0 0 0 0 0 0

582 14 HermiteCurve * 0 8576 14 HermiteCurve * 14 HermiteCurve * 0 0 533 0 0 0 0 0 0 0 0 0 0

583 20 HermiteCurve const * 0 8576 20 HermiteCurve const * 20 HermiteCurve const * 0 0 584 0 0 0 0 0 0 0 0 0 0

584 18 HermiteCurve const 0 8832 18 HermiteCurve const 18 HermiteCurve const 0 0 533 0 0 0 0 0 0 0 0 0 0

585 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

586 21 NurbsCurveInterface * 0 8576 21 NurbsCurveInterface * 21 NurbsCurveInterface * 0 0 534 0 0 0 0 0 0 0 0 0 0

587 27 NurbsCurveInterface const * 0 8576 27 NurbsCurveInterface const * 27 NurbsCurveInterface const * 0 0 588 0 0 0 0 0 0 0 0 0 0

588 25 NurbsCurveInterface const 0 8832 25 NurbsCurveInterface const 25 NurbsCurveInterface const 0 0 534 0 0 0 0 0 0 0 0 0 0

589 17 LVecBase4 const * 0 8576 17 LVecBase4 const * 17 LVecBase4 const * 0 0 590 0 0 0 0 0 0 0 0 0 0

590 15 LVecBase4 const 0 8832 15 LVecBase4 const 15 LVecBase4 const 0 0 591 0 0 0 0 0 0 0 0 0 0

591 9 LVecBase4 0 2105344 9 LVecBase4 9 LVecBase4 0 0 592 0 0 0 0 0 0 0 0 0 0

592 10 LVecBase4f 0 2048 10 LVecBase4f 10 LVecBase4f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

593 11 LVecBase4 * 0 8576 11 LVecBase4 * 11 LVecBase4 * 0 0 591 0 0 0 0 0 0 0 0 0 0

594 12 NurbsCurve * 0 8576 12 NurbsCurve * 12 NurbsCurve * 0 0 535 0 0 0 0 0 0 0 0 0 0

595 24 NurbsCurveResult const * 0 8576 24 NurbsCurveResult const * 24 NurbsCurveResult const * 0 0 596 0 0 0 0 0 0 0 0 0 0

596 22 NurbsCurveResult const 0 8832 22 NurbsCurveResult const 22 NurbsCurveResult const 0 0 536 0 0 0 0 0 0 0 0 0 0

597 18 NurbsCurveResult * 0 8576 18 NurbsCurveResult * 18 NurbsCurveResult * 0 0 536 0 0 0 0 0 0 0 0 0 0

598 14 PN_stdfloat [] 0 4202496 14 PN_stdfloat [] 14 PN_stdfloat [] 0 0 529 -1 0 0 0 0 0 0 0 0 0 0

599 15 LPoint3 const * 0 8576 15 LPoint3 const * 15 LPoint3 const * 0 0 600 0 0 0 0 0 0 0 0 0 0

600 13 LPoint3 const 0 8832 13 LPoint3 const 13 LPoint3 const 0 0 601 0 0 0 0 0 0 0 0 0 0

601 7 LPoint3 0 2105344 7 LPoint3 7 LPoint3 0 0 602 0 0 0 0 0 0 0 0 0 0

602 8 LPoint3f 0 2048 8 LPoint3f 8 LPoint3f 0 0 0 0 0 0 0 0 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

603 27 NurbsCurveEvaluator const * 0 8576 27 NurbsCurveEvaluator const * 27 NurbsCurveEvaluator const * 0 0 604 0 0 0 0 0 0 0 0 0 0

604 25 NurbsCurveEvaluator const 0 8832 25 NurbsCurveEvaluator const 25 NurbsCurveEvaluator const 0 0 537 0 0 0 0 0 0 0 0 0 0

605 16 NodePath const * 0 8576 16 NodePath const * 16 NodePath const * 0 0 606 0 0 0 0 0 0 0 0 0 0

606 14 NodePath const 0 8832 14 NodePath const 14 NodePath const 0 0 607 0 0 0 0 0 0 0 0 0 0

607 8 NodePath 0 2048 8 NodePath 8 NodePath 0 0 0 0 0 0 0 0 0 0 0 0 762
/**
 * NodePath is the fundamental system for disambiguating instances, and also
 * provides a higher-level interface for manipulating the scene graph.
 *
 * A NodePath is a list of connected nodes from the root of the graph to any
 * sub-node.  Each NodePath therefore uniquely describes one instance of a
 * node.
 *
 * NodePaths themselves are lightweight objects that may easily be copied and
 * passed by value.  Their data is stored as a series of NodePathComponents
 * that are stored on the nodes.  Holding a NodePath will keep a reference
 * count to all the nodes in the path.  However, if any node in the path is
 * removed or reparented (perhaps through a different NodePath), the NodePath
 * will automatically be updated to reflect the changes.
 */

608 10 NodePath * 0 8576 10 NodePath * 10 NodePath * 0 0 607 0 0 0 0 0 0 0 0 0 0

609 20 PN_stdfloat const [] 0 4202496 20 PN_stdfloat const [] 20 PN_stdfloat const [] 0 0 610 -1 0 0 0 0 0 0 0 0 0 0

610 17 PN_stdfloat const 0 8832 17 PN_stdfloat const 17 PN_stdfloat const 0 0 529 0 0 0 0 0 0 0 0 0 0

611 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 550 0 0 0 0 0 0 0 0 0 0

612 26 NurbsSurfaceResult const * 0 8576 26 NurbsSurfaceResult const * 26 NurbsSurfaceResult const * 0 0 613 0 0 0 0 0 0 0 0 0 0

613 24 NurbsSurfaceResult const 0 8832 24 NurbsSurfaceResult const 24 NurbsSurfaceResult const 0 0 538 0 0 0 0 0 0 0 0 0 0

614 20 NurbsSurfaceResult * 0 8576 20 NurbsSurfaceResult * 20 NurbsSurfaceResult * 0 0 538 0 0 0 0 0 0 0 0 0 0

615 23 NurbsSurfaceEvaluator * 0 8576 23 NurbsSurfaceEvaluator * 23 NurbsSurfaceEvaluator * 0 0 539 0 0 0 0 0 0 0 0 0 0

616 29 NurbsSurfaceEvaluator const * 0 8576 29 NurbsSurfaceEvaluator const * 29 NurbsSurfaceEvaluator const * 0 0 617 0 0 0 0 0 0 0 0 0 0

617 27 NurbsSurfaceEvaluator const 0 8832 27 NurbsSurfaceEvaluator const 27 NurbsSurfaceEvaluator const 0 0 539 0 0 0 0 0 0 0 0 0 0

618 10 RopeNode * 0 8576 10 RopeNode * 10 RopeNode * 0 0 541 0 0 0 0 0 0 0 0 0 0

619 16 RopeNode const * 0 8576 16 RopeNode const * 16 RopeNode const * 0 0 620 0 0 0 0 0 0 0 0 0 0

620 14 RopeNode const 0 8832 14 RopeNode const 14 RopeNode const 0 0 541 0 0 0 0 0 0 0 0 0 0

621 16 LVector3 const * 0 8576 16 LVector3 const * 16 LVector3 const * 0 0 547 0 0 0 0 0 0 0 0 0 0

622 11 SheetNode * 0 8576 11 SheetNode * 11 SheetNode * 0 0 553 0 0 0 0 0 0 0 0 0 0

623 17 SheetNode const * 0 8576 17 SheetNode const * 17 SheetNode const * 0 0 624 0 0 0 0 0 0 0 0 0 0

624 15 SheetNode const 0 8832 15 SheetNode const 15 SheetNode const 0 0 553 0 0 0 0 0 0 0 0 0 0

8
625 6 HC_CUT 0 5 1 540 0 1 1 
626 7 HC_FREE 0 5 2 540 0 1 2 
627 5 HC_G1 0 5 3 540 0 1 3 
628 9 HC_SMOOTH 0 5 4 540 0 1 4 
629 7 PCT_HPR 0 5 2 540 0 1 2 
630 8 PCT_NONE 0 5 0 540 0 1 0 
631 5 PCT_T 0 5 3 540 0 1 3 
632 7 PCT_XYZ 0 5 1 540 0 1 1 
25
633 6 curves 0 102 528 309 297 0 0 296 301 0 0 33 ParametricCurveCollection::curves 0

634 9 xyz_curve 0 2 528 303 0 0 0 0 0 0 0 36 ParametricCurveCollection::xyz_curve 0

635 9 hpr_curve 0 2 528 304 0 0 0 0 0 0 0 36 ParametricCurveCollection::hpr_curve 0

636 13 default_curve 0 2 528 305 0 0 0 0 0 0 0 40 ParametricCurveCollection::default_curve 0

637 15 timewarp_curves 0 66 528 310 0 0 0 0 306 0 0 42 ParametricCurveCollection::timewarp_curves 0

638 5 max_t 0 2 529 308 0 0 0 0 0 0 0 32 ParametricCurveCollection::max_t 0

639 7 u_order 0 6 540 450 449 0 0 0 0 0 0 30 NurbsSurfaceEvaluator::u_order 0

640 7 v_order 0 6 540 452 451 0 0 0 0 0 0 30 NurbsSurfaceEvaluator::v_order 0

641 7 u_knots 0 70 529 475 464 0 0 0 463 0 0 30 NurbsSurfaceEvaluator::u_knots 0

642 7 v_knots 0 70 529 476 468 0 0 0 467 0 0 30 NurbsSurfaceEvaluator::v_knots 0

643 5 curve 0 6 545 479 478 0 0 0 0 0 0 15 RopeNode::curve 0

644 11 render_mode 0 6 542 481 480 0 0 0 0 0 0 21 RopeNode::render_mode 0

645 7 uv_mode 0 6 543 483 482 0 0 0 0 0 0 17 RopeNode::uv_mode 0

646 12 uv_direction 0 6 546 485 484 0 0 0 0 0 0 22 RopeNode::uv_direction 0

647 8 uv_scale 0 6 529 487 486 0 0 0 0 0 0 18 RopeNode::uv_scale 0

648 11 normal_mode 0 6 544 489 488 0 0 0 0 0 0 21 RopeNode::normal_mode 0

649 7 tube_up 0 6 547 491 490 0 0 0 0 0 0 17 RopeNode::tube_up 0

650 16 use_vertex_color 0 6 546 493 492 0 0 0 0 0 0 26 RopeNode::use_vertex_color 0

651 22 vertex_color_dimension 0 2 540 494 0 0 0 0 0 0 0 32 RopeNode::vertex_color_dimension 0

652 10 num_subdiv 0 6 540 496 495 0 0 0 0 0 0 20 RopeNode::num_subdiv 0

653 10 num_slices 0 6 540 498 497 0 0 0 0 0 0 20 RopeNode::num_slices 0

654 20 use_vertex_thickness 0 6 546 500 499 0 0 0 0 0 0 30 RopeNode::use_vertex_thickness 0

655 26 vertex_thickness_dimension 0 2 540 501 0 0 0 0 0 0 0 36 RopeNode::vertex_thickness_dimension 0

656 9 thickness 0 6 529 503 502 0 0 0 0 0 0 19 RopeNode::thickness 0

657 6 matrix 0 30 550 507 504 506 505 0 0 0 0 16 RopeNode::matrix 0

10
658 10 get_curves 0 301 302 37 ParametricCurveCollection::get_curves 0

659 19 get_timewarp_curves 0 306 307 46 ParametricCurveCollection::get_timewarp_curves 0

660 7 get_cvs 0 372 383 28 NurbsCurveInterface::get_cvs 0

661 9 get_knots 0 373 385 30 NurbsCurveInterface::get_knots 0

662 13 get_sample_ts 0 408 409 31 NurbsCurveResult::get_sample_ts 0

663 17 get_sample_points 0 408 410 35 NurbsCurveResult::get_sample_points 0

664 12 get_vertices 0 416 418 33 NurbsCurveEvaluator::get_vertices 0

665 9 get_knots 0 424 426 30 NurbsCurveEvaluator::get_knots 0

666 11 get_u_knots 0 463 465 34 NurbsSurfaceEvaluator::get_u_knots 0

667 11 get_v_knots 0 467 469 34 NurbsSurfaceEvaluator::get_v_knots 0

