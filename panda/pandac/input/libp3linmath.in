1565844121
3 3
12 libp3linmath 4 Ns0b 12 panda3d.core 
1557
1966 11 MathNumbers 0 4 3523 24 MathNumbers::MathNumbers 0 2 1 2 0
112
inline MathNumbers::MathNumbers(void) = default;
inline MathNumbers::MathNumbers(MathNumbers const &) = default;

1967 12 ~MathNumbers 0 4 3523 25 MathNumbers::~MathNumbers 0 0 0
32
MathNumbers::~MathNumbers(void);

1968 9 deg_2_rad 0 1 0 9 deg_2_rad 0 2 1876 1877 0
67
inline double deg_2_rad(double f);
inline float deg_2_rad(float f);

1969 9 rad_2_deg 0 1 0 9 rad_2_deg 0 2 1878 1879 0
67
inline double rad_2_deg(double f);
inline float rad_2_deg(float f);

1970 10 LVecBase2f 0 4 3524 22 LVecBase2f::LVecBase2f 0 4 3 4 5 6 22
/**
 *
 */

/**
 *
 */
205
inline LVecBase2f::LVecBase2f(void) = default;
inline LVecBase2f::LVecBase2f(float fill_value);
inline LVecBase2f::LVecBase2f(float x, float y);
inline LVecBase2f::LVecBase2f(LVecBase2f const &) = default;

1971 12 operator new 0 4 3524 24 LVecBase2f::operator new 0 1 7 0
124
inline void *LVecBase2f::operator new(std::size_t size);
inline void *LVecBase2f::operator new(std::size_t size, void *ptr);

1972 15 operator delete 0 4 3524 27 LVecBase2f::operator delete 0 0 0
108
inline void LVecBase2f::operator delete(void *ptr);
inline void LVecBase2f::operator delete(void *, void *);

1973 12 validate_ptr 0 4 3524 24 LVecBase2f::validate_ptr 0 0 0
61
static inline bool LVecBase2f::validate_ptr(void const *ptr);

1974 10 operator = 0 4 3524 22 LVecBase2f::operator = 0 2 8 9 0
119
void LVecBase2f::operator =(LVecBase2f const &copy) = default;
void LVecBase2f::operator =(float fill_value) = default;

1975 4 zero 0 4 3524 16 LVecBase2f::zero 0 1 10 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2f const &LVecBase2f::zero(void);

1976 6 unit_x 0 4 3524 18 LVecBase2f::unit_x 0 1 11 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_x(void);

1977 6 unit_y 0 4 3524 18 LVecBase2f::unit_y 0 1 12 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2f const &LVecBase2f::unit_y(void);

1978 10 __reduce__ 0 4 3524 22 LVecBase2f::__reduce__ 0 1 13 0
62
inline PyObject *LVecBase2f::__reduce__(PyObject *self) const;

1979 11 __getattr__ 0 4 3524 23 LVecBase2f::__getattr__ 0 1 14 0
93
inline PyObject *LVecBase2f::__getattr__(PyObject *self, std::string const &attr_name) const;

1980 11 __setattr__ 0 4 3524 23 LVecBase2f::__setattr__ 0 1 15 0
99
inline int LVecBase2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

1981 11 operator [] 0 4 3524 23 LVecBase2f::operator [] 0 2 16 17 10
/**
 *
 */
96
inline float LVecBase2f::operator [](int i) const;
inline float &LVecBase2f::operator [](int i);

1982 4 size 0 4 3524 16 LVecBase2f::size 0 1 18 0
44
static constexpr int LVecBase2f::size(void);

1983 6 is_nan 0 4 3524 18 LVecBase2f::is_nan 0 1 19 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2f::is_nan(void) const;

1984 8 get_cell 0 4 3524 20 LVecBase2f::get_cell 0 1 20 10
/**
 *
 */
47
inline float LVecBase2f::get_cell(int i) const;

1985 8 set_cell 0 4 3524 20 LVecBase2f::set_cell 0 1 21 10
/**
 *
 */
53
inline void LVecBase2f::set_cell(int i, float value);

1986 5 get_x 0 4 3524 17 LVecBase2f::get_x 0 1 22 10
/**
 *
 */
43
inline float LVecBase2f::get_x(void) const;

1987 5 get_y 0 4 3524 17 LVecBase2f::get_y 0 1 23 10
/**
 *
 */
43
inline float LVecBase2f::get_y(void) const;

1988 5 set_x 0 4 3524 17 LVecBase2f::set_x 0 1 24 10
/**
 *
 */
43
inline void LVecBase2f::set_x(float value);

1989 5 set_y 0 4 3524 17 LVecBase2f::set_y 0 1 25 10
/**
 *
 */
43
inline void LVecBase2f::set_y(float value);

1990 11 add_to_cell 0 4 3524 23 LVecBase2f::add_to_cell 0 1 26 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase2f::add_to_cell(int i, float value);

1991 5 add_x 0 4 3524 17 LVecBase2f::add_x 0 1 27 10
/**
 *
 */
43
inline void LVecBase2f::add_x(float value);

1992 5 add_y 0 4 3524 17 LVecBase2f::add_y 0 1 28 10
/**
 *
 */
43
inline void LVecBase2f::add_y(float value);

1993 8 get_data 0 4 3524 20 LVecBase2f::get_data 0 1 29 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
53
inline float const *LVecBase2f::get_data(void) const;

1994 18 get_num_components 0 4 3524 30 LVecBase2f::get_num_components 0 1 30 0
58
static constexpr int LVecBase2f::get_num_components(void);

1995 4 fill 0 4 3524 16 LVecBase2f::fill 0 1 31 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase2f::fill(float fill_value);

1996 3 set 0 4 3524 15 LVecBase2f::set 0 1 32 10
/**
 *
 */
46
inline void LVecBase2f::set(float x, float y);

1997 3 dot 0 4 3524 15 LVecBase2f::dot 0 1 33 10
/**
 *
 */
60
inline float LVecBase2f::dot(LVecBase2f const &other) const;

1998 14 length_squared 0 4 3524 26 LVecBase2f::length_squared 0 1 34 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase2f::length_squared(void) const;

1999 6 length 0 4 3524 18 LVecBase2f::length 0 1 35 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase2f::length(void) const;

2000 9 normalize 0 4 3524 21 LVecBase2f::normalize 0 1 36 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2f::normalize(void);

2001 10 normalized 0 4 3524 22 LVecBase2f::normalized 0 1 37 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2f LVecBase2f::normalized(void) const;

2002 7 project 0 4 3524 19 LVecBase2f::project 0 1 38 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2f LVecBase2f::project(LVecBase2f const &onto) const;

2003 10 operator < 0 4 3524 22 LVecBase2f::operator < 0 1 39 0
66
inline bool LVecBase2f::operator <(LVecBase2f const &other) const;

2004 11 operator == 0 4 3524 23 LVecBase2f::operator == 0 1 40 0
67
inline bool LVecBase2f::operator ==(LVecBase2f const &other) const;

2005 11 operator != 0 4 3524 23 LVecBase2f::operator != 0 1 41 0
67
inline bool LVecBase2f::operator !=(LVecBase2f const &other) const;

2006 10 compare_to 0 4 3524 22 LVecBase2f::compare_to 0 2 42 43 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase2f::compare_to(LVecBase2f const &other) const;
inline int LVecBase2f::compare_to(LVecBase2f const &other, float threshold) const;

2007 8 get_hash 0 4 3524 20 LVecBase2f::get_hash 0 2 44 45 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase2f::get_hash(void) const;
inline std::size_t LVecBase2f::get_hash(float threshold) const;

2008 8 add_hash 0 4 3524 20 LVecBase2f::add_hash 0 2 46 47 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase2f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2f::add_hash(std::size_t hash, float threshold) const;

2009 13 generate_hash 0 4 3524 25 LVecBase2f::generate_hash 0 2 48 49 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2010 10 operator - 0 68 3524 22 LVecBase2f::operator - 0 1 50 0
53
inline LVecBase2f LVecBase2f::operator -(void) const;

2011 10 operator + 0 4 3524 22 LVecBase2f::operator + 0 1 51 0
72
inline LVecBase2f LVecBase2f::operator +(LVecBase2f const &other) const;

2012 10 operator - 0 4 3524 22 LVecBase2f::operator - 0 1 52 0
72
inline LVecBase2f LVecBase2f::operator -(LVecBase2f const &other) const;

2013 10 operator * 0 4 3524 22 LVecBase2f::operator * 0 1 53 0
61
inline LVecBase2f LVecBase2f::operator *(float scalar) const;

2014 10 operator / 0 4 3524 22 LVecBase2f::operator / 0 1 54 0
61
inline LVecBase2f LVecBase2f::operator /(float scalar) const;

2015 11 operator += 0 4 3524 23 LVecBase2f::operator += 0 1 55 0
61
inline void LVecBase2f::operator +=(LVecBase2f const &other);

2016 11 operator -= 0 4 3524 23 LVecBase2f::operator -= 0 1 56 0
61
inline void LVecBase2f::operator -=(LVecBase2f const &other);

2017 11 operator *= 0 4 3524 23 LVecBase2f::operator *= 0 1 57 0
50
inline void LVecBase2f::operator *=(float scalar);

2018 11 operator /= 0 4 3524 23 LVecBase2f::operator /= 0 1 58 0
50
inline void LVecBase2f::operator /=(float scalar);

2019 18 componentwise_mult 0 4 3524 30 LVecBase2f::componentwise_mult 0 1 59 10
/**
 *
 */
68
inline void LVecBase2f::componentwise_mult(LVecBase2f const &other);

2020 7 __pow__ 0 4 3524 19 LVecBase2f::__pow__ 0 1 60 0
60
inline LVecBase2f LVecBase2f::__pow__(float exponent) const;

2021 8 __ipow__ 0 4 3524 20 LVecBase2f::__ipow__ 0 1 61 0
70
inline PyObject *LVecBase2f::__ipow__(PyObject *self, float exponent);

2022 4 fmax 0 4 3524 16 LVecBase2f::fmax 0 1 62 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmax(LVecBase2f const &other) const;

2023 4 fmin 0 4 3524 16 LVecBase2f::fmin 0 1 63 10
/**
 *
 */
66
inline LVecBase2f LVecBase2f::fmin(LVecBase2f const &other) const;

2024 12 almost_equal 0 4 3524 24 LVecBase2f::almost_equal 0 2 64 65 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase2f::almost_equal(LVecBase2f const &other, float threshold) const;
inline bool LVecBase2f::almost_equal(LVecBase2f const &other) const;

2025 6 output 0 4 3524 18 LVecBase2f::output 0 1 66 10
/**
 *
 */
56
inline void LVecBase2f::output(std::ostream &out) const;

2026 8 __repr__ 0 4 3524 20 LVecBase2f::__repr__ 0 1 67 0
52
inline std::string LVecBase2f::__repr__(void) const;

2027 20 write_datagram_fixed 0 4 3524 32 LVecBase2f::write_datagram_fixed 0 1 68 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2f::write_datagram_fixed(Datagram &destination) const;

2028 19 read_datagram_fixed 0 4 3524 31 LVecBase2f::read_datagram_fixed 0 1 69 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2f::read_datagram_fixed(DatagramIterator &source);

2029 14 write_datagram 0 4 3524 26 LVecBase2f::write_datagram 0 1 70 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2f::write_datagram(Datagram &destination) const;

2030 13 read_datagram 0 4 3524 25 LVecBase2f::read_datagram 0 1 71 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2f::read_datagram(DatagramIterator &source);

2031 14 get_class_type 0 4 3524 26 LVecBase2f::get_class_type 0 1 72 0
51
static TypeHandle LVecBase2f::get_class_type(void);

2032 11 ~LVecBase2f 0 4 3524 23 LVecBase2f::~LVecBase2f 0 0 0
30
LVecBase2f::~LVecBase2f(void);

2033 10 LVecBase2d 0 4 3527 22 LVecBase2d::LVecBase2d 0 4 73 74 75 76 22
/**
 *
 */

/**
 *
 */
208
inline LVecBase2d::LVecBase2d(void) = default;
inline LVecBase2d::LVecBase2d(double fill_value);
inline LVecBase2d::LVecBase2d(double x, double y);
inline LVecBase2d::LVecBase2d(LVecBase2d const &) = default;

2034 12 operator new 0 4 3527 24 LVecBase2d::operator new 0 1 77 0
124
inline void *LVecBase2d::operator new(std::size_t size);
inline void *LVecBase2d::operator new(std::size_t size, void *ptr);

2035 15 operator delete 0 4 3527 27 LVecBase2d::operator delete 0 0 0
108
inline void LVecBase2d::operator delete(void *ptr);
inline void LVecBase2d::operator delete(void *, void *);

2036 12 validate_ptr 0 4 3527 24 LVecBase2d::validate_ptr 0 0 0
61
static inline bool LVecBase2d::validate_ptr(void const *ptr);

2037 10 operator = 0 4 3527 22 LVecBase2d::operator = 0 2 78 79 0
120
void LVecBase2d::operator =(LVecBase2d const &copy) = default;
void LVecBase2d::operator =(double fill_value) = default;

2038 4 zero 0 4 3527 16 LVecBase2d::zero 0 1 80 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2d const &LVecBase2d::zero(void);

2039 6 unit_x 0 4 3527 18 LVecBase2d::unit_x 0 1 81 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_x(void);

2040 6 unit_y 0 4 3527 18 LVecBase2d::unit_y 0 1 82 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2d const &LVecBase2d::unit_y(void);

2041 10 __reduce__ 0 4 3527 22 LVecBase2d::__reduce__ 0 1 83 0
62
inline PyObject *LVecBase2d::__reduce__(PyObject *self) const;

2042 11 __getattr__ 0 4 3527 23 LVecBase2d::__getattr__ 0 1 84 0
93
inline PyObject *LVecBase2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2043 11 __setattr__ 0 4 3527 23 LVecBase2d::__setattr__ 0 1 85 0
99
inline int LVecBase2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2044 11 operator [] 0 4 3527 23 LVecBase2d::operator [] 0 2 86 87 10
/**
 *
 */
98
inline double LVecBase2d::operator [](int i) const;
inline double &LVecBase2d::operator [](int i);

2045 4 size 0 4 3527 16 LVecBase2d::size 0 1 88 0
44
static constexpr int LVecBase2d::size(void);

2046 6 is_nan 0 4 3527 18 LVecBase2d::is_nan 0 1 89 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2d::is_nan(void) const;

2047 8 get_cell 0 4 3527 20 LVecBase2d::get_cell 0 1 90 10
/**
 *
 */
48
inline double LVecBase2d::get_cell(int i) const;

2048 8 set_cell 0 4 3527 20 LVecBase2d::set_cell 0 1 91 10
/**
 *
 */
54
inline void LVecBase2d::set_cell(int i, double value);

2049 5 get_x 0 4 3527 17 LVecBase2d::get_x 0 1 92 10
/**
 *
 */
44
inline double LVecBase2d::get_x(void) const;

2050 5 get_y 0 4 3527 17 LVecBase2d::get_y 0 1 93 10
/**
 *
 */
44
inline double LVecBase2d::get_y(void) const;

2051 5 set_x 0 4 3527 17 LVecBase2d::set_x 0 1 94 10
/**
 *
 */
44
inline void LVecBase2d::set_x(double value);

2052 5 set_y 0 4 3527 17 LVecBase2d::set_y 0 1 95 10
/**
 *
 */
44
inline void LVecBase2d::set_y(double value);

2053 11 add_to_cell 0 4 3527 23 LVecBase2d::add_to_cell 0 1 96 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase2d::add_to_cell(int i, double value);

2054 5 add_x 0 4 3527 17 LVecBase2d::add_x 0 1 97 10
/**
 *
 */
44
inline void LVecBase2d::add_x(double value);

2055 5 add_y 0 4 3527 17 LVecBase2d::add_y 0 1 98 10
/**
 *
 */
44
inline void LVecBase2d::add_y(double value);

2056 8 get_data 0 4 3527 20 LVecBase2d::get_data 0 1 99 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
54
inline double const *LVecBase2d::get_data(void) const;

2057 18 get_num_components 0 4 3527 30 LVecBase2d::get_num_components 0 1 100 0
58
static constexpr int LVecBase2d::get_num_components(void);

2058 4 fill 0 4 3527 16 LVecBase2d::fill 0 1 101 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase2d::fill(double fill_value);

2059 3 set 0 4 3527 15 LVecBase2d::set 0 1 102 10
/**
 *
 */
48
inline void LVecBase2d::set(double x, double y);

2060 3 dot 0 4 3527 15 LVecBase2d::dot 0 1 103 10
/**
 *
 */
61
inline double LVecBase2d::dot(LVecBase2d const &other) const;

2061 14 length_squared 0 4 3527 26 LVecBase2d::length_squared 0 1 104 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase2d::length_squared(void) const;

2062 6 length 0 4 3527 18 LVecBase2d::length 0 1 105 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase2d::length(void) const;

2063 9 normalize 0 4 3527 21 LVecBase2d::normalize 0 1 106 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase2d::normalize(void);

2064 10 normalized 0 4 3527 22 LVecBase2d::normalized 0 1 107 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase2d LVecBase2d::normalized(void) const;

2065 7 project 0 4 3527 19 LVecBase2d::project 0 1 108 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase2d LVecBase2d::project(LVecBase2d const &onto) const;

2066 10 operator < 0 4 3527 22 LVecBase2d::operator < 0 1 109 0
66
inline bool LVecBase2d::operator <(LVecBase2d const &other) const;

2067 11 operator == 0 4 3527 23 LVecBase2d::operator == 0 1 110 0
67
inline bool LVecBase2d::operator ==(LVecBase2d const &other) const;

2068 11 operator != 0 4 3527 23 LVecBase2d::operator != 0 1 111 0
67
inline bool LVecBase2d::operator !=(LVecBase2d const &other) const;

2069 10 compare_to 0 4 3527 22 LVecBase2d::compare_to 0 2 112 113 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase2d::compare_to(LVecBase2d const &other) const;
inline int LVecBase2d::compare_to(LVecBase2d const &other, double threshold) const;

2070 8 get_hash 0 4 3527 20 LVecBase2d::get_hash 0 2 114 115 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase2d::get_hash(void) const;
inline std::size_t LVecBase2d::get_hash(double threshold) const;

2071 8 add_hash 0 4 3527 20 LVecBase2d::add_hash 0 2 116 117 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase2d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase2d::add_hash(std::size_t hash, double threshold) const;

2072 13 generate_hash 0 4 3527 25 LVecBase2d::generate_hash 0 2 118 119 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase2d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2073 10 operator - 0 68 3527 22 LVecBase2d::operator - 0 1 120 0
53
inline LVecBase2d LVecBase2d::operator -(void) const;

2074 10 operator + 0 4 3527 22 LVecBase2d::operator + 0 1 121 0
72
inline LVecBase2d LVecBase2d::operator +(LVecBase2d const &other) const;

2075 10 operator - 0 4 3527 22 LVecBase2d::operator - 0 1 122 0
72
inline LVecBase2d LVecBase2d::operator -(LVecBase2d const &other) const;

2076 10 operator * 0 4 3527 22 LVecBase2d::operator * 0 1 123 0
62
inline LVecBase2d LVecBase2d::operator *(double scalar) const;

2077 10 operator / 0 4 3527 22 LVecBase2d::operator / 0 1 124 0
62
inline LVecBase2d LVecBase2d::operator /(double scalar) const;

2078 11 operator += 0 4 3527 23 LVecBase2d::operator += 0 1 125 0
61
inline void LVecBase2d::operator +=(LVecBase2d const &other);

2079 11 operator -= 0 4 3527 23 LVecBase2d::operator -= 0 1 126 0
61
inline void LVecBase2d::operator -=(LVecBase2d const &other);

2080 11 operator *= 0 4 3527 23 LVecBase2d::operator *= 0 1 127 0
51
inline void LVecBase2d::operator *=(double scalar);

2081 11 operator /= 0 4 3527 23 LVecBase2d::operator /= 0 1 128 0
51
inline void LVecBase2d::operator /=(double scalar);

2082 18 componentwise_mult 0 4 3527 30 LVecBase2d::componentwise_mult 0 1 129 10
/**
 *
 */
68
inline void LVecBase2d::componentwise_mult(LVecBase2d const &other);

2083 7 __pow__ 0 4 3527 19 LVecBase2d::__pow__ 0 1 130 0
61
inline LVecBase2d LVecBase2d::__pow__(double exponent) const;

2084 8 __ipow__ 0 4 3527 20 LVecBase2d::__ipow__ 0 1 131 0
71
inline PyObject *LVecBase2d::__ipow__(PyObject *self, double exponent);

2085 4 fmax 0 4 3527 16 LVecBase2d::fmax 0 1 132 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmax(LVecBase2d const &other) const;

2086 4 fmin 0 4 3527 16 LVecBase2d::fmin 0 1 133 10
/**
 *
 */
66
inline LVecBase2d LVecBase2d::fmin(LVecBase2d const &other) const;

2087 12 almost_equal 0 4 3527 24 LVecBase2d::almost_equal 0 2 134 135 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase2d::almost_equal(LVecBase2d const &other, double threshold) const;
inline bool LVecBase2d::almost_equal(LVecBase2d const &other) const;

2088 6 output 0 4 3527 18 LVecBase2d::output 0 1 136 10
/**
 *
 */
56
inline void LVecBase2d::output(std::ostream &out) const;

2089 8 __repr__ 0 4 3527 20 LVecBase2d::__repr__ 0 1 137 0
52
inline std::string LVecBase2d::__repr__(void) const;

2090 20 write_datagram_fixed 0 4 3527 32 LVecBase2d::write_datagram_fixed 0 1 138 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2d::write_datagram_fixed(Datagram &destination) const;

2091 19 read_datagram_fixed 0 4 3527 31 LVecBase2d::read_datagram_fixed 0 1 139 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2d::read_datagram_fixed(DatagramIterator &source);

2092 14 write_datagram 0 4 3527 26 LVecBase2d::write_datagram 0 1 140 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2d::write_datagram(Datagram &destination) const;

2093 13 read_datagram 0 4 3527 25 LVecBase2d::read_datagram 0 1 141 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2d::read_datagram(DatagramIterator &source);

2094 14 get_class_type 0 4 3527 26 LVecBase2d::get_class_type 0 1 142 0
51
static TypeHandle LVecBase2d::get_class_type(void);

2095 11 ~LVecBase2d 0 4 3527 23 LVecBase2d::~LVecBase2d 0 0 0
30
LVecBase2d::~LVecBase2d(void);

2096 10 LVecBase2i 0 4 3530 22 LVecBase2i::LVecBase2i 0 4 143 144 145 146 22
/**
 *
 */

/**
 *
 */
199
inline LVecBase2i::LVecBase2i(void) = default;
inline LVecBase2i::LVecBase2i(int fill_value);
inline LVecBase2i::LVecBase2i(int x, int y);
inline LVecBase2i::LVecBase2i(LVecBase2i const &) = default;

2097 12 operator new 0 4 3530 24 LVecBase2i::operator new 0 1 147 0
124
inline void *LVecBase2i::operator new(std::size_t size);
inline void *LVecBase2i::operator new(std::size_t size, void *ptr);

2098 15 operator delete 0 4 3530 27 LVecBase2i::operator delete 0 0 0
108
inline void LVecBase2i::operator delete(void *ptr);
inline void LVecBase2i::operator delete(void *, void *);

2099 12 validate_ptr 0 4 3530 24 LVecBase2i::validate_ptr 0 0 0
61
static inline bool LVecBase2i::validate_ptr(void const *ptr);

2100 10 operator = 0 4 3530 22 LVecBase2i::operator = 0 2 148 149 0
117
void LVecBase2i::operator =(LVecBase2i const &copy) = default;
void LVecBase2i::operator =(int fill_value) = default;

2101 4 zero 0 4 3530 16 LVecBase2i::zero 0 1 150 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase2i const &LVecBase2i::zero(void);

2102 6 unit_x 0 4 3530 18 LVecBase2i::unit_x 0 1 151 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_x(void);

2103 6 unit_y 0 4 3530 18 LVecBase2i::unit_y 0 1 152 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase2i const &LVecBase2i::unit_y(void);

2104 10 __reduce__ 0 4 3530 22 LVecBase2i::__reduce__ 0 1 153 0
62
inline PyObject *LVecBase2i::__reduce__(PyObject *self) const;

2105 11 __getattr__ 0 4 3530 23 LVecBase2i::__getattr__ 0 1 154 0
93
inline PyObject *LVecBase2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2106 11 __setattr__ 0 4 3530 23 LVecBase2i::__setattr__ 0 1 155 0
99
inline int LVecBase2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2107 11 operator [] 0 4 3530 23 LVecBase2i::operator [] 0 2 156 157 10
/**
 *
 */
92
inline int LVecBase2i::operator [](int i) const;
inline int &LVecBase2i::operator [](int i);

2108 4 size 0 4 3530 16 LVecBase2i::size 0 1 158 0
44
static constexpr int LVecBase2i::size(void);

2109 6 is_nan 0 4 3530 18 LVecBase2i::is_nan 0 1 159 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase2i::is_nan(void) const;

2110 8 get_cell 0 4 3530 20 LVecBase2i::get_cell 0 1 160 10
/**
 *
 */
45
inline int LVecBase2i::get_cell(int i) const;

2111 8 set_cell 0 4 3530 20 LVecBase2i::set_cell 0 1 161 10
/**
 *
 */
51
inline void LVecBase2i::set_cell(int i, int value);

2112 5 get_x 0 4 3530 17 LVecBase2i::get_x 0 1 162 10
/**
 *
 */
41
inline int LVecBase2i::get_x(void) const;

2113 5 get_y 0 4 3530 17 LVecBase2i::get_y 0 1 163 10
/**
 *
 */
41
inline int LVecBase2i::get_y(void) const;

2114 5 set_x 0 4 3530 17 LVecBase2i::set_x 0 1 164 10
/**
 *
 */
41
inline void LVecBase2i::set_x(int value);

2115 5 set_y 0 4 3530 17 LVecBase2i::set_y 0 1 165 10
/**
 *
 */
41
inline void LVecBase2i::set_y(int value);

2116 11 add_to_cell 0 4 3530 23 LVecBase2i::add_to_cell 0 1 166 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase2i::add_to_cell(int i, int value);

2117 5 add_x 0 4 3530 17 LVecBase2i::add_x 0 1 167 10
/**
 *
 */
41
inline void LVecBase2i::add_x(int value);

2118 5 add_y 0 4 3530 17 LVecBase2i::add_y 0 1 168 10
/**
 *
 */
41
inline void LVecBase2i::add_y(int value);

2119 8 get_data 0 4 3530 20 LVecBase2i::get_data 0 1 169 155
/**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */
51
inline int const *LVecBase2i::get_data(void) const;

2120 18 get_num_components 0 4 3530 30 LVecBase2i::get_num_components 0 1 170 0
58
static constexpr int LVecBase2i::get_num_components(void);

2121 4 fill 0 4 3530 16 LVecBase2i::fill 0 1 171 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase2i::fill(int fill_value);

2122 3 set 0 4 3530 15 LVecBase2i::set 0 1 172 10
/**
 *
 */
42
inline void LVecBase2i::set(int x, int y);

2123 3 dot 0 4 3530 15 LVecBase2i::dot 0 1 173 10
/**
 *
 */
58
inline int LVecBase2i::dot(LVecBase2i const &other) const;

2124 14 length_squared 0 4 3530 26 LVecBase2i::length_squared 0 1 174 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase2i::length_squared(void) const;

2125 10 operator < 0 4 3530 22 LVecBase2i::operator < 0 1 175 0
66
inline bool LVecBase2i::operator <(LVecBase2i const &other) const;

2126 11 operator == 0 4 3530 23 LVecBase2i::operator == 0 1 176 0
67
inline bool LVecBase2i::operator ==(LVecBase2i const &other) const;

2127 11 operator != 0 4 3530 23 LVecBase2i::operator != 0 1 177 0
67
inline bool LVecBase2i::operator !=(LVecBase2i const &other) const;

2128 10 compare_to 0 4 3530 22 LVecBase2i::compare_to 0 1 178 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase2i::compare_to(LVecBase2i const &other) const;

2129 8 get_hash 0 4 3530 20 LVecBase2i::get_hash 0 1 179 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase2i::get_hash(void) const;

2130 8 add_hash 0 4 3530 20 LVecBase2i::add_hash 0 1 180 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase2i::add_hash(std::size_t hash) const;

2131 13 generate_hash 0 4 3530 25 LVecBase2i::generate_hash 0 1 181 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase2i::generate_hash(ChecksumHashGenerator &hashgen) const;

2132 10 operator - 0 68 3530 22 LVecBase2i::operator - 0 1 182 0
53
inline LVecBase2i LVecBase2i::operator -(void) const;

2133 10 operator + 0 4 3530 22 LVecBase2i::operator + 0 1 183 0
72
inline LVecBase2i LVecBase2i::operator +(LVecBase2i const &other) const;

2134 10 operator - 0 4 3530 22 LVecBase2i::operator - 0 1 184 0
72
inline LVecBase2i LVecBase2i::operator -(LVecBase2i const &other) const;

2135 10 operator * 0 4 3530 22 LVecBase2i::operator * 0 1 185 0
59
inline LVecBase2i LVecBase2i::operator *(int scalar) const;

2136 10 operator / 0 4 3530 22 LVecBase2i::operator / 0 1 186 0
59
inline LVecBase2i LVecBase2i::operator /(int scalar) const;

2137 11 operator += 0 4 3530 23 LVecBase2i::operator += 0 1 187 0
61
inline void LVecBase2i::operator +=(LVecBase2i const &other);

2138 11 operator -= 0 4 3530 23 LVecBase2i::operator -= 0 1 188 0
61
inline void LVecBase2i::operator -=(LVecBase2i const &other);

2139 11 operator *= 0 4 3530 23 LVecBase2i::operator *= 0 1 189 0
48
inline void LVecBase2i::operator *=(int scalar);

2140 11 operator /= 0 4 3530 23 LVecBase2i::operator /= 0 1 190 0
48
inline void LVecBase2i::operator /=(int scalar);

2141 18 componentwise_mult 0 4 3530 30 LVecBase2i::componentwise_mult 0 1 191 10
/**
 *
 */
68
inline void LVecBase2i::componentwise_mult(LVecBase2i const &other);

2142 7 __pow__ 0 4 3530 19 LVecBase2i::__pow__ 0 1 192 0
58
inline LVecBase2i LVecBase2i::__pow__(int exponent) const;

2143 8 __ipow__ 0 4 3530 20 LVecBase2i::__ipow__ 0 1 193 0
68
inline PyObject *LVecBase2i::__ipow__(PyObject *self, int exponent);

2144 4 fmax 0 4 3530 16 LVecBase2i::fmax 0 1 194 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmax(LVecBase2i const &other) const;

2145 4 fmin 0 4 3530 16 LVecBase2i::fmin 0 1 195 10
/**
 *
 */
66
inline LVecBase2i LVecBase2i::fmin(LVecBase2i const &other) const;

2146 12 almost_equal 0 4 3530 24 LVecBase2i::almost_equal 0 2 196 197 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase2i::almost_equal(LVecBase2i const &other, int threshold) const;
inline bool LVecBase2i::almost_equal(LVecBase2i const &other) const;

2147 6 output 0 4 3530 18 LVecBase2i::output 0 1 198 10
/**
 *
 */
56
inline void LVecBase2i::output(std::ostream &out) const;

2148 8 __repr__ 0 4 3530 20 LVecBase2i::__repr__ 0 1 199 0
52
inline std::string LVecBase2i::__repr__(void) const;

2149 20 write_datagram_fixed 0 4 3530 32 LVecBase2i::write_datagram_fixed 0 1 200 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase2i::write_datagram_fixed(Datagram &destination) const;

2150 19 read_datagram_fixed 0 4 3530 31 LVecBase2i::read_datagram_fixed 0 1 201 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase2i::read_datagram_fixed(DatagramIterator &source);

2151 14 write_datagram 0 4 3530 26 LVecBase2i::write_datagram 0 1 202 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase2i::write_datagram(Datagram &destination) const;

2152 13 read_datagram 0 4 3530 25 LVecBase2i::read_datagram 0 1 203 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase2i::read_datagram(DatagramIterator &source);

2153 14 get_class_type 0 4 3530 26 LVecBase2i::get_class_type 0 1 204 0
51
static TypeHandle LVecBase2i::get_class_type(void);

2154 11 ~LVecBase2i 0 4 3530 23 LVecBase2i::~LVecBase2i 0 0 0
30
LVecBase2i::~LVecBase2i(void);

2155 9 LVector2f 0 4 3533 20 LVector2f::LVector2f 0 5 205 206 207 208 209 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
249
inline LVector2f::LVector2f(void) = default;
inline LVector2f::LVector2f(LVecBase2f const &copy);
inline LVector2f::LVector2f(float fill_value);
inline LVector2f::LVector2f(float x, float y);
inline LVector2f::LVector2f(LVector2f const &) = default;

2156 11 __getattr__ 0 4 3533 22 LVector2f::__getattr__ 0 1 210 0
92
inline PyObject *LVector2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2157 11 __setattr__ 0 4 3533 22 LVector2f::__setattr__ 0 1 211 0
98
inline int LVector2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2158 4 zero 0 4 3533 15 LVector2f::zero 0 1 212 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2f const &LVector2f::zero(void);

2159 6 unit_x 0 4 3533 17 LVector2f::unit_x 0 1 213 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2f const &LVector2f::unit_x(void);

2160 6 unit_y 0 4 3533 17 LVector2f::unit_y 0 1 214 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2f const &LVector2f::unit_y(void);

2161 10 operator - 0 68 3533 21 LVector2f::operator - 0 1 215 0
51
inline LVector2f LVector2f::operator -(void) const;

2162 10 operator + 0 4 3533 21 LVector2f::operator + 0 2 216 217 0
141
inline LVecBase2f LVector2f::operator +(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator +(LVector2f const &other) const;

2163 10 operator - 0 4 3533 21 LVector2f::operator - 0 2 218 219 0
141
inline LVecBase2f LVector2f::operator -(LVecBase2f const &other) const;
inline LVector2f LVector2f::operator -(LVector2f const &other) const;

2164 10 operator * 0 4 3533 21 LVector2f::operator * 0 1 220 0
59
inline LVector2f LVector2f::operator *(float scalar) const;

2165 10 operator / 0 4 3533 21 LVector2f::operator / 0 1 221 0
59
inline LVector2f LVector2f::operator /(float scalar) const;

2166 10 normalized 0 4 3533 21 LVector2f::normalized 0 1 222 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2f LVector2f::normalized(void) const;

2167 7 project 0 4 3533 18 LVector2f::project 0 1 223 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2f LVector2f::project(LVecBase2f const &onto) const;

2168 16 signed_angle_rad 0 4 3533 27 LVector2f::signed_angle_rad 0 1 224 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_rad(LVector2f const &other) const;

2169 16 signed_angle_deg 0 4 3533 27 LVector2f::signed_angle_deg 0 1 225 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
71
inline float LVector2f::signed_angle_deg(LVector2f const &other) const;

2170 8 __repr__ 0 4 3533 19 LVector2f::__repr__ 0 1 226 0
51
inline std::string LVector2f::__repr__(void) const;

2171 14 get_class_type 0 4 3533 25 LVector2f::get_class_type 0 1 227 0
50
static TypeHandle LVector2f::get_class_type(void);

2172 10 ~LVector2f 0 4 3533 21 LVector2f::~LVector2f 0 0 0
28
LVector2f::~LVector2f(void);

2173 9 LVector2d 0 4 3534 20 LVector2d::LVector2d 0 5 228 229 230 231 232 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
252
inline LVector2d::LVector2d(void) = default;
inline LVector2d::LVector2d(LVecBase2d const &copy);
inline LVector2d::LVector2d(double fill_value);
inline LVector2d::LVector2d(double x, double y);
inline LVector2d::LVector2d(LVector2d const &) = default;

2174 11 __getattr__ 0 4 3534 22 LVector2d::__getattr__ 0 1 233 0
92
inline PyObject *LVector2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2175 11 __setattr__ 0 4 3534 22 LVector2d::__setattr__ 0 1 234 0
98
inline int LVector2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2176 4 zero 0 4 3534 15 LVector2d::zero 0 1 235 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2d const &LVector2d::zero(void);

2177 6 unit_x 0 4 3534 17 LVector2d::unit_x 0 1 236 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2d const &LVector2d::unit_x(void);

2178 6 unit_y 0 4 3534 17 LVector2d::unit_y 0 1 237 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2d const &LVector2d::unit_y(void);

2179 10 operator - 0 68 3534 21 LVector2d::operator - 0 1 238 0
51
inline LVector2d LVector2d::operator -(void) const;

2180 10 operator + 0 4 3534 21 LVector2d::operator + 0 2 239 240 0
141
inline LVecBase2d LVector2d::operator +(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator +(LVector2d const &other) const;

2181 10 operator - 0 4 3534 21 LVector2d::operator - 0 2 241 242 0
141
inline LVecBase2d LVector2d::operator -(LVecBase2d const &other) const;
inline LVector2d LVector2d::operator -(LVector2d const &other) const;

2182 10 operator * 0 4 3534 21 LVector2d::operator * 0 1 243 0
60
inline LVector2d LVector2d::operator *(double scalar) const;

2183 10 operator / 0 4 3534 21 LVector2d::operator / 0 1 244 0
60
inline LVector2d LVector2d::operator /(double scalar) const;

2184 10 normalized 0 4 3534 21 LVector2d::normalized 0 1 245 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector2d LVector2d::normalized(void) const;

2185 7 project 0 4 3534 18 LVector2d::project 0 1 246 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector2d LVector2d::project(LVecBase2d const &onto) const;

2186 16 signed_angle_rad 0 4 3534 27 LVector2d::signed_angle_rad 0 1 247 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_rad(LVector2d const &other) const;

2187 16 signed_angle_deg 0 4 3534 27 LVector2d::signed_angle_deg 0 1 248 92
/**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */
72
inline double LVector2d::signed_angle_deg(LVector2d const &other) const;

2188 8 __repr__ 0 4 3534 19 LVector2d::__repr__ 0 1 249 0
51
inline std::string LVector2d::__repr__(void) const;

2189 14 get_class_type 0 4 3534 25 LVector2d::get_class_type 0 1 250 0
50
static TypeHandle LVector2d::get_class_type(void);

2190 10 ~LVector2d 0 4 3534 21 LVector2d::~LVector2d 0 0 0
28
LVector2d::~LVector2d(void);

2191 9 LVector2i 0 4 3535 20 LVector2i::LVector2i 0 5 251 252 253 254 255 146
/**
 * Constructs a new LVector2 from a LVecBase2
 */

/**
 * Constructs a new LVector2 with all components set to the fill value.
 */

/**
 *
 */
243
inline LVector2i::LVector2i(void) = default;
inline LVector2i::LVector2i(LVecBase2i const &copy);
inline LVector2i::LVector2i(int fill_value);
inline LVector2i::LVector2i(int x, int y);
inline LVector2i::LVector2i(LVector2i const &) = default;

2192 11 __getattr__ 0 4 3535 22 LVector2i::__getattr__ 0 1 256 0
92
inline PyObject *LVector2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2193 11 __setattr__ 0 4 3535 22 LVector2i::__setattr__ 0 1 257 0
98
inline int LVector2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2194 4 zero 0 4 3535 15 LVector2i::zero 0 1 258 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector2i const &LVector2i::zero(void);

2195 6 unit_x 0 4 3535 17 LVector2i::unit_x 0 1 259 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector2i const &LVector2i::unit_x(void);

2196 6 unit_y 0 4 3535 17 LVector2i::unit_y 0 1 260 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector2i const &LVector2i::unit_y(void);

2197 10 operator - 0 68 3535 21 LVector2i::operator - 0 1 261 0
51
inline LVector2i LVector2i::operator -(void) const;

2198 10 operator + 0 4 3535 21 LVector2i::operator + 0 2 262 263 0
141
inline LVecBase2i LVector2i::operator +(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator +(LVector2i const &other) const;

2199 10 operator - 0 4 3535 21 LVector2i::operator - 0 2 264 265 0
141
inline LVecBase2i LVector2i::operator -(LVecBase2i const &other) const;
inline LVector2i LVector2i::operator -(LVector2i const &other) const;

2200 10 operator * 0 4 3535 21 LVector2i::operator * 0 1 266 0
57
inline LVector2i LVector2i::operator *(int scalar) const;

2201 10 operator / 0 4 3535 21 LVector2i::operator / 0 1 267 0
57
inline LVector2i LVector2i::operator /(int scalar) const;

2202 8 __repr__ 0 4 3535 19 LVector2i::__repr__ 0 1 268 0
51
inline std::string LVector2i::__repr__(void) const;

2203 14 get_class_type 0 4 3535 25 LVector2i::get_class_type 0 1 269 0
50
static TypeHandle LVector2i::get_class_type(void);

2204 10 ~LVector2i 0 4 3535 21 LVector2i::~LVector2i 0 0 0
28
LVector2i::~LVector2i(void);

2205 8 LPoint2f 0 4 3536 18 LPoint2f::LPoint2f 0 5 270 271 272 273 274 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
238
inline LPoint2f::LPoint2f(void) = default;
inline LPoint2f::LPoint2f(LVecBase2f const &copy);
inline LPoint2f::LPoint2f(float fill_value);
inline LPoint2f::LPoint2f(float x, float y);
inline LPoint2f::LPoint2f(LPoint2f const &) = default;

2206 11 __getattr__ 0 4 3536 21 LPoint2f::__getattr__ 0 1 275 0
91
inline PyObject *LPoint2f::__getattr__(PyObject *self, std::string const &attr_name) const;

2207 11 __setattr__ 0 4 3536 21 LPoint2f::__setattr__ 0 1 276 0
97
inline int LPoint2f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2208 4 zero 0 4 3536 14 LPoint2f::zero 0 1 277 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2f const &LPoint2f::zero(void);

2209 6 unit_x 0 4 3536 16 LPoint2f::unit_x 0 1 278 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2f const &LPoint2f::unit_x(void);

2210 6 unit_y 0 4 3536 16 LPoint2f::unit_y 0 1 279 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2f const &LPoint2f::unit_y(void);

2211 10 operator - 0 68 3536 20 LPoint2f::operator - 0 1 280 0
49
inline LPoint2f LPoint2f::operator -(void) const;

2212 10 operator + 0 4 3536 20 LPoint2f::operator + 0 2 281 282 0
138
inline LVecBase2f LPoint2f::operator +(LVecBase2f const &other) const;
inline LPoint2f LPoint2f::operator +(LVector2f const &other) const;

2213 10 operator - 0 4 3536 20 LPoint2f::operator - 0 3 283 284 285 0
206
inline LVecBase2f LPoint2f::operator -(LVecBase2f const &other) const;
inline LVector2f LPoint2f::operator -(LPoint2f const &other) const;
inline LPoint2f LPoint2f::operator -(LVector2f const &other) const;

2214 10 operator * 0 4 3536 20 LPoint2f::operator * 0 1 286 0
57
inline LPoint2f LPoint2f::operator *(float scalar) const;

2215 10 operator / 0 4 3536 20 LPoint2f::operator / 0 1 287 0
57
inline LPoint2f LPoint2f::operator /(float scalar) const;

2216 10 normalized 0 4 3536 20 LPoint2f::normalized 0 1 288 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2f LPoint2f::normalized(void) const;

2217 7 project 0 4 3536 17 LPoint2f::project 0 1 289 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2f LPoint2f::project(LVecBase2f const &onto) const;

2218 8 __repr__ 0 4 3536 18 LPoint2f::__repr__ 0 1 290 0
50
inline std::string LPoint2f::__repr__(void) const;

2219 14 get_class_type 0 4 3536 24 LPoint2f::get_class_type 0 1 291 0
49
static TypeHandle LPoint2f::get_class_type(void);

2220 9 ~LPoint2f 0 4 3536 19 LPoint2f::~LPoint2f 0 0 0
26
LPoint2f::~LPoint2f(void);

2221 8 LPoint2d 0 4 3537 18 LPoint2d::LPoint2d 0 5 292 293 294 295 296 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
241
inline LPoint2d::LPoint2d(void) = default;
inline LPoint2d::LPoint2d(LVecBase2d const &copy);
inline LPoint2d::LPoint2d(double fill_value);
inline LPoint2d::LPoint2d(double x, double y);
inline LPoint2d::LPoint2d(LPoint2d const &) = default;

2222 11 __getattr__ 0 4 3537 21 LPoint2d::__getattr__ 0 1 297 0
91
inline PyObject *LPoint2d::__getattr__(PyObject *self, std::string const &attr_name) const;

2223 11 __setattr__ 0 4 3537 21 LPoint2d::__setattr__ 0 1 298 0
97
inline int LPoint2d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2224 4 zero 0 4 3537 14 LPoint2d::zero 0 1 299 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2d const &LPoint2d::zero(void);

2225 6 unit_x 0 4 3537 16 LPoint2d::unit_x 0 1 300 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2d const &LPoint2d::unit_x(void);

2226 6 unit_y 0 4 3537 16 LPoint2d::unit_y 0 1 301 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2d const &LPoint2d::unit_y(void);

2227 10 operator - 0 68 3537 20 LPoint2d::operator - 0 1 302 0
49
inline LPoint2d LPoint2d::operator -(void) const;

2228 10 operator + 0 4 3537 20 LPoint2d::operator + 0 2 303 304 0
138
inline LVecBase2d LPoint2d::operator +(LVecBase2d const &other) const;
inline LPoint2d LPoint2d::operator +(LVector2d const &other) const;

2229 10 operator - 0 4 3537 20 LPoint2d::operator - 0 3 305 306 307 0
206
inline LVecBase2d LPoint2d::operator -(LVecBase2d const &other) const;
inline LVector2d LPoint2d::operator -(LPoint2d const &other) const;
inline LPoint2d LPoint2d::operator -(LVector2d const &other) const;

2230 10 operator * 0 4 3537 20 LPoint2d::operator * 0 1 308 0
58
inline LPoint2d LPoint2d::operator *(double scalar) const;

2231 10 operator / 0 4 3537 20 LPoint2d::operator / 0 1 309 0
58
inline LPoint2d LPoint2d::operator /(double scalar) const;

2232 10 normalized 0 4 3537 20 LPoint2d::normalized 0 1 310 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint2d LPoint2d::normalized(void) const;

2233 7 project 0 4 3537 17 LPoint2d::project 0 1 311 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint2d LPoint2d::project(LVecBase2d const &onto) const;

2234 8 __repr__ 0 4 3537 18 LPoint2d::__repr__ 0 1 312 0
50
inline std::string LPoint2d::__repr__(void) const;

2235 14 get_class_type 0 4 3537 24 LPoint2d::get_class_type 0 1 313 0
49
static TypeHandle LPoint2d::get_class_type(void);

2236 9 ~LPoint2d 0 4 3537 19 LPoint2d::~LPoint2d 0 0 0
26
LPoint2d::~LPoint2d(void);

2237 8 LPoint2i 0 4 3538 18 LPoint2i::LPoint2i 0 5 314 315 316 317 318 190
/**
 * Constructs a new LPoint2 from a LVecBase2
 */

/**
 * Constructs a new LPoint2 all components set to the fill value.
 */

/**
 * Constructs a new LPoint2 with the given components
 */
232
inline LPoint2i::LPoint2i(void) = default;
inline LPoint2i::LPoint2i(LVecBase2i const &copy);
inline LPoint2i::LPoint2i(int fill_value);
inline LPoint2i::LPoint2i(int x, int y);
inline LPoint2i::LPoint2i(LPoint2i const &) = default;

2238 11 __getattr__ 0 4 3538 21 LPoint2i::__getattr__ 0 1 319 0
91
inline PyObject *LPoint2i::__getattr__(PyObject *self, std::string const &attr_name) const;

2239 11 __setattr__ 0 4 3538 21 LPoint2i::__setattr__ 0 1 320 0
97
inline int LPoint2i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2240 4 zero 0 4 3538 14 LPoint2i::zero 0 1 321 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint2i const &LPoint2i::zero(void);

2241 6 unit_x 0 4 3538 16 LPoint2i::unit_x 0 1 322 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint2i const &LPoint2i::unit_x(void);

2242 6 unit_y 0 4 3538 16 LPoint2i::unit_y 0 1 323 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint2i const &LPoint2i::unit_y(void);

2243 10 operator - 0 68 3538 20 LPoint2i::operator - 0 1 324 0
49
inline LPoint2i LPoint2i::operator -(void) const;

2244 10 operator + 0 4 3538 20 LPoint2i::operator + 0 2 325 326 0
138
inline LVecBase2i LPoint2i::operator +(LVecBase2i const &other) const;
inline LPoint2i LPoint2i::operator +(LVector2i const &other) const;

2245 10 operator - 0 4 3538 20 LPoint2i::operator - 0 3 327 328 329 0
206
inline LVecBase2i LPoint2i::operator -(LVecBase2i const &other) const;
inline LVector2i LPoint2i::operator -(LPoint2i const &other) const;
inline LPoint2i LPoint2i::operator -(LVector2i const &other) const;

2246 10 operator * 0 4 3538 20 LPoint2i::operator * 0 1 330 0
55
inline LPoint2i LPoint2i::operator *(int scalar) const;

2247 10 operator / 0 4 3538 20 LPoint2i::operator / 0 1 331 0
55
inline LPoint2i LPoint2i::operator /(int scalar) const;

2248 8 __repr__ 0 4 3538 18 LPoint2i::__repr__ 0 1 332 0
50
inline std::string LPoint2i::__repr__(void) const;

2249 14 get_class_type 0 4 3538 24 LPoint2i::get_class_type 0 1 333 0
49
static TypeHandle LPoint2i::get_class_type(void);

2250 9 ~LPoint2i 0 4 3538 19 LPoint2i::~LPoint2i 0 0 0
26
LPoint2i::~LPoint2i(void);

2251 10 LVecBase3f 0 4 3539 22 LVecBase3f::LVecBase3f 0 5 334 335 336 337 338 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
278
inline LVecBase3f::LVecBase3f(void) = default;
inline LVecBase3f::LVecBase3f(float fill_value);
inline LVecBase3f::LVecBase3f(float x, float y, float z);
inline LVecBase3f::LVecBase3f(LVecBase2f const &copy, float z);
inline LVecBase3f::LVecBase3f(LVecBase3f const &) = default;

2252 12 operator new 0 4 3539 24 LVecBase3f::operator new 0 1 339 0
124
inline void *LVecBase3f::operator new(std::size_t size);
inline void *LVecBase3f::operator new(std::size_t size, void *ptr);

2253 15 operator delete 0 4 3539 27 LVecBase3f::operator delete 0 0 0
108
inline void LVecBase3f::operator delete(void *ptr);
inline void LVecBase3f::operator delete(void *, void *);

2254 12 validate_ptr 0 4 3539 24 LVecBase3f::validate_ptr 0 0 0
61
static inline bool LVecBase3f::validate_ptr(void const *ptr);

2255 10 operator = 0 4 3539 22 LVecBase3f::operator = 0 2 340 341 0
119
void LVecBase3f::operator =(LVecBase3f const &copy) = default;
void LVecBase3f::operator =(float fill_value) = default;

2256 4 zero 0 4 3539 16 LVecBase3f::zero 0 1 342 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3f const &LVecBase3f::zero(void);

2257 6 unit_x 0 4 3539 18 LVecBase3f::unit_x 0 1 343 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_x(void);

2258 6 unit_y 0 4 3539 18 LVecBase3f::unit_y 0 1 344 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_y(void);

2259 6 unit_z 0 4 3539 18 LVecBase3f::unit_z 0 1 345 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3f const &LVecBase3f::unit_z(void);

2260 10 __reduce__ 0 4 3539 22 LVecBase3f::__reduce__ 0 1 346 0
62
inline PyObject *LVecBase3f::__reduce__(PyObject *self) const;

2261 11 __getattr__ 0 4 3539 23 LVecBase3f::__getattr__ 0 1 347 0
93
inline PyObject *LVecBase3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2262 11 __setattr__ 0 4 3539 23 LVecBase3f::__setattr__ 0 1 348 0
99
inline int LVecBase3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2263 11 operator [] 0 4 3539 23 LVecBase3f::operator [] 0 2 349 350 10
/**
 *
 */
96
inline float LVecBase3f::operator [](int i) const;
inline float &LVecBase3f::operator [](int i);

2264 4 size 0 4 3539 16 LVecBase3f::size 0 1 351 0
44
static constexpr int LVecBase3f::size(void);

2265 6 is_nan 0 4 3539 18 LVecBase3f::is_nan 0 1 352 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3f::is_nan(void) const;

2266 8 get_cell 0 4 3539 20 LVecBase3f::get_cell 0 1 353 10
/**
 *
 */
47
inline float LVecBase3f::get_cell(int i) const;

2267 5 get_x 0 4 3539 17 LVecBase3f::get_x 0 1 354 10
/**
 *
 */
43
inline float LVecBase3f::get_x(void) const;

2268 5 get_y 0 4 3539 17 LVecBase3f::get_y 0 1 355 10
/**
 *
 */
43
inline float LVecBase3f::get_y(void) const;

2269 5 get_z 0 4 3539 17 LVecBase3f::get_z 0 1 356 10
/**
 *
 */
43
inline float LVecBase3f::get_z(void) const;

2270 8 set_cell 0 4 3539 20 LVecBase3f::set_cell 0 1 357 10
/**
 *
 */
53
inline void LVecBase3f::set_cell(int i, float value);

2271 5 set_x 0 4 3539 17 LVecBase3f::set_x 0 1 358 10
/**
 *
 */
43
inline void LVecBase3f::set_x(float value);

2272 5 set_y 0 4 3539 17 LVecBase3f::set_y 0 1 359 10
/**
 *
 */
43
inline void LVecBase3f::set_y(float value);

2273 5 set_z 0 4 3539 17 LVecBase3f::set_z 0 1 360 10
/**
 *
 */
43
inline void LVecBase3f::set_z(float value);

2274 6 get_xy 0 4 3539 18 LVecBase3f::get_xy 0 1 361 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xy(void) const;

2275 6 get_xz 0 4 3539 18 LVecBase3f::get_xz 0 1 362 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2f LVecBase3f::get_xz(void) const;

2276 6 get_yz 0 4 3539 18 LVecBase3f::get_yz 0 1 363 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2f LVecBase3f::get_yz(void) const;

2277 11 add_to_cell 0 4 3539 23 LVecBase3f::add_to_cell 0 1 364 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase3f::add_to_cell(int i, float value);

2278 5 add_x 0 4 3539 17 LVecBase3f::add_x 0 1 365 10
/**
 *
 */
43
inline void LVecBase3f::add_x(float value);

2279 5 add_y 0 4 3539 17 LVecBase3f::add_y 0 1 366 10
/**
 *
 */
43
inline void LVecBase3f::add_y(float value);

2280 5 add_z 0 4 3539 17 LVecBase3f::add_z 0 1 367 10
/**
 *
 */
43
inline void LVecBase3f::add_z(float value);

2281 8 get_data 0 4 3539 20 LVecBase3f::get_data 0 1 368 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase3f::get_data(void) const;

2282 18 get_num_components 0 4 3539 30 LVecBase3f::get_num_components 0 1 369 0
58
static constexpr int LVecBase3f::get_num_components(void);

2283 4 fill 0 4 3539 16 LVecBase3f::fill 0 1 370 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase3f::fill(float fill_value);

2284 3 set 0 4 3539 15 LVecBase3f::set 0 1 371 10
/**
 *
 */
55
inline void LVecBase3f::set(float x, float y, float z);

2285 3 dot 0 4 3539 15 LVecBase3f::dot 0 1 372 10
/**
 *
 */
60
inline float LVecBase3f::dot(LVecBase3f const &other) const;

2286 14 length_squared 0 4 3539 26 LVecBase3f::length_squared 0 1 373 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase3f::length_squared(void) const;

2287 6 length 0 4 3539 18 LVecBase3f::length 0 1 374 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase3f::length(void) const;

2288 9 normalize 0 4 3539 21 LVecBase3f::normalize 0 1 375 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3f::normalize(void);

2289 10 normalized 0 4 3539 22 LVecBase3f::normalized 0 1 376 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3f LVecBase3f::normalized(void) const;

2290 7 project 0 4 3539 19 LVecBase3f::project 0 1 377 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3f LVecBase3f::project(LVecBase3f const &onto) const;

2291 5 cross 0 4 3539 17 LVecBase3f::cross 0 1 378 10
/**
 *
 */
67
inline LVecBase3f LVecBase3f::cross(LVecBase3f const &other) const;

2292 10 operator < 0 4 3539 22 LVecBase3f::operator < 0 1 379 0
66
inline bool LVecBase3f::operator <(LVecBase3f const &other) const;

2293 11 operator == 0 4 3539 23 LVecBase3f::operator == 0 1 380 0
67
inline bool LVecBase3f::operator ==(LVecBase3f const &other) const;

2294 11 operator != 0 4 3539 23 LVecBase3f::operator != 0 1 381 0
67
inline bool LVecBase3f::operator !=(LVecBase3f const &other) const;

2295 20 get_standardized_hpr 0 4 3539 32 LVecBase3f::get_standardized_hpr 0 1 382 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3f LVecBase3f::get_standardized_hpr(void) const;

2296 10 compare_to 0 4 3539 22 LVecBase3f::compare_to 0 2 383 384 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase3f::compare_to(LVecBase3f const &other) const;
inline int LVecBase3f::compare_to(LVecBase3f const &other, float threshold) const;

2297 8 get_hash 0 4 3539 20 LVecBase3f::get_hash 0 2 385 386 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase3f::get_hash(void) const;
inline std::size_t LVecBase3f::get_hash(float threshold) const;

2298 8 add_hash 0 4 3539 20 LVecBase3f::add_hash 0 2 387 388 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase3f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3f::add_hash(std::size_t hash, float threshold) const;

2299 13 generate_hash 0 4 3539 25 LVecBase3f::generate_hash 0 2 389 390 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2300 10 operator - 0 68 3539 22 LVecBase3f::operator - 0 1 391 0
53
inline LVecBase3f LVecBase3f::operator -(void) const;

2301 10 operator + 0 4 3539 22 LVecBase3f::operator + 0 1 392 0
72
inline LVecBase3f LVecBase3f::operator +(LVecBase3f const &other) const;

2302 10 operator - 0 4 3539 22 LVecBase3f::operator - 0 1 393 0
72
inline LVecBase3f LVecBase3f::operator -(LVecBase3f const &other) const;

2303 10 operator * 0 4 3539 22 LVecBase3f::operator * 0 1 394 0
61
inline LVecBase3f LVecBase3f::operator *(float scalar) const;

2304 10 operator / 0 4 3539 22 LVecBase3f::operator / 0 1 395 0
61
inline LVecBase3f LVecBase3f::operator /(float scalar) const;

2305 11 operator += 0 4 3539 23 LVecBase3f::operator += 0 1 396 0
61
inline void LVecBase3f::operator +=(LVecBase3f const &other);

2306 11 operator -= 0 4 3539 23 LVecBase3f::operator -= 0 1 397 0
61
inline void LVecBase3f::operator -=(LVecBase3f const &other);

2307 11 operator *= 0 4 3539 23 LVecBase3f::operator *= 0 1 398 0
50
inline void LVecBase3f::operator *=(float scalar);

2308 11 operator /= 0 4 3539 23 LVecBase3f::operator /= 0 1 399 0
50
inline void LVecBase3f::operator /=(float scalar);

2309 18 componentwise_mult 0 4 3539 30 LVecBase3f::componentwise_mult 0 1 400 10
/**
 *
 */
68
inline void LVecBase3f::componentwise_mult(LVecBase3f const &other);

2310 7 __pow__ 0 4 3539 19 LVecBase3f::__pow__ 0 1 401 0
60
inline LVecBase3f LVecBase3f::__pow__(float exponent) const;

2311 8 __ipow__ 0 4 3539 20 LVecBase3f::__ipow__ 0 1 402 0
70
inline PyObject *LVecBase3f::__ipow__(PyObject *self, float exponent);

2312 4 fmax 0 4 3539 16 LVecBase3f::fmax 0 1 403 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmax(LVecBase3f const &other) const;

2313 4 fmin 0 4 3539 16 LVecBase3f::fmin 0 1 404 10
/**
 *
 */
66
inline LVecBase3f LVecBase3f::fmin(LVecBase3f const &other) const;

2314 10 cross_into 0 4 3539 22 LVecBase3f::cross_into 0 1 405 10
/**
 *
 */
60
inline void LVecBase3f::cross_into(LVecBase3f const &other);

2315 12 almost_equal 0 4 3539 24 LVecBase3f::almost_equal 0 2 406 407 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase3f::almost_equal(LVecBase3f const &other, float threshold) const;
inline bool LVecBase3f::almost_equal(LVecBase3f const &other) const;

2316 6 output 0 4 3539 18 LVecBase3f::output 0 1 408 10
/**
 *
 */
56
inline void LVecBase3f::output(std::ostream &out) const;

2317 8 __repr__ 0 4 3539 20 LVecBase3f::__repr__ 0 1 409 0
52
inline std::string LVecBase3f::__repr__(void) const;

2318 20 write_datagram_fixed 0 4 3539 32 LVecBase3f::write_datagram_fixed 0 1 410 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3f::write_datagram_fixed(Datagram &destination) const;

2319 19 read_datagram_fixed 0 4 3539 31 LVecBase3f::read_datagram_fixed 0 1 411 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3f::read_datagram_fixed(DatagramIterator &source);

2320 14 write_datagram 0 4 3539 26 LVecBase3f::write_datagram 0 1 412 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3f::write_datagram(Datagram &destination) const;

2321 13 read_datagram 0 4 3539 25 LVecBase3f::read_datagram 0 1 413 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3f::read_datagram(DatagramIterator &source);

2322 14 get_class_type 0 4 3539 26 LVecBase3f::get_class_type 0 1 414 0
51
static TypeHandle LVecBase3f::get_class_type(void);

2323 11 ~LVecBase3f 0 4 3539 23 LVecBase3f::~LVecBase3f 0 0 0
30
LVecBase3f::~LVecBase3f(void);

2324 10 LVecBase3d 0 4 3541 22 LVecBase3d::LVecBase3d 0 5 415 416 417 418 419 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
283
inline LVecBase3d::LVecBase3d(void) = default;
inline LVecBase3d::LVecBase3d(double fill_value);
inline LVecBase3d::LVecBase3d(double x, double y, double z);
inline LVecBase3d::LVecBase3d(LVecBase2d const &copy, double z);
inline LVecBase3d::LVecBase3d(LVecBase3d const &) = default;

2325 12 operator new 0 4 3541 24 LVecBase3d::operator new 0 1 420 0
124
inline void *LVecBase3d::operator new(std::size_t size);
inline void *LVecBase3d::operator new(std::size_t size, void *ptr);

2326 15 operator delete 0 4 3541 27 LVecBase3d::operator delete 0 0 0
108
inline void LVecBase3d::operator delete(void *ptr);
inline void LVecBase3d::operator delete(void *, void *);

2327 12 validate_ptr 0 4 3541 24 LVecBase3d::validate_ptr 0 0 0
61
static inline bool LVecBase3d::validate_ptr(void const *ptr);

2328 10 operator = 0 4 3541 22 LVecBase3d::operator = 0 2 421 422 0
120
void LVecBase3d::operator =(LVecBase3d const &copy) = default;
void LVecBase3d::operator =(double fill_value) = default;

2329 4 zero 0 4 3541 16 LVecBase3d::zero 0 1 423 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3d const &LVecBase3d::zero(void);

2330 6 unit_x 0 4 3541 18 LVecBase3d::unit_x 0 1 424 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_x(void);

2331 6 unit_y 0 4 3541 18 LVecBase3d::unit_y 0 1 425 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_y(void);

2332 6 unit_z 0 4 3541 18 LVecBase3d::unit_z 0 1 426 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3d const &LVecBase3d::unit_z(void);

2333 10 __reduce__ 0 4 3541 22 LVecBase3d::__reduce__ 0 1 427 0
62
inline PyObject *LVecBase3d::__reduce__(PyObject *self) const;

2334 11 __getattr__ 0 4 3541 23 LVecBase3d::__getattr__ 0 1 428 0
93
inline PyObject *LVecBase3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2335 11 __setattr__ 0 4 3541 23 LVecBase3d::__setattr__ 0 1 429 0
99
inline int LVecBase3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2336 11 operator [] 0 4 3541 23 LVecBase3d::operator [] 0 2 430 431 10
/**
 *
 */
98
inline double LVecBase3d::operator [](int i) const;
inline double &LVecBase3d::operator [](int i);

2337 4 size 0 4 3541 16 LVecBase3d::size 0 1 432 0
44
static constexpr int LVecBase3d::size(void);

2338 6 is_nan 0 4 3541 18 LVecBase3d::is_nan 0 1 433 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3d::is_nan(void) const;

2339 8 get_cell 0 4 3541 20 LVecBase3d::get_cell 0 1 434 10
/**
 *
 */
48
inline double LVecBase3d::get_cell(int i) const;

2340 5 get_x 0 4 3541 17 LVecBase3d::get_x 0 1 435 10
/**
 *
 */
44
inline double LVecBase3d::get_x(void) const;

2341 5 get_y 0 4 3541 17 LVecBase3d::get_y 0 1 436 10
/**
 *
 */
44
inline double LVecBase3d::get_y(void) const;

2342 5 get_z 0 4 3541 17 LVecBase3d::get_z 0 1 437 10
/**
 *
 */
44
inline double LVecBase3d::get_z(void) const;

2343 8 set_cell 0 4 3541 20 LVecBase3d::set_cell 0 1 438 10
/**
 *
 */
54
inline void LVecBase3d::set_cell(int i, double value);

2344 5 set_x 0 4 3541 17 LVecBase3d::set_x 0 1 439 10
/**
 *
 */
44
inline void LVecBase3d::set_x(double value);

2345 5 set_y 0 4 3541 17 LVecBase3d::set_y 0 1 440 10
/**
 *
 */
44
inline void LVecBase3d::set_y(double value);

2346 5 set_z 0 4 3541 17 LVecBase3d::set_z 0 1 441 10
/**
 *
 */
44
inline void LVecBase3d::set_z(double value);

2347 6 get_xy 0 4 3541 18 LVecBase3d::get_xy 0 1 442 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xy(void) const;

2348 6 get_xz 0 4 3541 18 LVecBase3d::get_xz 0 1 443 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2d LVecBase3d::get_xz(void) const;

2349 6 get_yz 0 4 3541 18 LVecBase3d::get_yz 0 1 444 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2d LVecBase3d::get_yz(void) const;

2350 11 add_to_cell 0 4 3541 23 LVecBase3d::add_to_cell 0 1 445 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase3d::add_to_cell(int i, double value);

2351 5 add_x 0 4 3541 17 LVecBase3d::add_x 0 1 446 10
/**
 *
 */
44
inline void LVecBase3d::add_x(double value);

2352 5 add_y 0 4 3541 17 LVecBase3d::add_y 0 1 447 10
/**
 *
 */
44
inline void LVecBase3d::add_y(double value);

2353 5 add_z 0 4 3541 17 LVecBase3d::add_z 0 1 448 10
/**
 *
 */
44
inline void LVecBase3d::add_z(double value);

2354 8 get_data 0 4 3541 20 LVecBase3d::get_data 0 1 449 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase3d::get_data(void) const;

2355 18 get_num_components 0 4 3541 30 LVecBase3d::get_num_components 0 1 450 0
58
static constexpr int LVecBase3d::get_num_components(void);

2356 4 fill 0 4 3541 16 LVecBase3d::fill 0 1 451 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase3d::fill(double fill_value);

2357 3 set 0 4 3541 15 LVecBase3d::set 0 1 452 10
/**
 *
 */
58
inline void LVecBase3d::set(double x, double y, double z);

2358 3 dot 0 4 3541 15 LVecBase3d::dot 0 1 453 10
/**
 *
 */
61
inline double LVecBase3d::dot(LVecBase3d const &other) const;

2359 14 length_squared 0 4 3541 26 LVecBase3d::length_squared 0 1 454 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase3d::length_squared(void) const;

2360 6 length 0 4 3541 18 LVecBase3d::length 0 1 455 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase3d::length(void) const;

2361 9 normalize 0 4 3541 21 LVecBase3d::normalize 0 1 456 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase3d::normalize(void);

2362 10 normalized 0 4 3541 22 LVecBase3d::normalized 0 1 457 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase3d LVecBase3d::normalized(void) const;

2363 7 project 0 4 3541 19 LVecBase3d::project 0 1 458 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase3d LVecBase3d::project(LVecBase3d const &onto) const;

2364 5 cross 0 4 3541 17 LVecBase3d::cross 0 1 459 10
/**
 *
 */
67
inline LVecBase3d LVecBase3d::cross(LVecBase3d const &other) const;

2365 10 operator < 0 4 3541 22 LVecBase3d::operator < 0 1 460 0
66
inline bool LVecBase3d::operator <(LVecBase3d const &other) const;

2366 11 operator == 0 4 3541 23 LVecBase3d::operator == 0 1 461 0
67
inline bool LVecBase3d::operator ==(LVecBase3d const &other) const;

2367 11 operator != 0 4 3541 23 LVecBase3d::operator != 0 1 462 0
67
inline bool LVecBase3d::operator !=(LVecBase3d const &other) const;

2368 20 get_standardized_hpr 0 4 3541 32 LVecBase3d::get_standardized_hpr 0 1 463 623
/**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */
63
inline LVecBase3d LVecBase3d::get_standardized_hpr(void) const;

2369 10 compare_to 0 4 3541 22 LVecBase3d::compare_to 0 2 464 465 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase3d::compare_to(LVecBase3d const &other) const;
inline int LVecBase3d::compare_to(LVecBase3d const &other, double threshold) const;

2370 8 get_hash 0 4 3541 20 LVecBase3d::get_hash 0 2 466 467 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase3d::get_hash(void) const;
inline std::size_t LVecBase3d::get_hash(double threshold) const;

2371 8 add_hash 0 4 3541 20 LVecBase3d::add_hash 0 2 468 469 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase3d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase3d::add_hash(std::size_t hash, double threshold) const;

2372 13 generate_hash 0 4 3541 25 LVecBase3d::generate_hash 0 2 470 471 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2373 10 operator - 0 68 3541 22 LVecBase3d::operator - 0 1 472 0
53
inline LVecBase3d LVecBase3d::operator -(void) const;

2374 10 operator + 0 4 3541 22 LVecBase3d::operator + 0 1 473 0
72
inline LVecBase3d LVecBase3d::operator +(LVecBase3d const &other) const;

2375 10 operator - 0 4 3541 22 LVecBase3d::operator - 0 1 474 0
72
inline LVecBase3d LVecBase3d::operator -(LVecBase3d const &other) const;

2376 10 operator * 0 4 3541 22 LVecBase3d::operator * 0 1 475 0
62
inline LVecBase3d LVecBase3d::operator *(double scalar) const;

2377 10 operator / 0 4 3541 22 LVecBase3d::operator / 0 1 476 0
62
inline LVecBase3d LVecBase3d::operator /(double scalar) const;

2378 11 operator += 0 4 3541 23 LVecBase3d::operator += 0 1 477 0
61
inline void LVecBase3d::operator +=(LVecBase3d const &other);

2379 11 operator -= 0 4 3541 23 LVecBase3d::operator -= 0 1 478 0
61
inline void LVecBase3d::operator -=(LVecBase3d const &other);

2380 11 operator *= 0 4 3541 23 LVecBase3d::operator *= 0 1 479 0
51
inline void LVecBase3d::operator *=(double scalar);

2381 11 operator /= 0 4 3541 23 LVecBase3d::operator /= 0 1 480 0
51
inline void LVecBase3d::operator /=(double scalar);

2382 18 componentwise_mult 0 4 3541 30 LVecBase3d::componentwise_mult 0 1 481 10
/**
 *
 */
68
inline void LVecBase3d::componentwise_mult(LVecBase3d const &other);

2383 7 __pow__ 0 4 3541 19 LVecBase3d::__pow__ 0 1 482 0
61
inline LVecBase3d LVecBase3d::__pow__(double exponent) const;

2384 8 __ipow__ 0 4 3541 20 LVecBase3d::__ipow__ 0 1 483 0
71
inline PyObject *LVecBase3d::__ipow__(PyObject *self, double exponent);

2385 4 fmax 0 4 3541 16 LVecBase3d::fmax 0 1 484 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmax(LVecBase3d const &other) const;

2386 4 fmin 0 4 3541 16 LVecBase3d::fmin 0 1 485 10
/**
 *
 */
66
inline LVecBase3d LVecBase3d::fmin(LVecBase3d const &other) const;

2387 10 cross_into 0 4 3541 22 LVecBase3d::cross_into 0 1 486 10
/**
 *
 */
60
inline void LVecBase3d::cross_into(LVecBase3d const &other);

2388 12 almost_equal 0 4 3541 24 LVecBase3d::almost_equal 0 2 487 488 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase3d::almost_equal(LVecBase3d const &other, double threshold) const;
inline bool LVecBase3d::almost_equal(LVecBase3d const &other) const;

2389 6 output 0 4 3541 18 LVecBase3d::output 0 1 489 10
/**
 *
 */
56
inline void LVecBase3d::output(std::ostream &out) const;

2390 8 __repr__ 0 4 3541 20 LVecBase3d::__repr__ 0 1 490 0
52
inline std::string LVecBase3d::__repr__(void) const;

2391 20 write_datagram_fixed 0 4 3541 32 LVecBase3d::write_datagram_fixed 0 1 491 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3d::write_datagram_fixed(Datagram &destination) const;

2392 19 read_datagram_fixed 0 4 3541 31 LVecBase3d::read_datagram_fixed 0 1 492 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3d::read_datagram_fixed(DatagramIterator &source);

2393 14 write_datagram 0 4 3541 26 LVecBase3d::write_datagram 0 1 493 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3d::write_datagram(Datagram &destination) const;

2394 13 read_datagram 0 4 3541 25 LVecBase3d::read_datagram 0 1 494 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3d::read_datagram(DatagramIterator &source);

2395 14 get_class_type 0 4 3541 26 LVecBase3d::get_class_type 0 1 495 0
51
static TypeHandle LVecBase3d::get_class_type(void);

2396 11 ~LVecBase3d 0 4 3541 23 LVecBase3d::~LVecBase3d 0 0 0
30
LVecBase3d::~LVecBase3d(void);

2397 10 LVecBase3i 0 4 3543 22 LVecBase3i::LVecBase3i 0 5 496 497 498 499 500 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
268
inline LVecBase3i::LVecBase3i(void) = default;
inline LVecBase3i::LVecBase3i(int fill_value);
inline LVecBase3i::LVecBase3i(int x, int y, int z);
inline LVecBase3i::LVecBase3i(LVecBase2i const &copy, int z);
inline LVecBase3i::LVecBase3i(LVecBase3i const &) = default;

2398 12 operator new 0 4 3543 24 LVecBase3i::operator new 0 1 501 0
124
inline void *LVecBase3i::operator new(std::size_t size);
inline void *LVecBase3i::operator new(std::size_t size, void *ptr);

2399 15 operator delete 0 4 3543 27 LVecBase3i::operator delete 0 0 0
108
inline void LVecBase3i::operator delete(void *ptr);
inline void LVecBase3i::operator delete(void *, void *);

2400 12 validate_ptr 0 4 3543 24 LVecBase3i::validate_ptr 0 0 0
61
static inline bool LVecBase3i::validate_ptr(void const *ptr);

2401 10 operator = 0 4 3543 22 LVecBase3i::operator = 0 2 502 503 0
117
void LVecBase3i::operator =(LVecBase3i const &copy) = default;
void LVecBase3i::operator =(int fill_value) = default;

2402 4 zero 0 4 3543 16 LVecBase3i::zero 0 1 504 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase3i const &LVecBase3i::zero(void);

2403 6 unit_x 0 4 3543 18 LVecBase3i::unit_x 0 1 505 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_x(void);

2404 6 unit_y 0 4 3543 18 LVecBase3i::unit_y 0 1 506 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_y(void);

2405 6 unit_z 0 4 3543 18 LVecBase3i::unit_z 0 1 507 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase3i const &LVecBase3i::unit_z(void);

2406 10 __reduce__ 0 4 3543 22 LVecBase3i::__reduce__ 0 1 508 0
62
inline PyObject *LVecBase3i::__reduce__(PyObject *self) const;

2407 11 __getattr__ 0 4 3543 23 LVecBase3i::__getattr__ 0 1 509 0
93
inline PyObject *LVecBase3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2408 11 __setattr__ 0 4 3543 23 LVecBase3i::__setattr__ 0 1 510 0
99
inline int LVecBase3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2409 11 operator [] 0 4 3543 23 LVecBase3i::operator [] 0 2 511 512 10
/**
 *
 */
92
inline int LVecBase3i::operator [](int i) const;
inline int &LVecBase3i::operator [](int i);

2410 4 size 0 4 3543 16 LVecBase3i::size 0 1 513 0
44
static constexpr int LVecBase3i::size(void);

2411 6 is_nan 0 4 3543 18 LVecBase3i::is_nan 0 1 514 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase3i::is_nan(void) const;

2412 8 get_cell 0 4 3543 20 LVecBase3i::get_cell 0 1 515 10
/**
 *
 */
45
inline int LVecBase3i::get_cell(int i) const;

2413 5 get_x 0 4 3543 17 LVecBase3i::get_x 0 1 516 10
/**
 *
 */
41
inline int LVecBase3i::get_x(void) const;

2414 5 get_y 0 4 3543 17 LVecBase3i::get_y 0 1 517 10
/**
 *
 */
41
inline int LVecBase3i::get_y(void) const;

2415 5 get_z 0 4 3543 17 LVecBase3i::get_z 0 1 518 10
/**
 *
 */
41
inline int LVecBase3i::get_z(void) const;

2416 8 set_cell 0 4 3543 20 LVecBase3i::set_cell 0 1 519 10
/**
 *
 */
51
inline void LVecBase3i::set_cell(int i, int value);

2417 5 set_x 0 4 3543 17 LVecBase3i::set_x 0 1 520 10
/**
 *
 */
41
inline void LVecBase3i::set_x(int value);

2418 5 set_y 0 4 3543 17 LVecBase3i::set_y 0 1 521 10
/**
 *
 */
41
inline void LVecBase3i::set_y(int value);

2419 5 set_z 0 4 3543 17 LVecBase3i::set_z 0 1 522 10
/**
 *
 */
41
inline void LVecBase3i::set_z(int value);

2420 6 get_xy 0 4 3543 18 LVecBase3i::get_xy 0 1 523 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xy(void) const;

2421 6 get_xz 0 4 3543 18 LVecBase3i::get_xz 0 1 524 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
49
inline LVecBase2i LVecBase3i::get_xz(void) const;

2422 6 get_yz 0 4 3543 18 LVecBase3i::get_yz 0 1 525 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
49
inline LVecBase2i LVecBase3i::get_yz(void) const;

2423 11 add_to_cell 0 4 3543 23 LVecBase3i::add_to_cell 0 1 526 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase3i::add_to_cell(int i, int value);

2424 5 add_x 0 4 3543 17 LVecBase3i::add_x 0 1 527 10
/**
 *
 */
41
inline void LVecBase3i::add_x(int value);

2425 5 add_y 0 4 3543 17 LVecBase3i::add_y 0 1 528 10
/**
 *
 */
41
inline void LVecBase3i::add_y(int value);

2426 5 add_z 0 4 3543 17 LVecBase3i::add_z 0 1 529 10
/**
 *
 */
41
inline void LVecBase3i::add_z(int value);

2427 8 get_data 0 4 3543 20 LVecBase3i::get_data 0 1 530 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase3i::get_data(void) const;

2428 18 get_num_components 0 4 3543 30 LVecBase3i::get_num_components 0 1 531 0
58
static constexpr int LVecBase3i::get_num_components(void);

2429 4 fill 0 4 3543 16 LVecBase3i::fill 0 1 532 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase3i::fill(int fill_value);

2430 3 set 0 4 3543 15 LVecBase3i::set 0 1 533 10
/**
 *
 */
49
inline void LVecBase3i::set(int x, int y, int z);

2431 3 dot 0 4 3543 15 LVecBase3i::dot 0 1 534 10
/**
 *
 */
58
inline int LVecBase3i::dot(LVecBase3i const &other) const;

2432 14 length_squared 0 4 3543 26 LVecBase3i::length_squared 0 1 535 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase3i::length_squared(void) const;

2433 5 cross 0 4 3543 17 LVecBase3i::cross 0 1 536 10
/**
 *
 */
67
inline LVecBase3i LVecBase3i::cross(LVecBase3i const &other) const;

2434 10 operator < 0 4 3543 22 LVecBase3i::operator < 0 1 537 0
66
inline bool LVecBase3i::operator <(LVecBase3i const &other) const;

2435 11 operator == 0 4 3543 23 LVecBase3i::operator == 0 1 538 0
67
inline bool LVecBase3i::operator ==(LVecBase3i const &other) const;

2436 11 operator != 0 4 3543 23 LVecBase3i::operator != 0 1 539 0
67
inline bool LVecBase3i::operator !=(LVecBase3i const &other) const;

2437 10 compare_to 0 4 3543 22 LVecBase3i::compare_to 0 1 540 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase3i::compare_to(LVecBase3i const &other) const;

2438 8 get_hash 0 4 3543 20 LVecBase3i::get_hash 0 1 541 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase3i::get_hash(void) const;

2439 8 add_hash 0 4 3543 20 LVecBase3i::add_hash 0 1 542 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase3i::add_hash(std::size_t hash) const;

2440 13 generate_hash 0 4 3543 25 LVecBase3i::generate_hash 0 1 543 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase3i::generate_hash(ChecksumHashGenerator &hashgen) const;

2441 10 operator - 0 68 3543 22 LVecBase3i::operator - 0 1 544 0
53
inline LVecBase3i LVecBase3i::operator -(void) const;

2442 10 operator + 0 4 3543 22 LVecBase3i::operator + 0 1 545 0
72
inline LVecBase3i LVecBase3i::operator +(LVecBase3i const &other) const;

2443 10 operator - 0 4 3543 22 LVecBase3i::operator - 0 1 546 0
72
inline LVecBase3i LVecBase3i::operator -(LVecBase3i const &other) const;

2444 10 operator * 0 4 3543 22 LVecBase3i::operator * 0 1 547 0
59
inline LVecBase3i LVecBase3i::operator *(int scalar) const;

2445 10 operator / 0 4 3543 22 LVecBase3i::operator / 0 1 548 0
59
inline LVecBase3i LVecBase3i::operator /(int scalar) const;

2446 11 operator += 0 4 3543 23 LVecBase3i::operator += 0 1 549 0
61
inline void LVecBase3i::operator +=(LVecBase3i const &other);

2447 11 operator -= 0 4 3543 23 LVecBase3i::operator -= 0 1 550 0
61
inline void LVecBase3i::operator -=(LVecBase3i const &other);

2448 11 operator *= 0 4 3543 23 LVecBase3i::operator *= 0 1 551 0
48
inline void LVecBase3i::operator *=(int scalar);

2449 11 operator /= 0 4 3543 23 LVecBase3i::operator /= 0 1 552 0
48
inline void LVecBase3i::operator /=(int scalar);

2450 18 componentwise_mult 0 4 3543 30 LVecBase3i::componentwise_mult 0 1 553 10
/**
 *
 */
68
inline void LVecBase3i::componentwise_mult(LVecBase3i const &other);

2451 7 __pow__ 0 4 3543 19 LVecBase3i::__pow__ 0 1 554 0
58
inline LVecBase3i LVecBase3i::__pow__(int exponent) const;

2452 8 __ipow__ 0 4 3543 20 LVecBase3i::__ipow__ 0 1 555 0
68
inline PyObject *LVecBase3i::__ipow__(PyObject *self, int exponent);

2453 4 fmax 0 4 3543 16 LVecBase3i::fmax 0 1 556 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmax(LVecBase3i const &other) const;

2454 4 fmin 0 4 3543 16 LVecBase3i::fmin 0 1 557 10
/**
 *
 */
66
inline LVecBase3i LVecBase3i::fmin(LVecBase3i const &other) const;

2455 10 cross_into 0 4 3543 22 LVecBase3i::cross_into 0 1 558 10
/**
 *
 */
60
inline void LVecBase3i::cross_into(LVecBase3i const &other);

2456 12 almost_equal 0 4 3543 24 LVecBase3i::almost_equal 0 2 559 560 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase3i::almost_equal(LVecBase3i const &other, int threshold) const;
inline bool LVecBase3i::almost_equal(LVecBase3i const &other) const;

2457 6 output 0 4 3543 18 LVecBase3i::output 0 1 561 10
/**
 *
 */
56
inline void LVecBase3i::output(std::ostream &out) const;

2458 8 __repr__ 0 4 3543 20 LVecBase3i::__repr__ 0 1 562 0
52
inline std::string LVecBase3i::__repr__(void) const;

2459 20 write_datagram_fixed 0 4 3543 32 LVecBase3i::write_datagram_fixed 0 1 563 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase3i::write_datagram_fixed(Datagram &destination) const;

2460 19 read_datagram_fixed 0 4 3543 31 LVecBase3i::read_datagram_fixed 0 1 564 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase3i::read_datagram_fixed(DatagramIterator &source);

2461 14 write_datagram 0 4 3543 26 LVecBase3i::write_datagram 0 1 565 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase3i::write_datagram(Datagram &destination) const;

2462 13 read_datagram 0 4 3543 25 LVecBase3i::read_datagram 0 1 566 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase3i::read_datagram(DatagramIterator &source);

2463 14 get_class_type 0 4 3543 26 LVecBase3i::get_class_type 0 1 567 0
51
static TypeHandle LVecBase3i::get_class_type(void);

2464 11 ~LVecBase3i 0 4 3543 23 LVecBase3i::~LVecBase3i 0 0 0
30
LVecBase3i::~LVecBase3i(void);

2465 29 get_default_coordinate_system 0 1 0 29 get_default_coordinate_system 0 1 1880 0
53
CoordinateSystem get_default_coordinate_system(void);

2466 30 parse_coordinate_system_string 0 1 0 30 parse_coordinate_system_string 0 1 1881 0
72
CoordinateSystem parse_coordinate_system_string(std::string const &str);

2467 24 format_coordinate_system 0 1 0 24 format_coordinate_system 0 1 1882 0
58
std::string format_coordinate_system(CoordinateSystem cs);

2468 15 is_right_handed 0 1 0 15 is_right_handed 0 1 1883 0
57
bool is_right_handed(CoordinateSystem cs = ::CS_default);

2469 9 LVector3f 0 4 3546 20 LVector3f::LVector3f 0 6 568 569 570 571 572 573 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
320
inline LVector3f::LVector3f(void) = default;
inline LVector3f::LVector3f(LVecBase3f const &copy);
inline LVector3f::LVector3f(float fill_value);
inline LVector3f::LVector3f(float x, float y, float z);
inline LVector3f::LVector3f(LVecBase2f const &copy, float z);
inline LVector3f::LVector3f(LVector3f const &) = default;

2470 11 __getattr__ 0 4 3546 22 LVector3f::__getattr__ 0 1 574 0
92
inline PyObject *LVector3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2471 11 __setattr__ 0 4 3546 22 LVector3f::__setattr__ 0 1 575 0
98
inline int LVector3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2472 4 zero 0 4 3546 15 LVector3f::zero 0 1 576 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3f const &LVector3f::zero(void);

2473 6 unit_x 0 4 3546 17 LVector3f::unit_x 0 1 577 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3f const &LVector3f::unit_x(void);

2474 6 unit_y 0 4 3546 17 LVector3f::unit_y 0 1 578 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3f const &LVector3f::unit_y(void);

2475 6 unit_z 0 4 3546 17 LVector3f::unit_z 0 1 579 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3f const &LVector3f::unit_z(void);

2476 6 get_xy 0 4 3546 17 LVector3f::get_xy 0 1 580 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_xy(void) const;

2477 6 get_xz 0 4 3546 17 LVector3f::get_xz 0 1 581 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2f LVector3f::get_xz(void) const;

2478 6 get_yz 0 4 3546 17 LVector3f::get_yz 0 1 582 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2f LVector3f::get_yz(void) const;

2479 10 operator - 0 68 3546 21 LVector3f::operator - 0 1 583 0
51
inline LVector3f LVector3f::operator -(void) const;

2480 10 operator + 0 4 3546 21 LVector3f::operator + 0 2 584 585 0
141
inline LVecBase3f LVector3f::operator +(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator +(LVector3f const &other) const;

2481 10 operator - 0 4 3546 21 LVector3f::operator - 0 2 586 587 0
141
inline LVecBase3f LVector3f::operator -(LVecBase3f const &other) const;
inline LVector3f LVector3f::operator -(LVector3f const &other) const;

2482 5 cross 0 4 3546 16 LVector3f::cross 0 1 588 10
/**
 *
 */
65
inline LVector3f LVector3f::cross(LVecBase3f const &other) const;

2483 10 normalized 0 4 3546 21 LVector3f::normalized 0 1 589 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3f LVector3f::normalized(void) const;

2484 7 project 0 4 3546 18 LVector3f::project 0 1 590 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3f LVector3f::project(LVecBase3f const &onto) const;

2485 9 angle_rad 0 4 3546 20 LVector3f::angle_rad 0 1 591 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_rad(LVector3f const &other) const;

2486 9 angle_deg 0 4 3546 20 LVector3f::angle_deg 0 1 592 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
64
inline float LVector3f::angle_deg(LVector3f const &other) const;

2487 16 signed_angle_rad 0 4 3546 27 LVector3f::signed_angle_rad 0 1 593 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_rad(LVector3f const &other, LVector3f const &ref) const;

2488 16 signed_angle_deg 0 4 3546 27 LVector3f::signed_angle_deg 0 1 594 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
93
inline float LVector3f::signed_angle_deg(LVector3f const &other, LVector3f const &ref) const;

2489 18 relative_angle_rad 0 4 3546 29 LVector3f::relative_angle_rad 0 1 595 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_rad(LVector3f const &other) const;

2490 18 relative_angle_deg 0 4 3546 29 LVector3f::relative_angle_deg 0 1 596 50
/**
 * This method is deprecated.  Do not use.
 */
73
inline float LVector3f::relative_angle_deg(LVector3f const &other) const;

2491 10 operator * 0 4 3546 21 LVector3f::operator * 0 1 597 0
59
inline LVector3f LVector3f::operator *(float scalar) const;

2492 10 operator / 0 4 3546 21 LVector3f::operator / 0 1 598 0
59
inline LVector3f LVector3f::operator /(float scalar) const;

2493 2 up 0 4 3546 13 LVector3f::up 0 1 599 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3f LVector3f::up(CoordinateSystem cs = ::CS_default);

2494 5 right 0 4 3546 16 LVector3f::right 0 1 600 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3f LVector3f::right(CoordinateSystem cs = ::CS_default);

2495 7 forward 0 4 3546 18 LVector3f::forward 0 1 601 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3f LVector3f::forward(CoordinateSystem cs = ::CS_default);

2496 4 down 0 4 3546 15 LVector3f::down 0 1 602 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::down(CoordinateSystem cs = ::CS_default);

2497 4 left 0 4 3546 15 LVector3f::left 0 1 603 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::left(CoordinateSystem cs = ::CS_default);

2498 4 back 0 4 3546 15 LVector3f::back 0 1 604 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3f LVector3f::back(CoordinateSystem cs = ::CS_default);

2499 3 rfu 0 4 3546 14 LVector3f::rfu 0 1 605 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
109
static inline LVector3f LVector3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2500 8 __repr__ 0 4 3546 19 LVector3f::__repr__ 0 1 606 0
51
inline std::string LVector3f::__repr__(void) const;

2501 14 get_class_type 0 4 3546 25 LVector3f::get_class_type 0 1 607 0
50
static TypeHandle LVector3f::get_class_type(void);

2502 10 ~LVector3f 0 4 3546 21 LVector3f::~LVector3f 0 0 0
28
LVector3f::~LVector3f(void);

2503 9 LVector3d 0 4 3547 20 LVector3d::LVector3d 0 6 608 609 610 611 612 613 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
325
inline LVector3d::LVector3d(void) = default;
inline LVector3d::LVector3d(LVecBase3d const &copy);
inline LVector3d::LVector3d(double fill_value);
inline LVector3d::LVector3d(double x, double y, double z);
inline LVector3d::LVector3d(LVecBase2d const &copy, double z);
inline LVector3d::LVector3d(LVector3d const &) = default;

2504 11 __getattr__ 0 4 3547 22 LVector3d::__getattr__ 0 1 614 0
92
inline PyObject *LVector3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2505 11 __setattr__ 0 4 3547 22 LVector3d::__setattr__ 0 1 615 0
98
inline int LVector3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2506 4 zero 0 4 3547 15 LVector3d::zero 0 1 616 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3d const &LVector3d::zero(void);

2507 6 unit_x 0 4 3547 17 LVector3d::unit_x 0 1 617 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3d const &LVector3d::unit_x(void);

2508 6 unit_y 0 4 3547 17 LVector3d::unit_y 0 1 618 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3d const &LVector3d::unit_y(void);

2509 6 unit_z 0 4 3547 17 LVector3d::unit_z 0 1 619 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3d const &LVector3d::unit_z(void);

2510 6 get_xy 0 4 3547 17 LVector3d::get_xy 0 1 620 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_xy(void) const;

2511 6 get_xz 0 4 3547 17 LVector3d::get_xz 0 1 621 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2d LVector3d::get_xz(void) const;

2512 6 get_yz 0 4 3547 17 LVector3d::get_yz 0 1 622 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2d LVector3d::get_yz(void) const;

2513 10 operator - 0 68 3547 21 LVector3d::operator - 0 1 623 0
51
inline LVector3d LVector3d::operator -(void) const;

2514 10 operator + 0 4 3547 21 LVector3d::operator + 0 2 624 625 0
141
inline LVecBase3d LVector3d::operator +(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator +(LVector3d const &other) const;

2515 10 operator - 0 4 3547 21 LVector3d::operator - 0 2 626 627 0
141
inline LVecBase3d LVector3d::operator -(LVecBase3d const &other) const;
inline LVector3d LVector3d::operator -(LVector3d const &other) const;

2516 5 cross 0 4 3547 16 LVector3d::cross 0 1 628 10
/**
 *
 */
65
inline LVector3d LVector3d::cross(LVecBase3d const &other) const;

2517 10 normalized 0 4 3547 21 LVector3d::normalized 0 1 629 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector3d LVector3d::normalized(void) const;

2518 7 project 0 4 3547 18 LVector3d::project 0 1 630 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector3d LVector3d::project(LVecBase3d const &onto) const;

2519 9 angle_rad 0 4 3547 20 LVector3d::angle_rad 0 1 631 147
/**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_rad(LVector3d const &other) const;

2520 9 angle_deg 0 4 3547 20 LVector3d::angle_deg 0 1 632 138
/**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */
65
inline double LVector3d::angle_deg(LVector3d const &other) const;

2521 16 signed_angle_rad 0 4 3547 27 LVector3d::signed_angle_rad 0 1 633 259
/**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_rad(LVector3d const &other, LVector3d const &ref) const;

2522 16 signed_angle_deg 0 4 3547 27 LVector3d::signed_angle_deg 0 1 634 259
/**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */
94
inline double LVector3d::signed_angle_deg(LVector3d const &other, LVector3d const &ref) const;

2523 18 relative_angle_rad 0 4 3547 29 LVector3d::relative_angle_rad 0 1 635 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_rad(LVector3d const &other) const;

2524 18 relative_angle_deg 0 4 3547 29 LVector3d::relative_angle_deg 0 1 636 50
/**
 * This method is deprecated.  Do not use.
 */
74
inline double LVector3d::relative_angle_deg(LVector3d const &other) const;

2525 10 operator * 0 4 3547 21 LVector3d::operator * 0 1 637 0
60
inline LVector3d LVector3d::operator *(double scalar) const;

2526 10 operator / 0 4 3547 21 LVector3d::operator / 0 1 638 0
60
inline LVector3d LVector3d::operator /(double scalar) const;

2527 2 up 0 4 3547 13 LVector3d::up 0 1 639 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3d LVector3d::up(CoordinateSystem cs = ::CS_default);

2528 5 right 0 4 3547 16 LVector3d::right 0 1 640 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3d LVector3d::right(CoordinateSystem cs = ::CS_default);

2529 7 forward 0 4 3547 18 LVector3d::forward 0 1 641 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3d LVector3d::forward(CoordinateSystem cs = ::CS_default);

2530 4 down 0 4 3547 15 LVector3d::down 0 1 642 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::down(CoordinateSystem cs = ::CS_default);

2531 4 left 0 4 3547 15 LVector3d::left 0 1 643 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::left(CoordinateSystem cs = ::CS_default);

2532 4 back 0 4 3547 15 LVector3d::back 0 1 644 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3d LVector3d::back(CoordinateSystem cs = ::CS_default);

2533 3 rfu 0 4 3547 14 LVector3d::rfu 0 1 645 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
112
static inline LVector3d LVector3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2534 8 __repr__ 0 4 3547 19 LVector3d::__repr__ 0 1 646 0
51
inline std::string LVector3d::__repr__(void) const;

2535 14 get_class_type 0 4 3547 25 LVector3d::get_class_type 0 1 647 0
50
static TypeHandle LVector3d::get_class_type(void);

2536 10 ~LVector3d 0 4 3547 21 LVector3d::~LVector3d 0 0 0
28
LVector3d::~LVector3d(void);

2537 9 LVector3i 0 4 3548 20 LVector3i::LVector3i 0 6 648 649 650 651 652 653 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LVector3i::LVector3i(void) = default;
inline LVector3i::LVector3i(LVecBase3i const &copy);
inline LVector3i::LVector3i(int fill_value);
inline LVector3i::LVector3i(int x, int y, int z);
inline LVector3i::LVector3i(LVecBase2i const &copy, int z);
inline LVector3i::LVector3i(LVector3i const &) = default;

2538 11 __getattr__ 0 4 3548 22 LVector3i::__getattr__ 0 1 654 0
92
inline PyObject *LVector3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2539 11 __setattr__ 0 4 3548 22 LVector3i::__setattr__ 0 1 655 0
98
inline int LVector3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2540 4 zero 0 4 3548 15 LVector3i::zero 0 1 656 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector3i const &LVector3i::zero(void);

2541 6 unit_x 0 4 3548 17 LVector3i::unit_x 0 1 657 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector3i const &LVector3i::unit_x(void);

2542 6 unit_y 0 4 3548 17 LVector3i::unit_y 0 1 658 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector3i const &LVector3i::unit_y(void);

2543 6 unit_z 0 4 3548 17 LVector3i::unit_z 0 1 659 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector3i const &LVector3i::unit_z(void);

2544 6 get_xy 0 4 3548 17 LVector3i::get_xy 0 1 660 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_xy(void) const;

2545 6 get_xz 0 4 3548 17 LVector3i::get_xz 0 1 661 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
47
inline LVector2i LVector3i::get_xz(void) const;

2546 6 get_yz 0 4 3548 17 LVector3i::get_yz 0 1 662 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
47
inline LVector2i LVector3i::get_yz(void) const;

2547 10 operator - 0 68 3548 21 LVector3i::operator - 0 1 663 0
51
inline LVector3i LVector3i::operator -(void) const;

2548 10 operator + 0 4 3548 21 LVector3i::operator + 0 2 664 665 0
141
inline LVecBase3i LVector3i::operator +(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator +(LVector3i const &other) const;

2549 10 operator - 0 4 3548 21 LVector3i::operator - 0 2 666 667 0
141
inline LVecBase3i LVector3i::operator -(LVecBase3i const &other) const;
inline LVector3i LVector3i::operator -(LVector3i const &other) const;

2550 5 cross 0 4 3548 16 LVector3i::cross 0 1 668 10
/**
 *
 */
65
inline LVector3i LVector3i::cross(LVecBase3i const &other) const;

2551 10 operator * 0 4 3548 21 LVector3i::operator * 0 1 669 0
57
inline LVector3i LVector3i::operator *(int scalar) const;

2552 10 operator / 0 4 3548 21 LVector3i::operator / 0 1 670 0
57
inline LVector3i LVector3i::operator /(int scalar) const;

2553 2 up 0 4 3548 13 LVector3i::up 0 1 671 65
/**
 * Returns the up vector for the given coordinate system.
 */
74
static inline LVector3i LVector3i::up(CoordinateSystem cs = ::CS_default);

2554 5 right 0 4 3548 16 LVector3i::right 0 1 672 68
/**
 * Returns the right vector for the given coordinate system.
 */
77
static inline LVector3i LVector3i::right(CoordinateSystem cs = ::CS_default);

2555 7 forward 0 4 3548 18 LVector3i::forward 0 1 673 70
/**
 * Returns the forward vector for the given coordinate system.
 */
79
static inline LVector3i LVector3i::forward(CoordinateSystem cs = ::CS_default);

2556 4 down 0 4 3548 15 LVector3i::down 0 1 674 67
/**
 * Returns the down vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::down(CoordinateSystem cs = ::CS_default);

2557 4 left 0 4 3548 15 LVector3i::left 0 1 675 67
/**
 * Returns the left vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::left(CoordinateSystem cs = ::CS_default);

2558 4 back 0 4 3548 15 LVector3i::back 0 1 676 67
/**
 * Returns the back vector for the given coordinate system.
 */
76
static inline LVector3i LVector3i::back(CoordinateSystem cs = ::CS_default);

2559 3 rfu 0 4 3548 14 LVector3i::rfu 0 1 677 221
// INLINE_LINMATH static FLOATNAME(LVector3) & rfu(FLOATTYPE right,

/**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */
103
static inline LVector3i LVector3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2560 8 __repr__ 0 4 3548 19 LVector3i::__repr__ 0 1 678 0
51
inline std::string LVector3i::__repr__(void) const;

2561 14 get_class_type 0 4 3548 25 LVector3i::get_class_type 0 1 679 0
50
static TypeHandle LVector3i::get_class_type(void);

2562 10 ~LVector3i 0 4 3548 21 LVector3i::~LVector3i 0 0 0
28
LVector3i::~LVector3i(void);

2563 8 LPoint3f 0 4 3549 18 LPoint3f::LPoint3f 0 6 680 681 682 683 684 685 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
307
inline LPoint3f::LPoint3f(void) = default;
inline LPoint3f::LPoint3f(LVecBase3f const &copy);
inline LPoint3f::LPoint3f(float fill_value);
inline LPoint3f::LPoint3f(float x, float y, float z);
inline LPoint3f::LPoint3f(LVecBase2f const &copy, float z);
inline LPoint3f::LPoint3f(LPoint3f const &) = default;

2564 11 __getattr__ 0 4 3549 21 LPoint3f::__getattr__ 0 1 686 0
91
inline PyObject *LPoint3f::__getattr__(PyObject *self, std::string const &attr_name) const;

2565 11 __setattr__ 0 4 3549 21 LPoint3f::__setattr__ 0 1 687 0
97
inline int LPoint3f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2566 4 zero 0 4 3549 14 LPoint3f::zero 0 1 688 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3f const &LPoint3f::zero(void);

2567 6 unit_x 0 4 3549 16 LPoint3f::unit_x 0 1 689 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3f const &LPoint3f::unit_x(void);

2568 6 unit_y 0 4 3549 16 LPoint3f::unit_y 0 1 690 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3f const &LPoint3f::unit_y(void);

2569 6 unit_z 0 4 3549 16 LPoint3f::unit_z 0 1 691 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3f const &LPoint3f::unit_z(void);

2570 6 get_xy 0 4 3549 16 LPoint3f::get_xy 0 1 692 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_xy(void) const;

2571 6 get_xz 0 4 3549 16 LPoint3f::get_xz 0 1 693 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2f LPoint3f::get_xz(void) const;

2572 6 get_yz 0 4 3549 16 LPoint3f::get_yz 0 1 694 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2f LPoint3f::get_yz(void) const;

2573 10 operator - 0 68 3549 20 LPoint3f::operator - 0 1 695 0
49
inline LPoint3f LPoint3f::operator -(void) const;

2574 10 operator + 0 4 3549 20 LPoint3f::operator + 0 2 696 697 0
138
inline LVecBase3f LPoint3f::operator +(LVecBase3f const &other) const;
inline LPoint3f LPoint3f::operator +(LVector3f const &other) const;

2575 10 operator - 0 4 3549 20 LPoint3f::operator - 0 3 698 699 700 0
206
inline LVecBase3f LPoint3f::operator -(LVecBase3f const &other) const;
inline LVector3f LPoint3f::operator -(LPoint3f const &other) const;
inline LPoint3f LPoint3f::operator -(LVector3f const &other) const;

2576 5 cross 0 4 3549 15 LPoint3f::cross 0 1 701 10
/**
 *
 */
63
inline LPoint3f LPoint3f::cross(LVecBase3f const &other) const;

2577 10 normalized 0 4 3549 20 LPoint3f::normalized 0 1 702 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3f LPoint3f::normalized(void) const;

2578 7 project 0 4 3549 17 LPoint3f::project 0 1 703 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3f LPoint3f::project(LVecBase3f const &onto) const;

2579 10 operator * 0 4 3549 20 LPoint3f::operator * 0 1 704 0
57
inline LPoint3f LPoint3f::operator *(float scalar) const;

2580 10 operator / 0 4 3549 20 LPoint3f::operator / 0 1 705 0
57
inline LPoint3f LPoint3f::operator /(float scalar) const;

2581 6 origin 0 4 3549 16 LPoint3f::origin 0 1 706 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3f const &LPoint3f::origin(CoordinateSystem cs = ::CS_default);

2582 3 rfu 0 4 3549 13 LPoint3f::rfu 0 1 707 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
107
static inline LPoint3f LPoint3f::rfu(float right, float fwd, float up, CoordinateSystem cs = ::CS_default);

2583 8 __repr__ 0 4 3549 18 LPoint3f::__repr__ 0 1 708 0
50
inline std::string LPoint3f::__repr__(void) const;

2584 14 get_class_type 0 4 3549 24 LPoint3f::get_class_type 0 1 709 0
49
static TypeHandle LPoint3f::get_class_type(void);

2585 9 ~LPoint3f 0 4 3549 19 LPoint3f::~LPoint3f 0 0 0
26
LPoint3f::~LPoint3f(void);

2586 8 LPoint3d 0 4 3550 18 LPoint3d::LPoint3d 0 6 710 711 712 713 714 715 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
312
inline LPoint3d::LPoint3d(void) = default;
inline LPoint3d::LPoint3d(LVecBase3d const &copy);
inline LPoint3d::LPoint3d(double fill_value);
inline LPoint3d::LPoint3d(double x, double y, double z);
inline LPoint3d::LPoint3d(LVecBase2d const &copy, double z);
inline LPoint3d::LPoint3d(LPoint3d const &) = default;

2587 11 __getattr__ 0 4 3550 21 LPoint3d::__getattr__ 0 1 716 0
91
inline PyObject *LPoint3d::__getattr__(PyObject *self, std::string const &attr_name) const;

2588 11 __setattr__ 0 4 3550 21 LPoint3d::__setattr__ 0 1 717 0
97
inline int LPoint3d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2589 4 zero 0 4 3550 14 LPoint3d::zero 0 1 718 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3d const &LPoint3d::zero(void);

2590 6 unit_x 0 4 3550 16 LPoint3d::unit_x 0 1 719 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3d const &LPoint3d::unit_x(void);

2591 6 unit_y 0 4 3550 16 LPoint3d::unit_y 0 1 720 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3d const &LPoint3d::unit_y(void);

2592 6 unit_z 0 4 3550 16 LPoint3d::unit_z 0 1 721 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3d const &LPoint3d::unit_z(void);

2593 6 get_xy 0 4 3550 16 LPoint3d::get_xy 0 1 722 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_xy(void) const;

2594 6 get_xz 0 4 3550 16 LPoint3d::get_xz 0 1 723 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2d LPoint3d::get_xz(void) const;

2595 6 get_yz 0 4 3550 16 LPoint3d::get_yz 0 1 724 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2d LPoint3d::get_yz(void) const;

2596 10 operator - 0 68 3550 20 LPoint3d::operator - 0 1 725 0
49
inline LPoint3d LPoint3d::operator -(void) const;

2597 10 operator + 0 4 3550 20 LPoint3d::operator + 0 2 726 727 0
138
inline LVecBase3d LPoint3d::operator +(LVecBase3d const &other) const;
inline LPoint3d LPoint3d::operator +(LVector3d const &other) const;

2598 10 operator - 0 4 3550 20 LPoint3d::operator - 0 3 728 729 730 0
206
inline LVecBase3d LPoint3d::operator -(LVecBase3d const &other) const;
inline LVector3d LPoint3d::operator -(LPoint3d const &other) const;
inline LPoint3d LPoint3d::operator -(LVector3d const &other) const;

2599 5 cross 0 4 3550 15 LPoint3d::cross 0 1 731 10
/**
 *
 */
63
inline LPoint3d LPoint3d::cross(LVecBase3d const &other) const;

2600 10 normalized 0 4 3550 20 LPoint3d::normalized 0 1 732 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint3d LPoint3d::normalized(void) const;

2601 7 project 0 4 3550 17 LPoint3d::project 0 1 733 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint3d LPoint3d::project(LVecBase3d const &onto) const;

2602 10 operator * 0 4 3550 20 LPoint3d::operator * 0 1 734 0
58
inline LPoint3d LPoint3d::operator *(double scalar) const;

2603 10 operator / 0 4 3550 20 LPoint3d::operator / 0 1 735 0
58
inline LPoint3d LPoint3d::operator /(double scalar) const;

2604 6 origin 0 4 3550 16 LPoint3d::origin 0 1 736 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3d const &LPoint3d::origin(CoordinateSystem cs = ::CS_default);

2605 3 rfu 0 4 3550 13 LPoint3d::rfu 0 1 737 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
110
static inline LPoint3d LPoint3d::rfu(double right, double fwd, double up, CoordinateSystem cs = ::CS_default);

2606 8 __repr__ 0 4 3550 18 LPoint3d::__repr__ 0 1 738 0
50
inline std::string LPoint3d::__repr__(void) const;

2607 14 get_class_type 0 4 3550 24 LPoint3d::get_class_type 0 1 739 0
49
static TypeHandle LPoint3d::get_class_type(void);

2608 9 ~LPoint3d 0 4 3550 19 LPoint3d::~LPoint3d 0 0 0
26
LPoint3d::~LPoint3d(void);

2609 8 LPoint3i 0 4 3551 18 LPoint3i::LPoint3i 0 6 740 741 742 743 744 745 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
297
inline LPoint3i::LPoint3i(void) = default;
inline LPoint3i::LPoint3i(LVecBase3i const &copy);
inline LPoint3i::LPoint3i(int fill_value);
inline LPoint3i::LPoint3i(int x, int y, int z);
inline LPoint3i::LPoint3i(LVecBase2i const &copy, int z);
inline LPoint3i::LPoint3i(LPoint3i const &) = default;

2610 11 __getattr__ 0 4 3551 21 LPoint3i::__getattr__ 0 1 746 0
91
inline PyObject *LPoint3i::__getattr__(PyObject *self, std::string const &attr_name) const;

2611 11 __setattr__ 0 4 3551 21 LPoint3i::__setattr__ 0 1 747 0
97
inline int LPoint3i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2612 4 zero 0 4 3551 14 LPoint3i::zero 0 1 748 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint3i const &LPoint3i::zero(void);

2613 6 unit_x 0 4 3551 16 LPoint3i::unit_x 0 1 749 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint3i const &LPoint3i::unit_x(void);

2614 6 unit_y 0 4 3551 16 LPoint3i::unit_y 0 1 750 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint3i const &LPoint3i::unit_y(void);

2615 6 unit_z 0 4 3551 16 LPoint3i::unit_z 0 1 751 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint3i const &LPoint3i::unit_z(void);

2616 6 get_xy 0 4 3551 16 LPoint3i::get_xy 0 1 752 100
/**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_xy(void) const;

2617 6 get_xz 0 4 3551 16 LPoint3i::get_xz 0 1 753 105
/**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */
45
inline LPoint2i LPoint3i::get_xz(void) const;

2618 6 get_yz 0 4 3551 16 LPoint3i::get_yz 0 1 754 99
/**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */
45
inline LPoint2i LPoint3i::get_yz(void) const;

2619 10 operator - 0 68 3551 20 LPoint3i::operator - 0 1 755 0
49
inline LPoint3i LPoint3i::operator -(void) const;

2620 10 operator + 0 4 3551 20 LPoint3i::operator + 0 2 756 757 0
138
inline LVecBase3i LPoint3i::operator +(LVecBase3i const &other) const;
inline LPoint3i LPoint3i::operator +(LVector3i const &other) const;

2621 10 operator - 0 4 3551 20 LPoint3i::operator - 0 3 758 759 760 0
206
inline LVecBase3i LPoint3i::operator -(LVecBase3i const &other) const;
inline LVector3i LPoint3i::operator -(LPoint3i const &other) const;
inline LPoint3i LPoint3i::operator -(LVector3i const &other) const;

2622 5 cross 0 4 3551 15 LPoint3i::cross 0 1 761 10
/**
 *
 */
63
inline LPoint3i LPoint3i::cross(LVecBase3i const &other) const;

2623 10 operator * 0 4 3551 20 LPoint3i::operator * 0 1 762 0
55
inline LPoint3i LPoint3i::operator *(int scalar) const;

2624 10 operator / 0 4 3551 20 LPoint3i::operator / 0 1 763 0
55
inline LPoint3i LPoint3i::operator /(int scalar) const;

2625 6 origin 0 4 3551 16 LPoint3i::origin 0 1 764 186
/**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */
83
static inline LPoint3i const &LPoint3i::origin(CoordinateSystem cs = ::CS_default);

2626 3 rfu 0 4 3551 13 LPoint3i::rfu 0 1 765 146
/**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */
101
static inline LPoint3i LPoint3i::rfu(int right, int fwd, int up, CoordinateSystem cs = ::CS_default);

2627 8 __repr__ 0 4 3551 18 LPoint3i::__repr__ 0 1 766 0
50
inline std::string LPoint3i::__repr__(void) const;

2628 14 get_class_type 0 4 3551 24 LPoint3i::get_class_type 0 1 767 0
49
static TypeHandle LPoint3i::get_class_type(void);

2629 9 ~LPoint3i 0 4 3551 19 LPoint3i::~LPoint3i 0 0 0
26
LPoint3i::~LPoint3i(void);

2630 10 LVecBase4f 0 4 3552 22 LVecBase4f::LVecBase4f 0 8 768 769 770 771 772 773 774 775 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
461
inline LVecBase4f::LVecBase4f(void) = default;
inline LVecBase4f::LVecBase4f(float fill_value);
inline LVecBase4f::LVecBase4f(float x, float y, float z, float w);
inline LVecBase4f::LVecBase4f(UnalignedLVecBase4f const &copy);
inline LVecBase4f::LVecBase4f(LVecBase3f const &copy, float w);
inline LVecBase4f::LVecBase4f(LPoint3f const &point);
inline LVecBase4f::LVecBase4f(LVector3f const &vector);
inline LVecBase4f::LVecBase4f(LVecBase4f const &) = default;

2631 12 operator new 0 4 3552 24 LVecBase4f::operator new 0 1 776 0
124
inline void *LVecBase4f::operator new(std::size_t size);
inline void *LVecBase4f::operator new(std::size_t size, void *ptr);

2632 15 operator delete 0 4 3552 27 LVecBase4f::operator delete 0 0 0
108
inline void LVecBase4f::operator delete(void *ptr);
inline void LVecBase4f::operator delete(void *, void *);

2633 12 validate_ptr 0 4 3552 24 LVecBase4f::validate_ptr 0 0 0
61
static inline bool LVecBase4f::validate_ptr(void const *ptr);

2634 10 operator = 0 4 3552 22 LVecBase4f::operator = 0 2 777 778 0
119
void LVecBase4f::operator =(LVecBase4f const &copy) = default;
void LVecBase4f::operator =(float fill_value) = default;

2635 4 zero 0 4 3552 16 LVecBase4f::zero 0 1 779 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4f const &LVecBase4f::zero(void);

2636 6 unit_x 0 4 3552 18 LVecBase4f::unit_x 0 1 780 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_x(void);

2637 6 unit_y 0 4 3552 18 LVecBase4f::unit_y 0 1 781 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_y(void);

2638 6 unit_z 0 4 3552 18 LVecBase4f::unit_z 0 1 782 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_z(void);

2639 6 unit_w 0 4 3552 18 LVecBase4f::unit_w 0 1 783 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4f const &LVecBase4f::unit_w(void);

2640 10 __reduce__ 0 4 3552 22 LVecBase4f::__reduce__ 0 1 784 0
62
inline PyObject *LVecBase4f::__reduce__(PyObject *self) const;

2641 11 __getattr__ 0 4 3552 23 LVecBase4f::__getattr__ 0 1 785 0
93
inline PyObject *LVecBase4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2642 11 __setattr__ 0 4 3552 23 LVecBase4f::__setattr__ 0 1 786 0
99
inline int LVecBase4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2643 11 operator [] 0 4 3552 23 LVecBase4f::operator [] 0 2 787 788 10
/**
 *
 */
96
inline float LVecBase4f::operator [](int i) const;
inline float &LVecBase4f::operator [](int i);

2644 4 size 0 4 3552 16 LVecBase4f::size 0 1 789 0
44
static constexpr int LVecBase4f::size(void);

2645 6 is_nan 0 4 3552 18 LVecBase4f::is_nan 0 1 790 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4f::is_nan(void) const;

2646 8 get_cell 0 4 3552 20 LVecBase4f::get_cell 0 1 791 10
/**
 *
 */
47
inline float LVecBase4f::get_cell(int i) const;

2647 8 set_cell 0 4 3552 20 LVecBase4f::set_cell 0 1 792 10
/**
 *
 */
53
inline void LVecBase4f::set_cell(int i, float value);

2648 5 get_x 0 4 3552 17 LVecBase4f::get_x 0 1 793 10
/**
 *
 */
43
inline float LVecBase4f::get_x(void) const;

2649 5 get_y 0 4 3552 17 LVecBase4f::get_y 0 1 794 10
/**
 *
 */
43
inline float LVecBase4f::get_y(void) const;

2650 5 get_z 0 4 3552 17 LVecBase4f::get_z 0 1 795 10
/**
 *
 */
43
inline float LVecBase4f::get_z(void) const;

2651 5 get_w 0 4 3552 17 LVecBase4f::get_w 0 1 796 10
/**
 *
 */
43
inline float LVecBase4f::get_w(void) const;

2652 7 get_xyz 0 4 3552 19 LVecBase4f::get_xyz 0 1 797 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3f LVecBase4f::get_xyz(void) const;

2653 6 get_xy 0 4 3552 18 LVecBase4f::get_xy 0 1 798 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2f LVecBase4f::get_xy(void) const;

2654 5 set_x 0 4 3552 17 LVecBase4f::set_x 0 1 799 10
/**
 *
 */
43
inline void LVecBase4f::set_x(float value);

2655 5 set_y 0 4 3552 17 LVecBase4f::set_y 0 1 800 10
/**
 *
 */
43
inline void LVecBase4f::set_y(float value);

2656 5 set_z 0 4 3552 17 LVecBase4f::set_z 0 1 801 10
/**
 *
 */
43
inline void LVecBase4f::set_z(float value);

2657 5 set_w 0 4 3552 17 LVecBase4f::set_w 0 1 802 10
/**
 *
 */
43
inline void LVecBase4f::set_w(float value);

2658 11 add_to_cell 0 4 3552 23 LVecBase4f::add_to_cell 0 1 803 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
56
inline void LVecBase4f::add_to_cell(int i, float value);

2659 5 add_x 0 4 3552 17 LVecBase4f::add_x 0 1 804 10
/**
 *
 */
43
inline void LVecBase4f::add_x(float value);

2660 5 add_y 0 4 3552 17 LVecBase4f::add_y 0 1 805 10
/**
 *
 */
43
inline void LVecBase4f::add_y(float value);

2661 5 add_z 0 4 3552 17 LVecBase4f::add_z 0 1 806 10
/**
 *
 */
43
inline void LVecBase4f::add_z(float value);

2662 5 add_w 0 4 3552 17 LVecBase4f::add_w 0 1 807 10
/**
 *
 */
43
inline void LVecBase4f::add_w(float value);

2663 8 get_data 0 4 3552 20 LVecBase4f::get_data 0 1 808 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
53
inline float const *LVecBase4f::get_data(void) const;

2664 18 get_num_components 0 4 3552 30 LVecBase4f::get_num_components 0 1 809 0
58
static constexpr int LVecBase4f::get_num_components(void);

2665 12 extract_data 0 4 3552 24 LVecBase4f::extract_data 0 0 0
46
inline void LVecBase4f::extract_data(float *);

2666 4 fill 0 4 3552 16 LVecBase4f::fill 0 1 810 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
47
inline void LVecBase4f::fill(float fill_value);

2667 3 set 0 4 3552 15 LVecBase4f::set 0 1 811 10
/**
 *
 */
64
inline void LVecBase4f::set(float x, float y, float z, float w);

2668 3 dot 0 4 3552 15 LVecBase4f::dot 0 1 812 10
/**
 *
 */
60
inline float LVecBase4f::dot(LVecBase4f const &other) const;

2669 14 length_squared 0 4 3552 26 LVecBase4f::length_squared 0 1 813 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
52
inline float LVecBase4f::length_squared(void) const;

2670 6 length 0 4 3552 18 LVecBase4f::length 0 1 814 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
44
inline float LVecBase4f::length(void) const;

2671 9 normalize 0 4 3552 21 LVecBase4f::normalize 0 1 815 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4f::normalize(void);

2672 10 normalized 0 4 3552 22 LVecBase4f::normalized 0 1 816 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4f LVecBase4f::normalized(void) const;

2673 7 project 0 4 3552 19 LVecBase4f::project 0 1 817 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4f LVecBase4f::project(LVecBase4f const &onto) const;

2674 10 operator < 0 4 3552 22 LVecBase4f::operator < 0 1 818 0
66
inline bool LVecBase4f::operator <(LVecBase4f const &other) const;

2675 11 operator == 0 4 3552 23 LVecBase4f::operator == 0 1 819 0
67
inline bool LVecBase4f::operator ==(LVecBase4f const &other) const;

2676 11 operator != 0 4 3552 23 LVecBase4f::operator != 0 1 820 0
67
inline bool LVecBase4f::operator !=(LVecBase4f const &other) const;

2677 10 compare_to 0 4 3552 22 LVecBase4f::compare_to 0 2 821 822 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
148
inline int LVecBase4f::compare_to(LVecBase4f const &other) const;
inline int LVecBase4f::compare_to(LVecBase4f const &other, float threshold) const;

2678 8 get_hash 0 4 3552 20 LVecBase4f::get_hash 0 2 823 824 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
116
inline std::size_t LVecBase4f::get_hash(void) const;
inline std::size_t LVecBase4f::get_hash(float threshold) const;

2679 8 add_hash 0 4 3552 20 LVecBase4f::add_hash 0 2 825 826 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
146
inline std::size_t LVecBase4f::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4f::add_hash(std::size_t hash, float threshold) const;

2680 13 generate_hash 0 4 3552 25 LVecBase4f::generate_hash 0 2 827 828 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
170
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

2681 10 operator - 0 68 3552 22 LVecBase4f::operator - 0 1 829 0
53
inline LVecBase4f LVecBase4f::operator -(void) const;

2682 10 operator + 0 4 3552 22 LVecBase4f::operator + 0 1 830 0
72
inline LVecBase4f LVecBase4f::operator +(LVecBase4f const &other) const;

2683 10 operator - 0 4 3552 22 LVecBase4f::operator - 0 1 831 0
72
inline LVecBase4f LVecBase4f::operator -(LVecBase4f const &other) const;

2684 10 operator * 0 4 3552 22 LVecBase4f::operator * 0 1 832 0
61
inline LVecBase4f LVecBase4f::operator *(float scalar) const;

2685 10 operator / 0 4 3552 22 LVecBase4f::operator / 0 1 833 0
61
inline LVecBase4f LVecBase4f::operator /(float scalar) const;

2686 11 operator += 0 4 3552 23 LVecBase4f::operator += 0 1 834 0
61
inline void LVecBase4f::operator +=(LVecBase4f const &other);

2687 11 operator -= 0 4 3552 23 LVecBase4f::operator -= 0 1 835 0
61
inline void LVecBase4f::operator -=(LVecBase4f const &other);

2688 11 operator *= 0 4 3552 23 LVecBase4f::operator *= 0 1 836 0
50
inline void LVecBase4f::operator *=(float scalar);

2689 11 operator /= 0 4 3552 23 LVecBase4f::operator /= 0 1 837 0
50
inline void LVecBase4f::operator /=(float scalar);

2690 18 componentwise_mult 0 4 3552 30 LVecBase4f::componentwise_mult 0 1 838 10
/**
 *
 */
68
inline void LVecBase4f::componentwise_mult(LVecBase4f const &other);

2691 7 __pow__ 0 4 3552 19 LVecBase4f::__pow__ 0 1 839 0
60
inline LVecBase4f LVecBase4f::__pow__(float exponent) const;

2692 8 __ipow__ 0 4 3552 20 LVecBase4f::__ipow__ 0 1 840 0
70
inline PyObject *LVecBase4f::__ipow__(PyObject *self, float exponent);

2693 4 fmax 0 4 3552 16 LVecBase4f::fmax 0 1 841 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmax(LVecBase4f const &other) const;

2694 4 fmin 0 4 3552 16 LVecBase4f::fmin 0 1 842 10
/**
 *
 */
66
inline LVecBase4f LVecBase4f::fmin(LVecBase4f const &other) const;

2695 12 almost_equal 0 4 3552 24 LVecBase4f::almost_equal 0 2 843 844 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
154
inline bool LVecBase4f::almost_equal(LVecBase4f const &other, float threshold) const;
inline bool LVecBase4f::almost_equal(LVecBase4f const &other) const;

2696 6 output 0 4 3552 18 LVecBase4f::output 0 1 845 10
/**
 *
 */
56
inline void LVecBase4f::output(std::ostream &out) const;

2697 8 __repr__ 0 4 3552 20 LVecBase4f::__repr__ 0 1 846 0
52
inline std::string LVecBase4f::__repr__(void) const;

2698 20 write_datagram_fixed 0 4 3552 32 LVecBase4f::write_datagram_fixed 0 1 847 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4f::write_datagram_fixed(Datagram &destination) const;

2699 19 read_datagram_fixed 0 4 3552 31 LVecBase4f::read_datagram_fixed 0 1 848 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4f::read_datagram_fixed(DatagramIterator &source);

2700 14 write_datagram 0 4 3552 26 LVecBase4f::write_datagram 0 1 849 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4f::write_datagram(Datagram &destination) const;

2701 13 read_datagram 0 4 3552 25 LVecBase4f::read_datagram 0 1 850 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4f::read_datagram(DatagramIterator &source);

2702 14 get_class_type 0 4 3552 26 LVecBase4f::get_class_type 0 1 851 0
51
static TypeHandle LVecBase4f::get_class_type(void);

2703 11 ~LVecBase4f 0 4 3552 23 LVecBase4f::~LVecBase4f 0 0 0
30
LVecBase4f::~LVecBase4f(void);

2704 19 UnalignedLVecBase4f 0 4 3554 40 UnalignedLVecBase4f::UnalignedLVecBase4f 0 5 852 853 854 855 856 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
377
inline UnalignedLVecBase4f::UnalignedLVecBase4f(void) = default;
inline UnalignedLVecBase4f::UnalignedLVecBase4f(LVecBase4f const &copy);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float fill_value);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(float x, float y, float z, float w);
inline UnalignedLVecBase4f::UnalignedLVecBase4f(UnalignedLVecBase4f const &) = default;

2705 4 fill 0 4 3554 25 UnalignedLVecBase4f::fill 0 1 857 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
56
inline void UnalignedLVecBase4f::fill(float fill_value);

2706 3 set 0 4 3554 24 UnalignedLVecBase4f::set 0 1 858 10
/**
 *
 */
73
inline void UnalignedLVecBase4f::set(float x, float y, float z, float w);

2707 11 operator [] 0 4 3554 32 UnalignedLVecBase4f::operator [] 0 2 859 860 10
/**
 *
 */
114
inline float UnalignedLVecBase4f::operator [](int i) const;
inline float &UnalignedLVecBase4f::operator [](int i);

2708 4 size 0 4 3554 25 UnalignedLVecBase4f::size 0 1 861 0
53
static constexpr int UnalignedLVecBase4f::size(void);

2709 8 get_data 0 4 3554 29 UnalignedLVecBase4f::get_data 0 1 862 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
62
inline float const *UnalignedLVecBase4f::get_data(void) const;

2710 18 get_num_components 0 4 3554 39 UnalignedLVecBase4f::get_num_components 0 1 863 0
67
static constexpr int UnalignedLVecBase4f::get_num_components(void);

2711 11 operator == 0 4 3554 32 UnalignedLVecBase4f::operator == 0 1 864 0
85
inline bool UnalignedLVecBase4f::operator ==(UnalignedLVecBase4f const &other) const;

2712 11 operator != 0 4 3554 32 UnalignedLVecBase4f::operator != 0 1 865 0
85
inline bool UnalignedLVecBase4f::operator !=(UnalignedLVecBase4f const &other) const;

2713 14 get_class_type 0 4 3554 35 UnalignedLVecBase4f::get_class_type 0 1 866 0
60
static TypeHandle UnalignedLVecBase4f::get_class_type(void);

2714 20 ~UnalignedLVecBase4f 0 4 3554 41 UnalignedLVecBase4f::~UnalignedLVecBase4f 0 0 0
48
UnalignedLVecBase4f::~UnalignedLVecBase4f(void);

2715 10 LVecBase4d 0 4 3556 22 LVecBase4d::LVecBase4d 0 8 867 868 869 870 871 872 873 874 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
467
inline LVecBase4d::LVecBase4d(void) = default;
inline LVecBase4d::LVecBase4d(double fill_value);
inline LVecBase4d::LVecBase4d(double x, double y, double z, double w);
inline LVecBase4d::LVecBase4d(UnalignedLVecBase4d const &copy);
inline LVecBase4d::LVecBase4d(LVecBase3d const &copy, double w);
inline LVecBase4d::LVecBase4d(LPoint3d const &point);
inline LVecBase4d::LVecBase4d(LVector3d const &vector);
inline LVecBase4d::LVecBase4d(LVecBase4d const &) = default;

2716 12 operator new 0 4 3556 24 LVecBase4d::operator new 0 1 875 0
124
inline void *LVecBase4d::operator new(std::size_t size);
inline void *LVecBase4d::operator new(std::size_t size, void *ptr);

2717 15 operator delete 0 4 3556 27 LVecBase4d::operator delete 0 0 0
108
inline void LVecBase4d::operator delete(void *ptr);
inline void LVecBase4d::operator delete(void *, void *);

2718 12 validate_ptr 0 4 3556 24 LVecBase4d::validate_ptr 0 0 0
61
static inline bool LVecBase4d::validate_ptr(void const *ptr);

2719 10 operator = 0 4 3556 22 LVecBase4d::operator = 0 2 876 877 0
120
void LVecBase4d::operator =(LVecBase4d const &copy) = default;
void LVecBase4d::operator =(double fill_value) = default;

2720 4 zero 0 4 3556 16 LVecBase4d::zero 0 1 878 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4d const &LVecBase4d::zero(void);

2721 6 unit_x 0 4 3556 18 LVecBase4d::unit_x 0 1 879 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_x(void);

2722 6 unit_y 0 4 3556 18 LVecBase4d::unit_y 0 1 880 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_y(void);

2723 6 unit_z 0 4 3556 18 LVecBase4d::unit_z 0 1 881 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_z(void);

2724 6 unit_w 0 4 3556 18 LVecBase4d::unit_w 0 1 882 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4d const &LVecBase4d::unit_w(void);

2725 10 __reduce__ 0 4 3556 22 LVecBase4d::__reduce__ 0 1 883 0
62
inline PyObject *LVecBase4d::__reduce__(PyObject *self) const;

2726 11 __getattr__ 0 4 3556 23 LVecBase4d::__getattr__ 0 1 884 0
93
inline PyObject *LVecBase4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2727 11 __setattr__ 0 4 3556 23 LVecBase4d::__setattr__ 0 1 885 0
99
inline int LVecBase4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2728 11 operator [] 0 4 3556 23 LVecBase4d::operator [] 0 2 886 887 10
/**
 *
 */
98
inline double LVecBase4d::operator [](int i) const;
inline double &LVecBase4d::operator [](int i);

2729 4 size 0 4 3556 16 LVecBase4d::size 0 1 888 0
44
static constexpr int LVecBase4d::size(void);

2730 6 is_nan 0 4 3556 18 LVecBase4d::is_nan 0 1 889 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4d::is_nan(void) const;

2731 8 get_cell 0 4 3556 20 LVecBase4d::get_cell 0 1 890 10
/**
 *
 */
48
inline double LVecBase4d::get_cell(int i) const;

2732 8 set_cell 0 4 3556 20 LVecBase4d::set_cell 0 1 891 10
/**
 *
 */
54
inline void LVecBase4d::set_cell(int i, double value);

2733 5 get_x 0 4 3556 17 LVecBase4d::get_x 0 1 892 10
/**
 *
 */
44
inline double LVecBase4d::get_x(void) const;

2734 5 get_y 0 4 3556 17 LVecBase4d::get_y 0 1 893 10
/**
 *
 */
44
inline double LVecBase4d::get_y(void) const;

2735 5 get_z 0 4 3556 17 LVecBase4d::get_z 0 1 894 10
/**
 *
 */
44
inline double LVecBase4d::get_z(void) const;

2736 5 get_w 0 4 3556 17 LVecBase4d::get_w 0 1 895 10
/**
 *
 */
44
inline double LVecBase4d::get_w(void) const;

2737 7 get_xyz 0 4 3556 19 LVecBase4d::get_xyz 0 1 896 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3d LVecBase4d::get_xyz(void) const;

2738 6 get_xy 0 4 3556 18 LVecBase4d::get_xy 0 1 897 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2d LVecBase4d::get_xy(void) const;

2739 5 set_x 0 4 3556 17 LVecBase4d::set_x 0 1 898 10
/**
 *
 */
44
inline void LVecBase4d::set_x(double value);

2740 5 set_y 0 4 3556 17 LVecBase4d::set_y 0 1 899 10
/**
 *
 */
44
inline void LVecBase4d::set_y(double value);

2741 5 set_z 0 4 3556 17 LVecBase4d::set_z 0 1 900 10
/**
 *
 */
44
inline void LVecBase4d::set_z(double value);

2742 5 set_w 0 4 3556 17 LVecBase4d::set_w 0 1 901 10
/**
 *
 */
44
inline void LVecBase4d::set_w(double value);

2743 11 add_to_cell 0 4 3556 23 LVecBase4d::add_to_cell 0 1 902 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
57
inline void LVecBase4d::add_to_cell(int i, double value);

2744 5 add_x 0 4 3556 17 LVecBase4d::add_x 0 1 903 10
/**
 *
 */
44
inline void LVecBase4d::add_x(double value);

2745 5 add_y 0 4 3556 17 LVecBase4d::add_y 0 1 904 10
/**
 *
 */
44
inline void LVecBase4d::add_y(double value);

2746 5 add_z 0 4 3556 17 LVecBase4d::add_z 0 1 905 10
/**
 *
 */
44
inline void LVecBase4d::add_z(double value);

2747 5 add_w 0 4 3556 17 LVecBase4d::add_w 0 1 906 10
/**
 *
 */
44
inline void LVecBase4d::add_w(double value);

2748 8 get_data 0 4 3556 20 LVecBase4d::get_data 0 1 907 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
54
inline double const *LVecBase4d::get_data(void) const;

2749 18 get_num_components 0 4 3556 30 LVecBase4d::get_num_components 0 1 908 0
58
static constexpr int LVecBase4d::get_num_components(void);

2750 12 extract_data 0 4 3556 24 LVecBase4d::extract_data 0 0 0
46
inline void LVecBase4d::extract_data(float *);

2751 4 fill 0 4 3556 16 LVecBase4d::fill 0 1 909 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
48
inline void LVecBase4d::fill(double fill_value);

2752 3 set 0 4 3556 15 LVecBase4d::set 0 1 910 10
/**
 *
 */
68
inline void LVecBase4d::set(double x, double y, double z, double w);

2753 3 dot 0 4 3556 15 LVecBase4d::dot 0 1 911 10
/**
 *
 */
61
inline double LVecBase4d::dot(LVecBase4d const &other) const;

2754 14 length_squared 0 4 3556 26 LVecBase4d::length_squared 0 1 912 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
53
inline double LVecBase4d::length_squared(void) const;

2755 6 length 0 4 3556 18 LVecBase4d::length 0 1 913 72
/**
 * Returns the length of the vector, by the Pythagorean theorem.
 */
45
inline double LVecBase4d::length(void) const;

2756 9 normalize 0 4 3556 21 LVecBase4d::normalize 0 1 914 127
/**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */
40
inline bool LVecBase4d::normalize(void);

2757 10 normalized 0 4 3556 22 LVecBase4d::normalized 0 1 915 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
53
inline LVecBase4d LVecBase4d::normalized(void) const;

2758 7 project 0 4 3556 19 LVecBase4d::project 0 1 916 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
68
inline LVecBase4d LVecBase4d::project(LVecBase4d const &onto) const;

2759 10 operator < 0 4 3556 22 LVecBase4d::operator < 0 1 917 0
66
inline bool LVecBase4d::operator <(LVecBase4d const &other) const;

2760 11 operator == 0 4 3556 23 LVecBase4d::operator == 0 1 918 0
67
inline bool LVecBase4d::operator ==(LVecBase4d const &other) const;

2761 11 operator != 0 4 3556 23 LVecBase4d::operator != 0 1 919 0
67
inline bool LVecBase4d::operator !=(LVecBase4d const &other) const;

2762 10 compare_to 0 4 3556 22 LVecBase4d::compare_to 0 2 920 921 332
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */
149
inline int LVecBase4d::compare_to(LVecBase4d const &other) const;
inline int LVecBase4d::compare_to(LVecBase4d const &other, double threshold) const;

2763 8 get_hash 0 4 3556 20 LVecBase4d::get_hash 0 2 922 923 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
117
inline std::size_t LVecBase4d::get_hash(void) const;
inline std::size_t LVecBase4d::get_hash(double threshold) const;

2764 8 add_hash 0 4 3556 20 LVecBase4d::add_hash 0 2 924 925 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
147
inline std::size_t LVecBase4d::add_hash(std::size_t hash) const;
inline std::size_t LVecBase4d::add_hash(std::size_t hash, double threshold) const;

2765 13 generate_hash 0 4 3556 25 LVecBase4d::generate_hash 0 2 926 927 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
171
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen) const;
inline void LVecBase4d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

2766 10 operator - 0 68 3556 22 LVecBase4d::operator - 0 1 928 0
53
inline LVecBase4d LVecBase4d::operator -(void) const;

2767 10 operator + 0 4 3556 22 LVecBase4d::operator + 0 1 929 0
72
inline LVecBase4d LVecBase4d::operator +(LVecBase4d const &other) const;

2768 10 operator - 0 4 3556 22 LVecBase4d::operator - 0 1 930 0
72
inline LVecBase4d LVecBase4d::operator -(LVecBase4d const &other) const;

2769 10 operator * 0 4 3556 22 LVecBase4d::operator * 0 1 931 0
62
inline LVecBase4d LVecBase4d::operator *(double scalar) const;

2770 10 operator / 0 4 3556 22 LVecBase4d::operator / 0 1 932 0
62
inline LVecBase4d LVecBase4d::operator /(double scalar) const;

2771 11 operator += 0 4 3556 23 LVecBase4d::operator += 0 1 933 0
61
inline void LVecBase4d::operator +=(LVecBase4d const &other);

2772 11 operator -= 0 4 3556 23 LVecBase4d::operator -= 0 1 934 0
61
inline void LVecBase4d::operator -=(LVecBase4d const &other);

2773 11 operator *= 0 4 3556 23 LVecBase4d::operator *= 0 1 935 0
51
inline void LVecBase4d::operator *=(double scalar);

2774 11 operator /= 0 4 3556 23 LVecBase4d::operator /= 0 1 936 0
51
inline void LVecBase4d::operator /=(double scalar);

2775 18 componentwise_mult 0 4 3556 30 LVecBase4d::componentwise_mult 0 1 937 10
/**
 *
 */
68
inline void LVecBase4d::componentwise_mult(LVecBase4d const &other);

2776 7 __pow__ 0 4 3556 19 LVecBase4d::__pow__ 0 1 938 0
61
inline LVecBase4d LVecBase4d::__pow__(double exponent) const;

2777 8 __ipow__ 0 4 3556 20 LVecBase4d::__ipow__ 0 1 939 0
71
inline PyObject *LVecBase4d::__ipow__(PyObject *self, double exponent);

2778 4 fmax 0 4 3556 16 LVecBase4d::fmax 0 1 940 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmax(LVecBase4d const &other) const;

2779 4 fmin 0 4 3556 16 LVecBase4d::fmin 0 1 941 10
/**
 *
 */
66
inline LVecBase4d LVecBase4d::fmin(LVecBase4d const &other) const;

2780 12 almost_equal 0 4 3556 24 LVecBase4d::almost_equal 0 2 942 943 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
155
inline bool LVecBase4d::almost_equal(LVecBase4d const &other, double threshold) const;
inline bool LVecBase4d::almost_equal(LVecBase4d const &other) const;

2781 6 output 0 4 3556 18 LVecBase4d::output 0 1 944 10
/**
 *
 */
56
inline void LVecBase4d::output(std::ostream &out) const;

2782 8 __repr__ 0 4 3556 20 LVecBase4d::__repr__ 0 1 945 0
52
inline std::string LVecBase4d::__repr__(void) const;

2783 20 write_datagram_fixed 0 4 3556 32 LVecBase4d::write_datagram_fixed 0 1 946 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4d::write_datagram_fixed(Datagram &destination) const;

2784 19 read_datagram_fixed 0 4 3556 31 LVecBase4d::read_datagram_fixed 0 1 947 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4d::read_datagram_fixed(DatagramIterator &source);

2785 14 write_datagram 0 4 3556 26 LVecBase4d::write_datagram 0 1 948 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4d::write_datagram(Datagram &destination) const;

2786 13 read_datagram 0 4 3556 25 LVecBase4d::read_datagram 0 1 949 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4d::read_datagram(DatagramIterator &source);

2787 14 get_class_type 0 4 3556 26 LVecBase4d::get_class_type 0 1 950 0
51
static TypeHandle LVecBase4d::get_class_type(void);

2788 11 ~LVecBase4d 0 4 3556 23 LVecBase4d::~LVecBase4d 0 0 0
30
LVecBase4d::~LVecBase4d(void);

2789 19 UnalignedLVecBase4d 0 4 3558 40 UnalignedLVecBase4d::UnalignedLVecBase4d 0 5 951 952 953 954 955 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
382
inline UnalignedLVecBase4d::UnalignedLVecBase4d(void) = default;
inline UnalignedLVecBase4d::UnalignedLVecBase4d(LVecBase4d const &copy);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double fill_value);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(double x, double y, double z, double w);
inline UnalignedLVecBase4d::UnalignedLVecBase4d(UnalignedLVecBase4d const &) = default;

2790 4 fill 0 4 3558 25 UnalignedLVecBase4d::fill 0 1 956 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
57
inline void UnalignedLVecBase4d::fill(double fill_value);

2791 3 set 0 4 3558 24 UnalignedLVecBase4d::set 0 1 957 10
/**
 *
 */
77
inline void UnalignedLVecBase4d::set(double x, double y, double z, double w);

2792 11 operator [] 0 4 3558 32 UnalignedLVecBase4d::operator [] 0 2 958 959 10
/**
 *
 */
116
inline double UnalignedLVecBase4d::operator [](int i) const;
inline double &UnalignedLVecBase4d::operator [](int i);

2793 4 size 0 4 3558 25 UnalignedLVecBase4d::size 0 1 960 0
53
static constexpr int UnalignedLVecBase4d::size(void);

2794 8 get_data 0 4 3558 29 UnalignedLVecBase4d::get_data 0 1 961 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
63
inline double const *UnalignedLVecBase4d::get_data(void) const;

2795 18 get_num_components 0 4 3558 39 UnalignedLVecBase4d::get_num_components 0 1 962 0
67
static constexpr int UnalignedLVecBase4d::get_num_components(void);

2796 11 operator == 0 4 3558 32 UnalignedLVecBase4d::operator == 0 1 963 0
85
inline bool UnalignedLVecBase4d::operator ==(UnalignedLVecBase4d const &other) const;

2797 11 operator != 0 4 3558 32 UnalignedLVecBase4d::operator != 0 1 964 0
85
inline bool UnalignedLVecBase4d::operator !=(UnalignedLVecBase4d const &other) const;

2798 14 get_class_type 0 4 3558 35 UnalignedLVecBase4d::get_class_type 0 1 965 0
60
static TypeHandle UnalignedLVecBase4d::get_class_type(void);

2799 20 ~UnalignedLVecBase4d 0 4 3558 41 UnalignedLVecBase4d::~UnalignedLVecBase4d 0 0 0
48
UnalignedLVecBase4d::~UnalignedLVecBase4d(void);

2800 10 LVecBase4i 0 4 3560 22 LVecBase4i::LVecBase4i 0 8 966 967 968 969 970 971 972 973 219
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */

/**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */
449
inline LVecBase4i::LVecBase4i(void) = default;
inline LVecBase4i::LVecBase4i(int fill_value);
inline LVecBase4i::LVecBase4i(int x, int y, int z, int w);
inline LVecBase4i::LVecBase4i(UnalignedLVecBase4i const &copy);
inline LVecBase4i::LVecBase4i(LVecBase3i const &copy, int w);
inline LVecBase4i::LVecBase4i(LPoint3i const &point);
inline LVecBase4i::LVecBase4i(LVector3i const &vector);
inline LVecBase4i::LVecBase4i(LVecBase4i const &) = default;

2801 12 operator new 0 4 3560 24 LVecBase4i::operator new 0 1 974 0
124
inline void *LVecBase4i::operator new(std::size_t size);
inline void *LVecBase4i::operator new(std::size_t size, void *ptr);

2802 15 operator delete 0 4 3560 27 LVecBase4i::operator delete 0 0 0
108
inline void LVecBase4i::operator delete(void *ptr);
inline void LVecBase4i::operator delete(void *, void *);

2803 12 validate_ptr 0 4 3560 24 LVecBase4i::validate_ptr 0 0 0
61
static inline bool LVecBase4i::validate_ptr(void const *ptr);

2804 10 operator = 0 4 3560 22 LVecBase4i::operator = 0 2 975 976 0
117
void LVecBase4i::operator =(LVecBase4i const &copy) = default;
void LVecBase4i::operator =(int fill_value) = default;

2805 4 zero 0 4 3560 16 LVecBase4i::zero 0 1 977 40
/**
 * Returns a zero-length vector.
 */
55
static inline LVecBase4i const &LVecBase4i::zero(void);

2806 6 unit_x 0 4 3560 18 LVecBase4i::unit_x 0 1 978 35
/**
 * Returns a unit X vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_x(void);

2807 6 unit_y 0 4 3560 18 LVecBase4i::unit_y 0 1 979 35
/**
 * Returns a unit Y vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_y(void);

2808 6 unit_z 0 4 3560 18 LVecBase4i::unit_z 0 1 980 35
/**
 * Returns a unit Z vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_z(void);

2809 6 unit_w 0 4 3560 18 LVecBase4i::unit_w 0 1 981 35
/**
 * Returns a unit W vector.
 */
57
static inline LVecBase4i const &LVecBase4i::unit_w(void);

2810 10 __reduce__ 0 4 3560 22 LVecBase4i::__reduce__ 0 1 982 0
62
inline PyObject *LVecBase4i::__reduce__(PyObject *self) const;

2811 11 __getattr__ 0 4 3560 23 LVecBase4i::__getattr__ 0 1 983 0
93
inline PyObject *LVecBase4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2812 11 __setattr__ 0 4 3560 23 LVecBase4i::__setattr__ 0 1 984 0
99
inline int LVecBase4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2813 11 operator [] 0 4 3560 23 LVecBase4i::operator [] 0 2 985 986 10
/**
 *
 */
92
inline int LVecBase4i::operator [](int i) const;
inline int &LVecBase4i::operator [](int i);

2814 4 size 0 4 3560 16 LVecBase4i::size 0 1 987 0
44
static constexpr int LVecBase4i::size(void);

2815 6 is_nan 0 4 3560 18 LVecBase4i::is_nan 0 1 988 91
/**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */
43
inline bool LVecBase4i::is_nan(void) const;

2816 8 get_cell 0 4 3560 20 LVecBase4i::get_cell 0 1 989 10
/**
 *
 */
45
inline int LVecBase4i::get_cell(int i) const;

2817 8 set_cell 0 4 3560 20 LVecBase4i::set_cell 0 1 990 10
/**
 *
 */
51
inline void LVecBase4i::set_cell(int i, int value);

2818 5 get_x 0 4 3560 17 LVecBase4i::get_x 0 1 991 10
/**
 *
 */
41
inline int LVecBase4i::get_x(void) const;

2819 5 get_y 0 4 3560 17 LVecBase4i::get_y 0 1 992 10
/**
 *
 */
41
inline int LVecBase4i::get_y(void) const;

2820 5 get_z 0 4 3560 17 LVecBase4i::get_z 0 1 993 10
/**
 *
 */
41
inline int LVecBase4i::get_z(void) const;

2821 5 get_w 0 4 3560 17 LVecBase4i::get_w 0 1 994 10
/**
 *
 */
41
inline int LVecBase4i::get_w(void) const;

2822 7 get_xyz 0 4 3560 19 LVecBase4i::get_xyz 0 1 995 58
/**
 * Returns the x, y and z component of this vector
 */
50
inline LVecBase3i LVecBase4i::get_xyz(void) const;

2823 6 get_xy 0 4 3560 18 LVecBase4i::get_xy 0 1 996 55
/**
 * Returns the x and y component of this vector
 */
49
inline LVecBase2i LVecBase4i::get_xy(void) const;

2824 5 set_x 0 4 3560 17 LVecBase4i::set_x 0 1 997 10
/**
 *
 */
41
inline void LVecBase4i::set_x(int value);

2825 5 set_y 0 4 3560 17 LVecBase4i::set_y 0 1 998 10
/**
 *
 */
41
inline void LVecBase4i::set_y(int value);

2826 5 set_z 0 4 3560 17 LVecBase4i::set_z 0 1 999 10
/**
 *
 */
41
inline void LVecBase4i::set_z(int value);

2827 5 set_w 0 4 3560 17 LVecBase4i::set_w 0 1 1000 10
/**
 *
 */
41
inline void LVecBase4i::set_w(int value);

2828 11 add_to_cell 0 4 3560 23 LVecBase4i::add_to_cell 0 1 1001 164
// These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages:

/**
 *
 */
54
inline void LVecBase4i::add_to_cell(int i, int value);

2829 5 add_x 0 4 3560 17 LVecBase4i::add_x 0 1 1002 10
/**
 *
 */
41
inline void LVecBase4i::add_x(int value);

2830 5 add_y 0 4 3560 17 LVecBase4i::add_y 0 1 1003 10
/**
 *
 */
41
inline void LVecBase4i::add_y(int value);

2831 5 add_z 0 4 3560 17 LVecBase4i::add_z 0 1 1004 10
/**
 *
 */
41
inline void LVecBase4i::add_z(int value);

2832 5 add_w 0 4 3560 17 LVecBase4i::add_w 0 1 1005 10
/**
 *
 */
41
inline void LVecBase4i::add_w(int value);

2833 8 get_data 0 4 3560 20 LVecBase4i::get_data 0 1 1006 161
/**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
51
inline int const *LVecBase4i::get_data(void) const;

2834 18 get_num_components 0 4 3560 30 LVecBase4i::get_num_components 0 1 1007 0
58
static constexpr int LVecBase4i::get_num_components(void);

2835 12 extract_data 0 4 3560 24 LVecBase4i::extract_data 0 0 0
46
inline void LVecBase4i::extract_data(float *);

2836 4 fill 0 4 3560 16 LVecBase4i::fill 0 1 1008 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
45
inline void LVecBase4i::fill(int fill_value);

2837 3 set 0 4 3560 15 LVecBase4i::set 0 1 1009 10
/**
 *
 */
56
inline void LVecBase4i::set(int x, int y, int z, int w);

2838 3 dot 0 4 3560 15 LVecBase4i::dot 0 1 1010 10
/**
 *
 */
58
inline int LVecBase4i::dot(LVecBase4i const &other) const;

2839 14 length_squared 0 4 3560 26 LVecBase4i::length_squared 0 1 1011 69
/**
 * Returns the square of the vector's length, cheap and easy.
 */
50
inline int LVecBase4i::length_squared(void) const;

2840 10 operator < 0 4 3560 22 LVecBase4i::operator < 0 1 1012 0
66
inline bool LVecBase4i::operator <(LVecBase4i const &other) const;

2841 11 operator == 0 4 3560 23 LVecBase4i::operator == 0 1 1013 0
67
inline bool LVecBase4i::operator ==(LVecBase4i const &other) const;

2842 11 operator != 0 4 3560 23 LVecBase4i::operator != 0 1 1014 0
67
inline bool LVecBase4i::operator !=(LVecBase4i const &other) const;

2843 10 compare_to 0 4 3560 22 LVecBase4i::compare_to 0 1 1015 97
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */
65
inline int LVecBase4i::compare_to(LVecBase4i const &other) const;

2844 8 get_hash 0 4 3560 20 LVecBase4i::get_hash 0 1 1016 49
/**
 * Returns a suitable hash for phash_map.
 */
52
inline std::size_t LVecBase4i::get_hash(void) const;

2845 8 add_hash 0 4 3560 20 LVecBase4i::add_hash 0 1 1017 49
/**
 * Adds the vector into the running hash.
 */
64
inline std::size_t LVecBase4i::add_hash(std::size_t hash) const;

2846 13 generate_hash 0 4 3560 25 LVecBase4i::generate_hash 0 1 1018 59
/**
 * Adds the vector to the indicated hash generator.
 */
76
inline void LVecBase4i::generate_hash(ChecksumHashGenerator &hashgen) const;

2847 10 operator - 0 68 3560 22 LVecBase4i::operator - 0 1 1019 0
53
inline LVecBase4i LVecBase4i::operator -(void) const;

2848 10 operator + 0 4 3560 22 LVecBase4i::operator + 0 1 1020 0
72
inline LVecBase4i LVecBase4i::operator +(LVecBase4i const &other) const;

2849 10 operator - 0 4 3560 22 LVecBase4i::operator - 0 1 1021 0
72
inline LVecBase4i LVecBase4i::operator -(LVecBase4i const &other) const;

2850 10 operator * 0 4 3560 22 LVecBase4i::operator * 0 1 1022 0
59
inline LVecBase4i LVecBase4i::operator *(int scalar) const;

2851 10 operator / 0 4 3560 22 LVecBase4i::operator / 0 1 1023 0
59
inline LVecBase4i LVecBase4i::operator /(int scalar) const;

2852 11 operator += 0 4 3560 23 LVecBase4i::operator += 0 1 1024 0
61
inline void LVecBase4i::operator +=(LVecBase4i const &other);

2853 11 operator -= 0 4 3560 23 LVecBase4i::operator -= 0 1 1025 0
61
inline void LVecBase4i::operator -=(LVecBase4i const &other);

2854 11 operator *= 0 4 3560 23 LVecBase4i::operator *= 0 1 1026 0
48
inline void LVecBase4i::operator *=(int scalar);

2855 11 operator /= 0 4 3560 23 LVecBase4i::operator /= 0 1 1027 0
48
inline void LVecBase4i::operator /=(int scalar);

2856 18 componentwise_mult 0 4 3560 30 LVecBase4i::componentwise_mult 0 1 1028 10
/**
 *
 */
68
inline void LVecBase4i::componentwise_mult(LVecBase4i const &other);

2857 7 __pow__ 0 4 3560 19 LVecBase4i::__pow__ 0 1 1029 0
58
inline LVecBase4i LVecBase4i::__pow__(int exponent) const;

2858 8 __ipow__ 0 4 3560 20 LVecBase4i::__ipow__ 0 1 1030 0
68
inline PyObject *LVecBase4i::__ipow__(PyObject *self, int exponent);

2859 4 fmax 0 4 3560 16 LVecBase4i::fmax 0 1 1031 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmax(LVecBase4i const &other) const;

2860 4 fmin 0 4 3560 16 LVecBase4i::fmin 0 1 1032 10
/**
 *
 */
66
inline LVecBase4i LVecBase4i::fmin(LVecBase4i const &other) const;

2861 12 almost_equal 0 4 3560 24 LVecBase4i::almost_equal 0 2 1033 1034 210
/**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */

/**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */
152
inline bool LVecBase4i::almost_equal(LVecBase4i const &other, int threshold) const;
inline bool LVecBase4i::almost_equal(LVecBase4i const &other) const;

2862 6 output 0 4 3560 18 LVecBase4i::output 0 1 1035 10
/**
 *
 */
56
inline void LVecBase4i::output(std::ostream &out) const;

2863 8 __repr__ 0 4 3560 20 LVecBase4i::__repr__ 0 1 1036 0
52
inline std::string LVecBase4i::__repr__(void) const;

2864 20 write_datagram_fixed 0 4 3560 32 LVecBase4i::write_datagram_fixed 0 1 1037 332
/**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
74
inline void LVecBase4i::write_datagram_fixed(Datagram &destination) const;

2865 19 read_datagram_fixed 0 4 3560 31 LVecBase4i::read_datagram_fixed 0 1 1038 114
/**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
70
inline void LVecBase4i::read_datagram_fixed(DatagramIterator &source);

2866 14 write_datagram 0 4 3560 26 LVecBase4i::write_datagram 0 1 1039 205
/**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */
68
inline void LVecBase4i::write_datagram(Datagram &destination) const;

2867 13 read_datagram 0 4 3560 25 LVecBase4i::read_datagram 0 1 1040 67
/**
 * Reads the vector from the Datagram using get_stdfloat().
 */
64
inline void LVecBase4i::read_datagram(DatagramIterator &source);

2868 14 get_class_type 0 4 3560 26 LVecBase4i::get_class_type 0 1 1041 0
51
static TypeHandle LVecBase4i::get_class_type(void);

2869 11 ~LVecBase4i 0 4 3560 23 LVecBase4i::~LVecBase4i 0 0 0
30
LVecBase4i::~LVecBase4i(void);

2870 19 UnalignedLVecBase4i 0 4 3562 40 UnalignedLVecBase4i::UnalignedLVecBase4i 0 5 1042 1043 1044 1045 1046 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
367
inline UnalignedLVecBase4i::UnalignedLVecBase4i(void) = default;
inline UnalignedLVecBase4i::UnalignedLVecBase4i(LVecBase4i const &copy);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int fill_value);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(int x, int y, int z, int w);
inline UnalignedLVecBase4i::UnalignedLVecBase4i(UnalignedLVecBase4i const &) = default;

2871 4 fill 0 4 3562 25 UnalignedLVecBase4i::fill 0 1 1047 129
/**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */
54
inline void UnalignedLVecBase4i::fill(int fill_value);

2872 3 set 0 4 3562 24 UnalignedLVecBase4i::set 0 1 1048 10
/**
 *
 */
65
inline void UnalignedLVecBase4i::set(int x, int y, int z, int w);

2873 11 operator [] 0 4 3562 32 UnalignedLVecBase4i::operator [] 0 2 1049 1050 10
/**
 *
 */
110
inline int UnalignedLVecBase4i::operator [](int i) const;
inline int &UnalignedLVecBase4i::operator [](int i);

2874 4 size 0 4 3562 25 UnalignedLVecBase4i::size 0 1 1051 0
53
static constexpr int UnalignedLVecBase4i::size(void);

2875 8 get_data 0 4 3562 29 UnalignedLVecBase4i::get_data 0 1 1052 162
/**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */
60
inline int const *UnalignedLVecBase4i::get_data(void) const;

2876 18 get_num_components 0 4 3562 39 UnalignedLVecBase4i::get_num_components 0 1 1053 0
67
static constexpr int UnalignedLVecBase4i::get_num_components(void);

2877 11 operator == 0 4 3562 32 UnalignedLVecBase4i::operator == 0 1 1054 0
85
inline bool UnalignedLVecBase4i::operator ==(UnalignedLVecBase4i const &other) const;

2878 11 operator != 0 4 3562 32 UnalignedLVecBase4i::operator != 0 1 1055 0
85
inline bool UnalignedLVecBase4i::operator !=(UnalignedLVecBase4i const &other) const;

2879 14 get_class_type 0 4 3562 35 UnalignedLVecBase4i::get_class_type 0 1 1056 0
60
static TypeHandle UnalignedLVecBase4i::get_class_type(void);

2880 20 ~UnalignedLVecBase4i 0 4 3562 41 UnalignedLVecBase4i::~UnalignedLVecBase4i 0 0 0
48
UnalignedLVecBase4i::~UnalignedLVecBase4i(void);

2881 9 LVector4f 0 4 3564 20 LVector4f::LVector4f 0 6 1057 1058 1059 1060 1061 1062 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
329
inline LVector4f::LVector4f(void) = default;
inline LVector4f::LVector4f(LVecBase4f const &copy);
inline LVector4f::LVector4f(float fill_value);
inline LVector4f::LVector4f(float x, float y, float z, float w);
inline LVector4f::LVector4f(LVecBase3f const &copy, float w);
inline LVector4f::LVector4f(LVector4f const &) = default;

2882 11 __getattr__ 0 4 3564 22 LVector4f::__getattr__ 0 1 1063 0
92
inline PyObject *LVector4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2883 11 __setattr__ 0 4 3564 22 LVector4f::__setattr__ 0 1 1064 0
98
inline int LVector4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2884 4 zero 0 4 3564 15 LVector4f::zero 0 1 1065 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4f const &LVector4f::zero(void);

2885 6 unit_x 0 4 3564 17 LVector4f::unit_x 0 1 1066 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4f const &LVector4f::unit_x(void);

2886 6 unit_y 0 4 3564 17 LVector4f::unit_y 0 1 1067 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4f const &LVector4f::unit_y(void);

2887 6 unit_z 0 4 3564 17 LVector4f::unit_z 0 1 1068 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4f const &LVector4f::unit_z(void);

2888 6 unit_w 0 4 3564 17 LVector4f::unit_w 0 1 1069 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4f const &LVector4f::unit_w(void);

2889 7 get_xyz 0 4 3564 18 LVector4f::get_xyz 0 1 1070 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3f LVector4f::get_xyz(void) const;

2890 6 get_xy 0 4 3564 17 LVector4f::get_xy 0 1 1071 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2f LVector4f::get_xy(void) const;

2891 10 operator - 0 68 3564 21 LVector4f::operator - 0 1 1072 0
51
inline LVector4f LVector4f::operator -(void) const;

2892 10 operator + 0 4 3564 21 LVector4f::operator + 0 2 1073 1074 0
141
inline LVecBase4f LVector4f::operator +(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator +(LVector4f const &other) const;

2893 10 operator - 0 4 3564 21 LVector4f::operator - 0 2 1075 1076 0
141
inline LVecBase4f LVector4f::operator -(LVecBase4f const &other) const;
inline LVector4f LVector4f::operator -(LVector4f const &other) const;

2894 10 operator * 0 4 3564 21 LVector4f::operator * 0 1 1077 0
59
inline LVector4f LVector4f::operator *(float scalar) const;

2895 10 operator / 0 4 3564 21 LVector4f::operator / 0 1 1078 0
59
inline LVector4f LVector4f::operator /(float scalar) const;

2896 10 normalized 0 4 3564 21 LVector4f::normalized 0 1 1079 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4f LVector4f::normalized(void) const;

2897 7 project 0 4 3564 18 LVector4f::project 0 1 1080 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4f LVector4f::project(LVecBase4f const &onto) const;

2898 8 __repr__ 0 4 3564 19 LVector4f::__repr__ 0 1 1081 0
51
inline std::string LVector4f::__repr__(void) const;

2899 14 get_class_type 0 4 3564 25 LVector4f::get_class_type 0 1 1082 0
50
static TypeHandle LVector4f::get_class_type(void);

2900 10 ~LVector4f 0 4 3564 21 LVector4f::~LVector4f 0 0 0
28
LVector4f::~LVector4f(void);

2901 9 LVector4d 0 4 3565 20 LVector4d::LVector4d 0 6 1083 1084 1085 1086 1087 1088 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
335
inline LVector4d::LVector4d(void) = default;
inline LVector4d::LVector4d(LVecBase4d const &copy);
inline LVector4d::LVector4d(double fill_value);
inline LVector4d::LVector4d(double x, double y, double z, double w);
inline LVector4d::LVector4d(LVecBase3d const &copy, double w);
inline LVector4d::LVector4d(LVector4d const &) = default;

2902 11 __getattr__ 0 4 3565 22 LVector4d::__getattr__ 0 1 1089 0
92
inline PyObject *LVector4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2903 11 __setattr__ 0 4 3565 22 LVector4d::__setattr__ 0 1 1090 0
98
inline int LVector4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2904 4 zero 0 4 3565 15 LVector4d::zero 0 1 1091 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4d const &LVector4d::zero(void);

2905 6 unit_x 0 4 3565 17 LVector4d::unit_x 0 1 1092 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4d const &LVector4d::unit_x(void);

2906 6 unit_y 0 4 3565 17 LVector4d::unit_y 0 1 1093 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4d const &LVector4d::unit_y(void);

2907 6 unit_z 0 4 3565 17 LVector4d::unit_z 0 1 1094 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4d const &LVector4d::unit_z(void);

2908 6 unit_w 0 4 3565 17 LVector4d::unit_w 0 1 1095 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4d const &LVector4d::unit_w(void);

2909 7 get_xyz 0 4 3565 18 LVector4d::get_xyz 0 1 1096 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3d LVector4d::get_xyz(void) const;

2910 6 get_xy 0 4 3565 17 LVector4d::get_xy 0 1 1097 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2d LVector4d::get_xy(void) const;

2911 10 operator - 0 68 3565 21 LVector4d::operator - 0 1 1098 0
51
inline LVector4d LVector4d::operator -(void) const;

2912 10 operator + 0 4 3565 21 LVector4d::operator + 0 2 1099 1100 0
141
inline LVecBase4d LVector4d::operator +(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator +(LVector4d const &other) const;

2913 10 operator - 0 4 3565 21 LVector4d::operator - 0 2 1101 1102 0
141
inline LVecBase4d LVector4d::operator -(LVecBase4d const &other) const;
inline LVector4d LVector4d::operator -(LVector4d const &other) const;

2914 10 operator * 0 4 3565 21 LVector4d::operator * 0 1 1103 0
60
inline LVector4d LVector4d::operator *(double scalar) const;

2915 10 operator / 0 4 3565 21 LVector4d::operator / 0 1 1104 0
60
inline LVector4d LVector4d::operator /(double scalar) const;

2916 10 normalized 0 4 3565 21 LVector4d::normalized 0 1 1105 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
51
inline LVector4d LVector4d::normalized(void) const;

2917 7 project 0 4 3565 18 LVector4d::project 0 1 1106 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
66
inline LVector4d LVector4d::project(LVecBase4d const &onto) const;

2918 8 __repr__ 0 4 3565 19 LVector4d::__repr__ 0 1 1107 0
51
inline std::string LVector4d::__repr__(void) const;

2919 14 get_class_type 0 4 3565 25 LVector4d::get_class_type 0 1 1108 0
50
static TypeHandle LVector4d::get_class_type(void);

2920 10 ~LVector4d 0 4 3565 21 LVector4d::~LVector4d 0 0 0
28
LVector4d::~LVector4d(void);

2921 9 LVector4i 0 4 3566 20 LVector4i::LVector4i 0 6 1109 1110 1111 1112 1113 1114 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
317
inline LVector4i::LVector4i(void) = default;
inline LVector4i::LVector4i(LVecBase4i const &copy);
inline LVector4i::LVector4i(int fill_value);
inline LVector4i::LVector4i(int x, int y, int z, int w);
inline LVector4i::LVector4i(LVecBase3i const &copy, int w);
inline LVector4i::LVector4i(LVector4i const &) = default;

2922 11 __getattr__ 0 4 3566 22 LVector4i::__getattr__ 0 1 1115 0
92
inline PyObject *LVector4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2923 11 __setattr__ 0 4 3566 22 LVector4i::__setattr__ 0 1 1116 0
98
inline int LVector4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2924 4 zero 0 4 3566 15 LVector4i::zero 0 1 1117 40
/**
 * Returns a zero-length vector.
 */
53
static inline LVector4i const &LVector4i::zero(void);

2925 6 unit_x 0 4 3566 17 LVector4i::unit_x 0 1 1118 35
/**
 * Returns a unit X vector.
 */
55
static inline LVector4i const &LVector4i::unit_x(void);

2926 6 unit_y 0 4 3566 17 LVector4i::unit_y 0 1 1119 35
/**
 * Returns a unit Y vector.
 */
55
static inline LVector4i const &LVector4i::unit_y(void);

2927 6 unit_z 0 4 3566 17 LVector4i::unit_z 0 1 1120 35
/**
 * Returns a unit Z vector.
 */
55
static inline LVector4i const &LVector4i::unit_z(void);

2928 6 unit_w 0 4 3566 17 LVector4i::unit_w 0 1 1121 35
/**
 * Returns a unit W vector.
 */
55
static inline LVector4i const &LVector4i::unit_w(void);

2929 7 get_xyz 0 4 3566 18 LVector4i::get_xyz 0 1 1122 58
/**
 * Returns the x, y and z component of this vector
 */
48
inline LVector3i LVector4i::get_xyz(void) const;

2930 6 get_xy 0 4 3566 17 LVector4i::get_xy 0 1 1123 55
/**
 * Returns the x and y component of this vector
 */
47
inline LVector2i LVector4i::get_xy(void) const;

2931 10 operator - 0 68 3566 21 LVector4i::operator - 0 1 1124 0
51
inline LVector4i LVector4i::operator -(void) const;

2932 10 operator + 0 4 3566 21 LVector4i::operator + 0 2 1125 1126 0
141
inline LVecBase4i LVector4i::operator +(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator +(LVector4i const &other) const;

2933 10 operator - 0 4 3566 21 LVector4i::operator - 0 2 1127 1128 0
141
inline LVecBase4i LVector4i::operator -(LVecBase4i const &other) const;
inline LVector4i LVector4i::operator -(LVector4i const &other) const;

2934 10 operator * 0 4 3566 21 LVector4i::operator * 0 1 1129 0
57
inline LVector4i LVector4i::operator *(int scalar) const;

2935 10 operator / 0 4 3566 21 LVector4i::operator / 0 1 1130 0
57
inline LVector4i LVector4i::operator /(int scalar) const;

2936 8 __repr__ 0 4 3566 19 LVector4i::__repr__ 0 1 1131 0
51
inline std::string LVector4i::__repr__(void) const;

2937 14 get_class_type 0 4 3566 25 LVector4i::get_class_type 0 1 1132 0
50
static TypeHandle LVector4i::get_class_type(void);

2938 10 ~LVector4i 0 4 3566 21 LVector4i::~LVector4i 0 0 0
28
LVector4i::~LVector4i(void);

2939 8 LPoint4f 0 4 3567 18 LPoint4f::LPoint4f 0 6 1133 1134 1135 1136 1137 1138 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
316
inline LPoint4f::LPoint4f(void) = default;
inline LPoint4f::LPoint4f(LVecBase4f const &copy);
inline LPoint4f::LPoint4f(float fill_value);
inline LPoint4f::LPoint4f(float x, float y, float z, float w);
inline LPoint4f::LPoint4f(LVecBase3f const &copy, float w);
inline LPoint4f::LPoint4f(LPoint4f const &) = default;

2940 11 __getattr__ 0 4 3567 21 LPoint4f::__getattr__ 0 1 1139 0
91
inline PyObject *LPoint4f::__getattr__(PyObject *self, std::string const &attr_name) const;

2941 11 __setattr__ 0 4 3567 21 LPoint4f::__setattr__ 0 1 1140 0
97
inline int LPoint4f::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2942 4 zero 0 4 3567 14 LPoint4f::zero 0 1 1141 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4f const &LPoint4f::zero(void);

2943 6 unit_x 0 4 3567 16 LPoint4f::unit_x 0 1 1142 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4f const &LPoint4f::unit_x(void);

2944 6 unit_y 0 4 3567 16 LPoint4f::unit_y 0 1 1143 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4f const &LPoint4f::unit_y(void);

2945 6 unit_z 0 4 3567 16 LPoint4f::unit_z 0 1 1144 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4f const &LPoint4f::unit_z(void);

2946 6 unit_w 0 4 3567 16 LPoint4f::unit_w 0 1 1145 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4f const &LPoint4f::unit_w(void);

2947 7 get_xyz 0 4 3567 17 LPoint4f::get_xyz 0 1 1146 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3f LPoint4f::get_xyz(void) const;

2948 6 get_xy 0 4 3567 16 LPoint4f::get_xy 0 1 1147 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2f LPoint4f::get_xy(void) const;

2949 10 operator - 0 68 3567 20 LPoint4f::operator - 0 1 1148 0
49
inline LPoint4f LPoint4f::operator -(void) const;

2950 10 operator + 0 4 3567 20 LPoint4f::operator + 0 2 1149 1150 0
138
inline LVecBase4f LPoint4f::operator +(LVecBase4f const &other) const;
inline LPoint4f LPoint4f::operator +(LVector4f const &other) const;

2951 10 operator - 0 4 3567 20 LPoint4f::operator - 0 3 1151 1152 1153 0
206
inline LVecBase4f LPoint4f::operator -(LVecBase4f const &other) const;
inline LVector4f LPoint4f::operator -(LPoint4f const &other) const;
inline LPoint4f LPoint4f::operator -(LVector4f const &other) const;

2952 10 operator * 0 4 3567 20 LPoint4f::operator * 0 1 1154 0
57
inline LPoint4f LPoint4f::operator *(float scalar) const;

2953 10 operator / 0 4 3567 20 LPoint4f::operator / 0 1 1155 0
57
inline LPoint4f LPoint4f::operator /(float scalar) const;

2954 10 normalized 0 4 3567 20 LPoint4f::normalized 0 1 1156 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4f LPoint4f::normalized(void) const;

2955 7 project 0 4 3567 17 LPoint4f::project 0 1 1157 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4f LPoint4f::project(LVecBase4f const &onto) const;

2956 8 __repr__ 0 4 3567 18 LPoint4f::__repr__ 0 1 1158 0
50
inline std::string LPoint4f::__repr__(void) const;

2957 14 get_class_type 0 4 3567 24 LPoint4f::get_class_type 0 1 1159 0
49
static TypeHandle LPoint4f::get_class_type(void);

2958 9 ~LPoint4f 0 4 3567 19 LPoint4f::~LPoint4f 0 0 0
26
LPoint4f::~LPoint4f(void);

2959 8 LPoint4d 0 4 3568 18 LPoint4d::LPoint4d 0 6 1160 1161 1162 1163 1164 1165 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
322
inline LPoint4d::LPoint4d(void) = default;
inline LPoint4d::LPoint4d(LVecBase4d const &copy);
inline LPoint4d::LPoint4d(double fill_value);
inline LPoint4d::LPoint4d(double x, double y, double z, double w);
inline LPoint4d::LPoint4d(LVecBase3d const &copy, double w);
inline LPoint4d::LPoint4d(LPoint4d const &) = default;

2960 11 __getattr__ 0 4 3568 21 LPoint4d::__getattr__ 0 1 1166 0
91
inline PyObject *LPoint4d::__getattr__(PyObject *self, std::string const &attr_name) const;

2961 11 __setattr__ 0 4 3568 21 LPoint4d::__setattr__ 0 1 1167 0
97
inline int LPoint4d::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2962 4 zero 0 4 3568 14 LPoint4d::zero 0 1 1168 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4d const &LPoint4d::zero(void);

2963 6 unit_x 0 4 3568 16 LPoint4d::unit_x 0 1 1169 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4d const &LPoint4d::unit_x(void);

2964 6 unit_y 0 4 3568 16 LPoint4d::unit_y 0 1 1170 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4d const &LPoint4d::unit_y(void);

2965 6 unit_z 0 4 3568 16 LPoint4d::unit_z 0 1 1171 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4d const &LPoint4d::unit_z(void);

2966 6 unit_w 0 4 3568 16 LPoint4d::unit_w 0 1 1172 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4d const &LPoint4d::unit_w(void);

2967 7 get_xyz 0 4 3568 17 LPoint4d::get_xyz 0 1 1173 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3d LPoint4d::get_xyz(void) const;

2968 6 get_xy 0 4 3568 16 LPoint4d::get_xy 0 1 1174 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2d LPoint4d::get_xy(void) const;

2969 10 operator - 0 68 3568 20 LPoint4d::operator - 0 1 1175 0
49
inline LPoint4d LPoint4d::operator -(void) const;

2970 10 operator + 0 4 3568 20 LPoint4d::operator + 0 2 1176 1177 0
138
inline LVecBase4d LPoint4d::operator +(LVecBase4d const &other) const;
inline LPoint4d LPoint4d::operator +(LVector4d const &other) const;

2971 10 operator - 0 4 3568 20 LPoint4d::operator - 0 3 1178 1179 1180 0
206
inline LVecBase4d LPoint4d::operator -(LVecBase4d const &other) const;
inline LVector4d LPoint4d::operator -(LPoint4d const &other) const;
inline LPoint4d LPoint4d::operator -(LVector4d const &other) const;

2972 10 operator * 0 4 3568 20 LPoint4d::operator * 0 1 1181 0
58
inline LPoint4d LPoint4d::operator *(double scalar) const;

2973 10 operator / 0 4 3568 20 LPoint4d::operator / 0 1 1182 0
58
inline LPoint4d LPoint4d::operator /(double scalar) const;

2974 10 normalized 0 4 3568 20 LPoint4d::normalized 0 1 1183 160
/**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */
49
inline LPoint4d LPoint4d::normalized(void) const;

2975 7 project 0 4 3568 17 LPoint4d::project 0 1 1184 152
/**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */
64
inline LPoint4d LPoint4d::project(LVecBase4d const &onto) const;

2976 8 __repr__ 0 4 3568 18 LPoint4d::__repr__ 0 1 1185 0
50
inline std::string LPoint4d::__repr__(void) const;

2977 14 get_class_type 0 4 3568 24 LPoint4d::get_class_type 0 1 1186 0
49
static TypeHandle LPoint4d::get_class_type(void);

2978 9 ~LPoint4d 0 4 3568 19 LPoint4d::~LPoint4d 0 0 0
26
LPoint4d::~LPoint4d(void);

2979 8 LPoint4i 0 4 3569 18 LPoint4i::LPoint4i 0 6 1187 1188 1189 1190 1191 1192 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
304
inline LPoint4i::LPoint4i(void) = default;
inline LPoint4i::LPoint4i(LVecBase4i const &copy);
inline LPoint4i::LPoint4i(int fill_value);
inline LPoint4i::LPoint4i(int x, int y, int z, int w);
inline LPoint4i::LPoint4i(LVecBase3i const &copy, int w);
inline LPoint4i::LPoint4i(LPoint4i const &) = default;

2980 11 __getattr__ 0 4 3569 21 LPoint4i::__getattr__ 0 1 1193 0
91
inline PyObject *LPoint4i::__getattr__(PyObject *self, std::string const &attr_name) const;

2981 11 __setattr__ 0 4 3569 21 LPoint4i::__setattr__ 0 1 1194 0
97
inline int LPoint4i::__setattr__(PyObject *self, std::string const &attr_name, PyObject *assign);

2982 4 zero 0 4 3569 14 LPoint4i::zero 0 1 1195 39
/**
 * Returns a zero-length point.
 */
51
static inline LPoint4i const &LPoint4i::zero(void);

2983 6 unit_x 0 4 3569 16 LPoint4i::unit_x 0 1 1196 34
/**
 * Returns a unit X point.
 */
53
static inline LPoint4i const &LPoint4i::unit_x(void);

2984 6 unit_y 0 4 3569 16 LPoint4i::unit_y 0 1 1197 34
/**
 * Returns a unit Y point.
 */
53
static inline LPoint4i const &LPoint4i::unit_y(void);

2985 6 unit_z 0 4 3569 16 LPoint4i::unit_z 0 1 1198 34
/**
 * Returns a unit Z point.
 */
53
static inline LPoint4i const &LPoint4i::unit_z(void);

2986 6 unit_w 0 4 3569 16 LPoint4i::unit_w 0 1 1199 34
/**
 * Returns a unit W point.
 */
53
static inline LPoint4i const &LPoint4i::unit_w(void);

2987 7 get_xyz 0 4 3569 17 LPoint4i::get_xyz 0 1 1200 58
/**
 * Returns the x, y and z component of this vector
 */
46
inline LPoint3i LPoint4i::get_xyz(void) const;

2988 6 get_xy 0 4 3569 16 LPoint4i::get_xy 0 1 1201 55
/**
 * Returns the x and y component of this vector
 */
45
inline LPoint2i LPoint4i::get_xy(void) const;

2989 10 operator - 0 68 3569 20 LPoint4i::operator - 0 1 1202 0
49
inline LPoint4i LPoint4i::operator -(void) const;

2990 10 operator + 0 4 3569 20 LPoint4i::operator + 0 2 1203 1204 0
138
inline LVecBase4i LPoint4i::operator +(LVecBase4i const &other) const;
inline LPoint4i LPoint4i::operator +(LVector4i const &other) const;

2991 10 operator - 0 4 3569 20 LPoint4i::operator - 0 3 1205 1206 1207 0
206
inline LVecBase4i LPoint4i::operator -(LVecBase4i const &other) const;
inline LVector4i LPoint4i::operator -(LPoint4i const &other) const;
inline LPoint4i LPoint4i::operator -(LVector4i const &other) const;

2992 10 operator * 0 4 3569 20 LPoint4i::operator * 0 1 1208 0
55
inline LPoint4i LPoint4i::operator *(int scalar) const;

2993 10 operator / 0 4 3569 20 LPoint4i::operator / 0 1 1209 0
55
inline LPoint4i LPoint4i::operator /(int scalar) const;

2994 8 __repr__ 0 4 3569 18 LPoint4i::__repr__ 0 1 1210 0
50
inline std::string LPoint4i::__repr__(void) const;

2995 14 get_class_type 0 4 3569 24 LPoint4i::get_class_type 0 1 1211 0
49
static TypeHandle LPoint4i::get_class_type(void);

2996 9 ~LPoint4i 0 4 3569 19 LPoint4i::~LPoint4i 0 0 0
26
LPoint4i::~LPoint4i(void);

2997 11 operator [] 0 4 3572 27 LMatrix3f::Row::operator [] 0 2 1314 1315 10
/**
 *
 */
104
inline float LMatrix3f::Row::operator [](int i) const;
inline float &LMatrix3f::Row::operator [](int i);

2998 4 size 0 4 3572 20 LMatrix3f::Row::size 0 1 1316 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3f::Row::size(void);

2999 17 operator typecast 0 132 3572 33 LMatrix3f::Row::operator typecast 0 1 1317 0
47
inline operator LVecBase3f const &(void) const;

3000 3 Row 0 4 3572 19 LMatrix3f::Row::Row 0 1 1313 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3f::Row::Row(LMatrix3f::Row const &) = default;

3001 4 ~Row 0 4 3572 20 LMatrix3f::Row::~Row 0 0 0
27
LMatrix3f::Row::~Row(void);

3002 11 operator [] 0 4 3573 28 LMatrix3f::CRow::operator [] 0 1 1319 0
55
inline float LMatrix3f::CRow::operator [](int i) const;

3003 4 size 0 4 3573 21 LMatrix3f::CRow::size 0 1 1320 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3f::CRow::size(void);

3004 17 operator typecast 0 132 3573 34 LMatrix3f::CRow::operator typecast 0 1 1321 0
47
inline operator LVecBase3f const &(void) const;

3005 4 CRow 0 4 3573 21 LMatrix3f::CRow::CRow 0 1 1318 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3f::CRow::CRow(LMatrix3f::CRow const &) = default;

3006 5 ~CRow 0 4 3573 22 LMatrix3f::CRow::~CRow 0 0 0
29
LMatrix3f::CRow::~CRow(void);

3007 9 LMatrix3f 0 4 3570 20 LMatrix3f::LMatrix3f 0 4 1212 1213 1214 1215 96
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
277
inline LMatrix3f::LMatrix3f(void);
inline LMatrix3f::LMatrix3f(LMatrix3f const &other);
inline LMatrix3f::LMatrix3f(float , float , float , float , float , float , float , float , float );
inline LMatrix3f::LMatrix3f(LVecBase3f const &, LVecBase3f const &, LVecBase3f const &);

3008 10 operator = 0 4 3570 21 LMatrix3f::operator = 0 2 1216 1217 22
/**
 *
 */

/**
 *
 */
111
inline void LMatrix3f::operator =(LMatrix3f const &other);
inline void LMatrix3f::operator =(float fill_value);

3009 12 operator new 0 4 3570 23 LMatrix3f::operator new 0 1 1218 0
122
inline void *LMatrix3f::operator new(std::size_t size);
inline void *LMatrix3f::operator new(std::size_t size, void *ptr);

3010 15 operator delete 0 4 3570 26 LMatrix3f::operator delete 0 0 0
106
inline void LMatrix3f::operator delete(void *ptr);
inline void LMatrix3f::operator delete(void *, void *);

3011 12 validate_ptr 0 4 3570 23 LMatrix3f::validate_ptr 0 0 0
60
static inline bool LMatrix3f::validate_ptr(void const *ptr);

3012 10 __reduce__ 0 4 3570 21 LMatrix3f::__reduce__ 0 1 1219 0
61
inline PyObject *LMatrix3f::__reduce__(PyObject *self) const;

3013 4 fill 0 4 3570 15 LMatrix3f::fill 0 1 1220 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
39
void LMatrix3f::fill(float fill_value);

3014 3 set 0 4 3570 14 LMatrix3f::set 0 1 1221 10
/**
 *
 */
126
inline void LMatrix3f::set(float e00, float e01, float e02, float e10, float e11, float e12, float e20, float e21, float e22);

3015 11 operator [] 0 4 3570 22 LMatrix3f::operator [] 0 2 1222 1223 0
112
inline LMatrix3f::CRow LMatrix3f::operator [](int i) const;
inline LMatrix3f::Row LMatrix3f::operator [](int i);

3016 4 size 0 4 3570 15 LMatrix3f::size 0 1 1224 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3f::size(void);

3017 7 set_row 0 4 3570 18 LMatrix3f::set_row 0 2 1225 1226 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3f::set_row(int row, LVecBase3f const &v);
inline void LMatrix3f::set_row(int row, LVecBase2f const &v);

3018 7 set_col 0 4 3570 18 LMatrix3f::set_col 0 2 1227 1228 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3f::set_col(int col, LVecBase3f const &v);
inline void LMatrix3f::set_col(int col, LVecBase2f const &v);

3019 7 get_row 0 4 3570 18 LMatrix3f::get_row 0 2 1229 1230 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3f LMatrix3f::get_row(int row) const;
inline void LMatrix3f::get_row(LVecBase3f &result_vec, int row) const;

3020 7 get_col 0 4 3570 18 LMatrix3f::get_col 0 1 1231 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3f LMatrix3f::get_col(int col) const;

3021 0 0 0 0 0 0 0 0
0

3022 0 0 0 0 0 0 0 0
0

3023 8 get_row2 0 4 3570 19 LMatrix3f::get_row2 0 1 1232 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2f LMatrix3f::get_row2(int row) const;

3024 8 get_col2 0 4 3570 19 LMatrix3f::get_col2 0 1 1233 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2f LMatrix3f::get_col2(int col) const;

3025 11 operator () 0 4 3570 22 LMatrix3f::operator () 0 2 1234 1235 10
/**
 *
 */
116
inline float &LMatrix3f::operator ()(int row, int col);
inline float LMatrix3f::operator ()(int row, int col) const;

3026 6 is_nan 0 4 3570 17 LMatrix3f::is_nan 0 1 1236 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3f::is_nan(void) const;

3027 11 is_identity 0 4 3570 22 LMatrix3f::is_identity 0 1 1237 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3f::is_identity(void) const;

3028 8 get_cell 0 4 3570 19 LMatrix3f::get_cell 0 1 1238 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix3f::get_cell(int row, int col) const;

3029 8 set_cell 0 4 3570 19 LMatrix3f::set_cell 0 1 1239 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix3f::set_cell(int row, int col, float value);

3030 8 get_data 0 4 3570 19 LMatrix3f::get_data 0 1 1240 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix3f::get_data(void) const;

3031 18 get_num_components 0 4 3570 29 LMatrix3f::get_num_components 0 1 1241 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3f::get_num_components(void) const;

3032 10 operator < 0 4 3570 21 LMatrix3f::operator < 0 1 1242 0
64
inline bool LMatrix3f::operator <(LMatrix3f const &other) const;

3033 11 operator == 0 4 3570 22 LMatrix3f::operator == 0 1 1243 0
65
inline bool LMatrix3f::operator ==(LMatrix3f const &other) const;

3034 11 operator != 0 4 3570 22 LMatrix3f::operator != 0 1 1244 0
65
inline bool LMatrix3f::operator !=(LMatrix3f const &other) const;

3035 10 compare_to 0 4 3570 21 LMatrix3f::compare_to 0 2 1245 1246 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix3f::compare_to(LMatrix3f const &other) const;
int LMatrix3f::compare_to(LMatrix3f const &other, float threshold) const;

3036 8 get_hash 0 4 3570 19 LMatrix3f::get_hash 0 2 1247 1248 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix3f::get_hash(void) const;
inline std::size_t LMatrix3f::get_hash(float threshold) const;

3037 8 add_hash 0 4 3570 19 LMatrix3f::add_hash 0 2 1249 1250 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix3f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3f::add_hash(std::size_t hash, float threshold) const;

3038 5 xform 0 4 3570 16 LMatrix3f::xform 0 1 1251 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3f LMatrix3f::xform(LVecBase3f const &v) const;

3039 11 xform_point 0 4 3570 22 LMatrix3f::xform_point 0 1 1252 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2f LMatrix3f::xform_point(LVecBase2f const &v) const;

3040 9 xform_vec 0 4 3570 20 LMatrix3f::xform_vec 0 2 1253 1254 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2f LMatrix3f::xform_vec(LVecBase2f const &v) const;
inline LVecBase3f LMatrix3f::xform_vec(LVecBase3f const &v) const;

3041 17 xform_vec_general 0 4 3570 28 LMatrix3f::xform_vec_general 0 1 1255 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix3f::xform_vec_general(LVecBase3f const &v) const;

3042 14 xform_in_place 0 4 3570 25 LMatrix3f::xform_in_place 0 1 1256 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3f::xform_in_place(LVecBase3f &v) const;

3043 20 xform_point_in_place 0 4 3570 31 LMatrix3f::xform_point_in_place 0 1 1257 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3f::xform_point_in_place(LVecBase2f &v) const;

3044 18 xform_vec_in_place 0 4 3570 29 LMatrix3f::xform_vec_in_place 0 2 1258 1259 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3f::xform_vec_in_place(LVecBase2f &v) const;
inline void LMatrix3f::xform_vec_in_place(LVecBase3f &v) const;

3045 26 xform_vec_general_in_place 0 4 3570 37 LMatrix3f::xform_vec_general_in_place 0 1 1260 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3f::xform_vec_general_in_place(LVecBase3f &v) const;

3046 8 multiply 0 4 3570 19 LMatrix3f::multiply 0 1 1261 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3f::multiply(LMatrix3f const &other1, LMatrix3f const &other2);

3047 10 operator * 0 4 3570 21 LMatrix3f::operator * 0 2 1262 1263 0
129
inline LMatrix3f LMatrix3f::operator *(LMatrix3f const &other) const;
inline LMatrix3f LMatrix3f::operator *(float scalar) const;

3048 10 operator / 0 4 3570 21 LMatrix3f::operator / 0 1 1264 0
59
inline LMatrix3f LMatrix3f::operator /(float scalar) const;

3049 11 operator += 0 4 3570 22 LMatrix3f::operator += 0 1 1265 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator +=(LMatrix3f const &other);

3050 11 operator -= 0 4 3570 22 LMatrix3f::operator -= 0 1 1266 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3f &LMatrix3f::operator -=(LMatrix3f const &other);

3051 11 operator *= 0 4 3570 22 LMatrix3f::operator *= 0 2 1267 1268 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
121
inline LMatrix3f &LMatrix3f::operator *=(LMatrix3f const &other);
inline LMatrix3f &LMatrix3f::operator *=(float scalar);

3052 11 operator /= 0 4 3570 22 LMatrix3f::operator /= 0 1 1269 39
/**
 * Performs a memberwise scale.
 */
55
inline LMatrix3f &LMatrix3f::operator /=(float scalar);

3053 18 componentwise_mult 0 4 3570 29 LMatrix3f::componentwise_mult 0 1 1270 10
/**
 *
 */
66
inline void LMatrix3f::componentwise_mult(LMatrix3f const &other);

3054 11 determinant 0 4 3570 22 LMatrix3f::determinant 0 1 1271 49
/**
 * Returns the determinant of the matrix.
 */
48
inline float LMatrix3f::determinant(void) const;

3055 14 transpose_from 0 4 3570 25 LMatrix3f::transpose_from 0 1 1272 10
/**
 *
 */
62
inline void LMatrix3f::transpose_from(LMatrix3f const &other);

3056 18 transpose_in_place 0 4 3570 29 LMatrix3f::transpose_in_place 0 1 1273 10
/**
 *
 */
48
inline void LMatrix3f::transpose_in_place(void);

3057 11 invert_from 0 4 3570 22 LMatrix3f::invert_from 0 1 1274 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3f::invert_from(LMatrix3f const &other);

3058 15 invert_in_place 0 4 3570 26 LMatrix3f::invert_in_place 0 1 1275 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3f::invert_in_place(void);

3059 21 invert_transpose_from 0 4 3570 32 LMatrix3f::invert_transpose_from 0 2 1276 1277 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3f::invert_transpose_from(LMatrix3f const &other);
inline bool LMatrix3f::invert_transpose_from(LMatrix4f const &other);

3060 9 ident_mat 0 4 3570 20 LMatrix3f::ident_mat 0 1 1278 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3f const &LMatrix3f::ident_mat(void);

3061 17 set_translate_mat 0 4 3570 28 LMatrix3f::set_translate_mat 0 1 1279 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3f::set_translate_mat(LVecBase2f const &trans);

3062 14 set_rotate_mat 0 4 3570 25 LMatrix3f::set_rotate_mat 0 2 1280 1281 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
156
inline void LMatrix3f::set_rotate_mat(float angle);
void LMatrix3f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3063 13 set_scale_mat 0 4 3570 24 LMatrix3f::set_scale_mat 0 2 1282 1283 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3f::set_scale_mat(LVecBase2f const &scale);
inline void LMatrix3f::set_scale_mat(LVecBase3f const &scale);

3064 13 translate_mat 0 4 3570 24 LMatrix3f::translate_mat 0 2 1284 1285 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
144
static inline LMatrix3f LMatrix3f::translate_mat(LVecBase2f const &trans);
static inline LMatrix3f LMatrix3f::translate_mat(float tx, float ty);

3065 10 rotate_mat 0 4 3570 21 LMatrix3f::rotate_mat 0 2 1286 1287 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
179
static inline LMatrix3f LMatrix3f::rotate_mat(float angle);
static inline LMatrix3f LMatrix3f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3066 9 scale_mat 0 4 3570 20 LMatrix3f::scale_mat 0 4 1288 1289 1290 1291 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
283
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase2f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy);
static inline LMatrix3f LMatrix3f::scale_mat(LVecBase3f const &scale);
static inline LMatrix3f LMatrix3f::scale_mat(float sx, float sy, float sz);

3067 23 set_rotate_mat_normaxis 0 4 3570 34 LMatrix3f::set_rotate_mat_normaxis 0 1 1292 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
113
void LMatrix3f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3068 19 rotate_mat_normaxis 0 4 3570 30 LMatrix3f::rotate_mat_normaxis 0 1 1293 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
128
static inline LMatrix3f LMatrix3f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3069 13 set_shear_mat 0 4 3570 24 LMatrix3f::set_shear_mat 0 1 1294 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3070 9 shear_mat 0 4 3570 20 LMatrix3f::shear_mat 0 2 1295 1296 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix3f LMatrix3f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3071 19 set_scale_shear_mat 0 4 3570 30 LMatrix3f::set_scale_shear_mat 0 1 1297 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3072 15 scale_shear_mat 0 4 3570 26 LMatrix3f::scale_shear_mat 0 2 1298 1299 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix3f LMatrix3f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3f LMatrix3f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3073 11 convert_mat 0 4 3570 22 LMatrix3f::convert_mat 0 1 1300 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3f const &LMatrix3f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3074 12 almost_equal 0 4 3570 23 LMatrix3f::almost_equal 0 2 1301 1302 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
143
bool LMatrix3f::almost_equal(LMatrix3f const &other, float threshold) const;
inline bool LMatrix3f::almost_equal(LMatrix3f const &other) const;

3075 6 output 0 4 3570 17 LMatrix3f::output 0 1 1303 10
/**
 *
 */
48
void LMatrix3f::output(std::ostream &out) const;

3076 5 write 0 4 3570 16 LMatrix3f::write 0 1 1304 10
/**
 *
 */
69
void LMatrix3f::write(std::ostream &out, int indent_level = 0) const;

3077 8 __repr__ 0 4 3570 19 LMatrix3f::__repr__ 0 1 1305 0
51
inline std::string LMatrix3f::__repr__(void) const;

3078 13 generate_hash 0 4 3570 24 LMatrix3f::generate_hash 0 2 1306 1307 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
161
inline void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3f::generate_hash(ChecksumHashGenerator &hashgen, float threshold) const;

3079 20 write_datagram_fixed 0 4 3570 31 LMatrix3f::write_datagram_fixed 0 1 1308 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3f::write_datagram_fixed(Datagram &destination) const;

3080 19 read_datagram_fixed 0 4 3570 30 LMatrix3f::read_datagram_fixed 0 1 1309 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3f::read_datagram_fixed(DatagramIterator &scan);

3081 14 write_datagram 0 4 3570 25 LMatrix3f::write_datagram 0 1 1310 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3f::write_datagram(Datagram &destination) const;

3082 13 read_datagram 0 4 3570 24 LMatrix3f::read_datagram 0 1 1311 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3f::read_datagram(DatagramIterator &source);

3083 14 get_class_type 0 4 3570 25 LMatrix3f::get_class_type 0 1 1312 0
50
static TypeHandle LMatrix3f::get_class_type(void);

3084 10 ~LMatrix3f 0 4 3570 21 LMatrix3f::~LMatrix3f 0 0 0
28
LMatrix3f::~LMatrix3f(void);

3085 9 transpose 0 1 0 9 transpose 0 4 1884 1885 1886 1887 0
191
inline LMatrix3f transpose(LMatrix3f const &a);
inline LMatrix4f transpose(LMatrix4f const &a);
inline LMatrix3d transpose(LMatrix3d const &a);
inline LMatrix4d transpose(LMatrix4d const &a);

3086 6 invert 0 1 0 6 invert 0 6 1888 1889 1890 1891 1892 1893 0
281
inline LMatrix3f invert(LMatrix3f const &a);
inline LMatrix4f invert(LMatrix4f const &a);
inline LMatrix3d invert(LMatrix3d const &a);
inline LMatrix4d invert(LMatrix4d const &a);
inline LQuaternionf invert(LQuaternionf const &a);
inline LQuaterniond invert(LQuaterniond const &a);

3087 11 operator [] 0 4 3576 27 LMatrix4f::Row::operator [] 0 2 1434 1435 10
/**
 *
 */
104
inline float LMatrix4f::Row::operator [](int i) const;
inline float &LMatrix4f::Row::operator [](int i);

3088 4 size 0 4 3576 20 LMatrix4f::Row::size 0 1 1436 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4f::Row::size(void);

3089 17 operator typecast 0 132 3576 33 LMatrix4f::Row::operator typecast 0 1 1437 0
47
inline operator LVecBase4f const &(void) const;

3090 3 Row 0 4 3576 19 LMatrix4f::Row::Row 0 1 1433 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4f::Row::Row(LMatrix4f::Row const &) = default;

3091 4 ~Row 0 4 3576 20 LMatrix4f::Row::~Row 0 0 0
27
LMatrix4f::Row::~Row(void);

3092 11 operator [] 0 4 3577 28 LMatrix4f::CRow::operator [] 0 1 1439 0
55
inline float LMatrix4f::CRow::operator [](int i) const;

3093 4 size 0 4 3577 21 LMatrix4f::CRow::size 0 1 1440 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4f::CRow::size(void);

3094 17 operator typecast 0 132 3577 34 LMatrix4f::CRow::operator typecast 0 1 1441 0
47
inline operator LVecBase4f const &(void) const;

3095 4 CRow 0 4 3577 21 LMatrix4f::CRow::CRow 0 1 1438 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4f::CRow::CRow(LMatrix4f::CRow const &) = default;

3096 5 ~CRow 0 4 3577 22 LMatrix4f::CRow::~CRow 0 0 0
29
LMatrix4f::CRow::~CRow(void);

3097 9 LMatrix4f 0 4 3574 20 LMatrix4f::LMatrix4f 0 7 1322 1323 1324 1325 1326 1327 1328 228
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
548
inline LMatrix4f::LMatrix4f(void);
inline LMatrix4f::LMatrix4f(LMatrix4f const &other);
inline LMatrix4f::LMatrix4f(UnalignedLMatrix4f const &other);
inline LMatrix4f::LMatrix4f(float , float , float , float , float , float , float , float , float , float , float , float , float , float , float , float );
inline LMatrix4f::LMatrix4f(LVecBase4f const &, LVecBase4f const &, LVecBase4f const &, LVecBase4f const &);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3);
inline LMatrix4f::LMatrix4f(LMatrix3f const &upper3, LVecBase3f const &trans);

3098 10 operator = 0 4 3574 21 LMatrix4f::operator = 0 3 1329 1330 1331 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
179
inline void LMatrix4f::operator =(LMatrix4f const &other);
inline void LMatrix4f::operator =(UnalignedLMatrix4f const &other);
inline void LMatrix4f::operator =(float fill_value);

3099 12 operator new 0 4 3574 23 LMatrix4f::operator new 0 1 1332 0
122
inline void *LMatrix4f::operator new(std::size_t size);
inline void *LMatrix4f::operator new(std::size_t size, void *ptr);

3100 15 operator delete 0 4 3574 26 LMatrix4f::operator delete 0 0 0
106
inline void LMatrix4f::operator delete(void *ptr);
inline void LMatrix4f::operator delete(void *, void *);

3101 12 validate_ptr 0 4 3574 23 LMatrix4f::validate_ptr 0 0 0
60
static inline bool LMatrix4f::validate_ptr(void const *ptr);

3102 10 __reduce__ 0 4 3574 21 LMatrix4f::__reduce__ 0 1 1333 0
61
inline PyObject *LMatrix4f::__reduce__(PyObject *self) const;

3103 4 fill 0 4 3574 15 LMatrix4f::fill 0 1 1334 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
46
inline void LMatrix4f::fill(float fill_value);

3104 3 set 0 4 3574 14 LMatrix4f::set 0 1 1335 10
/**
 *
 */
203
inline void LMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3105 11 set_upper_3 0 4 3574 22 LMatrix4f::set_upper_3 0 1 1336 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4f::set_upper_3(LMatrix3f const &upper3);

3106 11 get_upper_3 0 4 3574 22 LMatrix4f::get_upper_3 0 1 1337 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3f LMatrix4f::get_upper_3(void) const;

3107 11 operator [] 0 4 3574 22 LMatrix4f::operator [] 0 2 1338 1339 0
112
inline LMatrix4f::CRow LMatrix4f::operator [](int i) const;
inline LMatrix4f::Row LMatrix4f::operator [](int i);

3108 4 size 0 4 3574 15 LMatrix4f::size 0 1 1340 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4f::size(void);

3109 7 set_row 0 4 3574 18 LMatrix4f::set_row 0 2 1341 1342 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4f::set_row(int row, LVecBase4f const &v);
inline void LMatrix4f::set_row(int row, LVecBase3f const &v);

3110 7 set_col 0 4 3574 18 LMatrix4f::set_col 0 2 1343 1344 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4f::set_col(int col, LVecBase4f const &v);
inline void LMatrix4f::set_col(int col, LVecBase3f const &v);

3111 7 get_row 0 4 3574 18 LMatrix4f::get_row 0 2 1345 1346 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4f LMatrix4f::get_row(int row) const;
inline void LMatrix4f::get_row(LVecBase4f &result_vec, int row) const;

3112 7 get_col 0 4 3574 18 LMatrix4f::get_col 0 1 1347 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4f LMatrix4f::get_col(int col) const;

3113 8 get_row3 0 4 3574 19 LMatrix4f::get_row3 0 2 1348 1349 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3f LMatrix4f::get_row3(int row) const;
inline void LMatrix4f::get_row3(LVecBase3f &result_vec, int row) const;

3114 0 0 0 0 0 0 0 0
0

3115 0 0 0 0 0 0 0 0
0

3116 8 get_col3 0 4 3574 19 LMatrix4f::get_col3 0 1 1350 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3f LMatrix4f::get_col3(int col) const;

3117 11 operator () 0 4 3574 22 LMatrix4f::operator () 0 2 1351 1352 10
/**
 *
 */
116
inline float &LMatrix4f::operator ()(int row, int col);
inline float LMatrix4f::operator ()(int row, int col) const;

3118 6 is_nan 0 4 3574 17 LMatrix4f::is_nan 0 1 1353 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4f::is_nan(void) const;

3119 11 is_identity 0 4 3574 22 LMatrix4f::is_identity 0 1 1354 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4f::is_identity(void) const;

3120 8 get_cell 0 4 3574 19 LMatrix4f::get_cell 0 1 1355 54
/**
 * Returns a particular element of the matrix.
 */
57
inline float LMatrix4f::get_cell(int row, int col) const;

3121 8 set_cell 0 4 3574 19 LMatrix4f::set_cell 0 1 1356 54
/**
 * Changes a particular element of the matrix.
 */
63
inline void LMatrix4f::set_cell(int row, int col, float value);

3122 8 get_data 0 4 3574 19 LMatrix4f::get_data 0 1 1357 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
52
inline float const *LMatrix4f::get_data(void) const;

3123 18 get_num_components 0 4 3574 29 LMatrix4f::get_num_components 0 1 1358 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4f::get_num_components(void) const;

3124 5 begin 0 4 3574 16 LMatrix4f::begin 0 2 1359 1360 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4f::iterator LMatrix4f::begin(void);
inline LMatrix4f::const_iterator LMatrix4f::begin(void) const;

3125 3 end 0 4 3574 14 LMatrix4f::end 0 2 1361 1362 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4f::iterator LMatrix4f::end(void);
inline LMatrix4f::const_iterator LMatrix4f::end(void) const;

3126 10 operator < 0 4 3574 21 LMatrix4f::operator < 0 1 1363 0
64
inline bool LMatrix4f::operator <(LMatrix4f const &other) const;

3127 11 operator == 0 4 3574 22 LMatrix4f::operator == 0 1 1364 0
65
inline bool LMatrix4f::operator ==(LMatrix4f const &other) const;

3128 11 operator != 0 4 3574 22 LMatrix4f::operator != 0 1 1365 0
65
inline bool LMatrix4f::operator !=(LMatrix4f const &other) const;

3129 10 compare_to 0 4 3574 21 LMatrix4f::compare_to 0 2 1366 1367 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
137
inline int LMatrix4f::compare_to(LMatrix4f const &other) const;
int LMatrix4f::compare_to(LMatrix4f const &other, float threshold) const;

3130 8 get_hash 0 4 3574 19 LMatrix4f::get_hash 0 2 1368 1369 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
114
inline std::size_t LMatrix4f::get_hash(void) const;
inline std::size_t LMatrix4f::get_hash(float threshold) const;

3131 8 add_hash 0 4 3574 19 LMatrix4f::add_hash 0 2 1370 1371 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
144
inline std::size_t LMatrix4f::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4f::add_hash(std::size_t hash, float threshold) const;

3132 5 xform 0 4 3574 16 LMatrix4f::xform 0 1 1372 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4f LMatrix4f::xform(LVecBase4f const &v) const;

3133 11 xform_point 0 4 3574 22 LMatrix4f::xform_point 0 1 1373 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3f LMatrix4f::xform_point(LVecBase3f const &v) const;

3134 19 xform_point_general 0 4 3574 30 LMatrix4f::xform_point_general 0 1 1374 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3f LMatrix4f::xform_point_general(LVecBase3f const &v) const;

3135 9 xform_vec 0 4 3574 20 LMatrix4f::xform_vec 0 1 1375 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3f LMatrix4f::xform_vec(LVecBase3f const &v) const;

3136 17 xform_vec_general 0 4 3574 28 LMatrix4f::xform_vec_general 0 1 1376 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3f LMatrix4f::xform_vec_general(LVecBase3f const &v) const;

3137 14 xform_in_place 0 4 3574 25 LMatrix4f::xform_in_place 0 1 1377 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4f::xform_in_place(LVecBase4f &v) const;

3138 20 xform_point_in_place 0 4 3574 31 LMatrix4f::xform_point_in_place 0 1 1378 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4f::xform_point_in_place(LVecBase3f &v) const;

3139 28 xform_point_general_in_place 0 4 3574 39 LMatrix4f::xform_point_general_in_place 0 1 1379 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4f::xform_point_general_in_place(LVecBase3f &v) const;

3140 18 xform_vec_in_place 0 4 3574 29 LMatrix4f::xform_vec_in_place 0 1 1380 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4f::xform_vec_in_place(LVecBase3f &v) const;

3141 26 xform_vec_general_in_place 0 4 3574 37 LMatrix4f::xform_vec_general_in_place 0 1 1381 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4f::xform_vec_general_in_place(LVecBase3f &v) const;

3142 8 multiply 0 4 3574 19 LMatrix4f::multiply 0 1 1382 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4f::multiply(LMatrix4f const &other1, LMatrix4f const &other2);

3143 10 operator * 0 4 3574 21 LMatrix4f::operator * 0 2 1383 1384 0
129
inline LMatrix4f LMatrix4f::operator *(LMatrix4f const &other) const;
inline LMatrix4f LMatrix4f::operator *(float scalar) const;

3144 10 operator / 0 4 3574 21 LMatrix4f::operator / 0 1 1385 0
59
inline LMatrix4f LMatrix4f::operator /(float scalar) const;

3145 11 operator += 0 4 3574 22 LMatrix4f::operator += 0 1 1386 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator +=(LMatrix4f const &other);

3146 11 operator -= 0 4 3574 22 LMatrix4f::operator -= 0 1 1387 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4f &LMatrix4f::operator -=(LMatrix4f const &other);

3147 11 operator *= 0 4 3574 22 LMatrix4f::operator *= 0 2 1388 1389 22
/**
 *
 */

/**
 *
 */
121
inline LMatrix4f &LMatrix4f::operator *=(LMatrix4f const &other);
inline LMatrix4f &LMatrix4f::operator *=(float scalar);

3148 11 operator /= 0 4 3574 22 LMatrix4f::operator /= 0 1 1390 10
/**
 *
 */
55
inline LMatrix4f &LMatrix4f::operator /=(float scalar);

3149 18 componentwise_mult 0 4 3574 29 LMatrix4f::componentwise_mult 0 1 1391 10
/**
 *
 */
66
inline void LMatrix4f::componentwise_mult(LMatrix4f const &other);

3150 14 transpose_from 0 4 3574 25 LMatrix4f::transpose_from 0 1 1392 10
/**
 *
 */
62
inline void LMatrix4f::transpose_from(LMatrix4f const &other);

3151 18 transpose_in_place 0 4 3574 29 LMatrix4f::transpose_in_place 0 1 1393 10
/**
 *
 */
48
inline void LMatrix4f::transpose_in_place(void);

3152 11 invert_from 0 4 3574 22 LMatrix4f::invert_from 0 1 1394 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4f::invert_from(LMatrix4f const &other);

3153 18 invert_affine_from 0 4 3574 29 LMatrix4f::invert_affine_from 0 1 1395 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4f::invert_affine_from(LMatrix4f const &other);

3154 15 invert_in_place 0 4 3574 26 LMatrix4f::invert_in_place 0 1 1396 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4f::invert_in_place(void);

3155 10 accumulate 0 4 3574 21 LMatrix4f::accumulate 0 1 1397 46
/**
 * Computes (*this) += other * weight.
 */
72
inline void LMatrix4f::accumulate(LMatrix4f const &other, float weight);

3156 9 ident_mat 0 4 3574 20 LMatrix4f::ident_mat 0 1 1398 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4f const &LMatrix4f::ident_mat(void);

3157 8 ones_mat 0 4 3574 19 LMatrix4f::ones_mat 0 1 1399 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4f const &LMatrix4f::ones_mat(void);

3158 9 zeros_mat 0 4 3574 20 LMatrix4f::zeros_mat 0 1 1400 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4f const &LMatrix4f::zeros_mat(void);

3159 17 set_translate_mat 0 4 3574 28 LMatrix4f::set_translate_mat 0 1 1401 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4f::set_translate_mat(LVecBase3f const &trans);

3160 14 set_rotate_mat 0 4 3574 25 LMatrix4f::set_rotate_mat 0 1 1402 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
104
void LMatrix4f::set_rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3161 23 set_rotate_mat_normaxis 0 4 3574 34 LMatrix4f::set_rotate_mat_normaxis 0 1 1403 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
113
void LMatrix4f::set_rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3162 13 set_scale_mat 0 4 3574 24 LMatrix4f::set_scale_mat 0 1 1404 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4f::set_scale_mat(LVecBase3f const &scale);

3163 13 set_shear_mat 0 4 3574 24 LMatrix4f::set_shear_mat 0 1 1405 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4f::set_shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3164 19 set_scale_shear_mat 0 4 3574 30 LMatrix4f::set_scale_shear_mat 0 1 1406 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4f::set_scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);

3165 13 translate_mat 0 4 3574 24 LMatrix4f::translate_mat 0 2 1407 1408 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
154
static inline LMatrix4f LMatrix4f::translate_mat(LVecBase3f const &trans);
static inline LMatrix4f LMatrix4f::translate_mat(float tx, float ty, float tz);

3166 10 rotate_mat 0 4 3574 21 LMatrix4f::rotate_mat 0 1 1409 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
119
static inline LMatrix4f LMatrix4f::rotate_mat(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3167 19 rotate_mat_normaxis 0 4 3574 30 LMatrix4f::rotate_mat_normaxis 0 1 1410 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
128
static inline LMatrix4f LMatrix4f::rotate_mat_normaxis(float angle, LVecBase3f const &axis, CoordinateSystem cs = ::CS_default);

3168 9 scale_mat 0 4 3574 20 LMatrix4f::scale_mat 0 3 1411 1412 1413 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
205
static inline LMatrix4f LMatrix4f::scale_mat(LVecBase3f const &scale);
static inline LMatrix4f LMatrix4f::scale_mat(float sx, float sy, float sz);
static inline LMatrix4f LMatrix4f::scale_mat(float scale);

3169 9 shear_mat 0 4 3574 20 LMatrix4f::shear_mat 0 2 1414 1415 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
224
static inline LMatrix4f LMatrix4f::shear_mat(LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::shear_mat(float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3170 15 scale_shear_mat 0 4 3574 26 LMatrix4f::scale_shear_mat 0 2 1416 1417 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
291
static inline LMatrix4f LMatrix4f::scale_shear_mat(LVecBase3f const &scale, LVecBase3f const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4f LMatrix4f::scale_shear_mat(float sx, float sy, float sz, float shxy, float shxz, float shyz, CoordinateSystem cs = ::CS_default);

3171 13 y_to_z_up_mat 0 4 3574 24 LMatrix4f::y_to_z_up_mat 0 1 1418 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::y_to_z_up_mat(void);

3172 13 z_to_y_up_mat 0 4 3574 24 LMatrix4f::z_to_y_up_mat 0 1 1419 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4f const &LMatrix4f::z_to_y_up_mat(void);

3173 11 convert_mat 0 4 3574 22 LMatrix4f::convert_mat 0 1 1420 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4f const &LMatrix4f::convert_mat(CoordinateSystem from, CoordinateSystem to);

3174 12 almost_equal 0 4 3574 23 LMatrix4f::almost_equal 0 2 1421 1422 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
143
bool LMatrix4f::almost_equal(LMatrix4f const &other, float threshold) const;
inline bool LMatrix4f::almost_equal(LMatrix4f const &other) const;

3175 6 output 0 4 3574 17 LMatrix4f::output 0 1 1423 10
/**
 *
 */
48
void LMatrix4f::output(std::ostream &out) const;

3176 5 write 0 4 3574 16 LMatrix4f::write 0 1 1424 10
/**
 *
 */
69
void LMatrix4f::write(std::ostream &out, int indent_level = 0) const;

3177 8 __repr__ 0 4 3574 19 LMatrix4f::__repr__ 0 1 1425 0
51
inline std::string LMatrix4f::__repr__(void) const;

3178 13 generate_hash 0 4 3574 24 LMatrix4f::generate_hash 0 2 1426 1427 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
157
inline void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4f::generate_hash(ChecksumHashGenerator &hashgen, float scale) const;

3179 20 write_datagram_fixed 0 4 3574 31 LMatrix4f::write_datagram_fixed 0 1 1428 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4f::write_datagram_fixed(Datagram &destination) const;

3180 19 read_datagram_fixed 0 4 3574 30 LMatrix4f::read_datagram_fixed 0 1 1429 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4f::read_datagram_fixed(DatagramIterator &scan);

3181 14 write_datagram 0 4 3574 25 LMatrix4f::write_datagram 0 1 1430 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4f::write_datagram(Datagram &destination) const;

3182 13 read_datagram 0 4 3574 24 LMatrix4f::read_datagram 0 1 1431 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4f::read_datagram(DatagramIterator &source);

3183 14 get_class_type 0 4 3574 25 LMatrix4f::get_class_type 0 1 1432 0
50
static TypeHandle LMatrix4f::get_class_type(void);

3184 10 ~LMatrix4f 0 4 3574 21 LMatrix4f::~LMatrix4f 0 0 0
28
LMatrix4f::~LMatrix4f(void);

3185 18 UnalignedLMatrix4f 0 4 3578 38 UnalignedLMatrix4f::UnalignedLMatrix4f 0 4 1442 1443 1444 1445 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
424
inline UnalignedLMatrix4f::UnalignedLMatrix4f(void);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(LMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(UnalignedLMatrix4f const &copy);
inline UnalignedLMatrix4f::UnalignedLMatrix4f(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3186 10 operator = 0 4 3578 30 UnalignedLMatrix4f::operator = 0 2 1446 1447 22
/**
 *
 */

/**
 *
 */
142
inline void UnalignedLMatrix4f::operator =(LMatrix4f const &copy);
inline void UnalignedLMatrix4f::operator =(UnalignedLMatrix4f const &copy);

3187 3 set 0 4 3578 23 UnalignedLMatrix4f::set 0 1 1448 10
/**
 *
 */
212
inline void UnalignedLMatrix4f::set(float e00, float e01, float e02, float e03, float e10, float e11, float e12, float e13, float e20, float e21, float e22, float e23, float e30, float e31, float e32, float e33);

3188 11 operator () 0 4 3578 31 UnalignedLMatrix4f::operator () 0 2 1449 1450 10
/**
 *
 */
134
inline float &UnalignedLMatrix4f::operator ()(int row, int col);
inline float UnalignedLMatrix4f::operator ()(int row, int col) const;

3189 8 get_data 0 4 3578 28 UnalignedLMatrix4f::get_data 0 1 1451 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
61
inline float const *UnalignedLMatrix4f::get_data(void) const;

3190 18 get_num_components 0 4 3578 38 UnalignedLMatrix4f::get_num_components 0 1 1452 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4f::get_num_components(void) const;

3191 11 operator == 0 4 3578 31 UnalignedLMatrix4f::operator == 0 1 1453 0
83
inline bool UnalignedLMatrix4f::operator ==(UnalignedLMatrix4f const &other) const;

3192 11 operator != 0 4 3578 31 UnalignedLMatrix4f::operator != 0 1 1454 0
83
inline bool UnalignedLMatrix4f::operator !=(UnalignedLMatrix4f const &other) const;

3193 14 get_class_type 0 4 3578 34 UnalignedLMatrix4f::get_class_type 0 1 1455 0
59
static TypeHandle UnalignedLMatrix4f::get_class_type(void);

3194 19 ~UnalignedLMatrix4f 0 4 3578 39 UnalignedLMatrix4f::~UnalignedLMatrix4f 0 0 0
46
UnalignedLMatrix4f::~UnalignedLMatrix4f(void);

3195 11 operator [] 0 4 3582 27 LMatrix3d::Row::operator [] 0 2 1558 1559 10
/**
 *
 */
106
inline double LMatrix3d::Row::operator [](int i) const;
inline double &LMatrix3d::Row::operator [](int i);

3196 4 size 0 4 3582 20 LMatrix3d::Row::size 0 1 1560 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
45
static inline int LMatrix3d::Row::size(void);

3197 17 operator typecast 0 132 3582 33 LMatrix3d::Row::operator typecast 0 1 1561 0
47
inline operator LVecBase3d const &(void) const;

3198 3 Row 0 4 3582 19 LMatrix3d::Row::Row 0 1 1557 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix3d::Row::Row(LMatrix3d::Row const &) = default;

3199 4 ~Row 0 4 3582 20 LMatrix3d::Row::~Row 0 0 0
27
LMatrix3d::Row::~Row(void);

3200 11 operator [] 0 4 3583 28 LMatrix3d::CRow::operator [] 0 1 1563 0
56
inline double LMatrix3d::CRow::operator [](int i) const;

3201 4 size 0 4 3583 21 LMatrix3d::CRow::size 0 1 1564 58
/**
 * Returns 3: the number of columns of a LMatrix3.
 */
46
static inline int LMatrix3d::CRow::size(void);

3202 17 operator typecast 0 132 3583 34 LMatrix3d::CRow::operator typecast 0 1 1565 0
47
inline operator LVecBase3d const &(void) const;

3203 4 CRow 0 4 3583 21 LMatrix3d::CRow::CRow 0 1 1562 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix3d::CRow::CRow(LMatrix3d::CRow const &) = default;

3204 5 ~CRow 0 4 3583 22 LMatrix3d::CRow::~CRow 0 0 0
29
LMatrix3d::CRow::~CRow(void);

3205 9 LMatrix3d 0 4 3580 20 LMatrix3d::LMatrix3d 0 4 1456 1457 1458 1459 96
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from three individual rows.
 */
286
inline LMatrix3d::LMatrix3d(void);
inline LMatrix3d::LMatrix3d(LMatrix3d const &other);
inline LMatrix3d::LMatrix3d(double , double , double , double , double , double , double , double , double );
inline LMatrix3d::LMatrix3d(LVecBase3d const &, LVecBase3d const &, LVecBase3d const &);

3206 10 operator = 0 4 3580 21 LMatrix3d::operator = 0 2 1460 1461 22
/**
 *
 */

/**
 *
 */
112
inline void LMatrix3d::operator =(LMatrix3d const &other);
inline void LMatrix3d::operator =(double fill_value);

3207 12 operator new 0 4 3580 23 LMatrix3d::operator new 0 1 1462 0
122
inline void *LMatrix3d::operator new(std::size_t size);
inline void *LMatrix3d::operator new(std::size_t size, void *ptr);

3208 15 operator delete 0 4 3580 26 LMatrix3d::operator delete 0 0 0
106
inline void LMatrix3d::operator delete(void *ptr);
inline void LMatrix3d::operator delete(void *, void *);

3209 12 validate_ptr 0 4 3580 23 LMatrix3d::validate_ptr 0 0 0
60
static inline bool LMatrix3d::validate_ptr(void const *ptr);

3210 10 __reduce__ 0 4 3580 21 LMatrix3d::__reduce__ 0 1 1463 0
61
inline PyObject *LMatrix3d::__reduce__(PyObject *self) const;

3211 4 fill 0 4 3580 15 LMatrix3d::fill 0 1 1464 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
40
void LMatrix3d::fill(double fill_value);

3212 3 set 0 4 3580 14 LMatrix3d::set 0 1 1465 10
/**
 *
 */
135
inline void LMatrix3d::set(double e00, double e01, double e02, double e10, double e11, double e12, double e20, double e21, double e22);

3213 11 operator [] 0 4 3580 22 LMatrix3d::operator [] 0 2 1466 1467 0
112
inline LMatrix3d::CRow LMatrix3d::operator [](int i) const;
inline LMatrix3d::Row LMatrix3d::operator [](int i);

3214 4 size 0 4 3580 15 LMatrix3d::size 0 1 1468 55
/**
 * Returns 3: the number of rows of a LMatrix3.
 */
40
static inline int LMatrix3d::size(void);

3215 7 set_row 0 4 3580 18 LMatrix3d::set_row 0 2 1469 1470 193
/**
 * Replaces the indicated row of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */
123
inline void LMatrix3d::set_row(int row, LVecBase3d const &v);
inline void LMatrix3d::set_row(int row, LVecBase2d const &v);

3216 7 set_col 0 4 3580 18 LMatrix3d::set_col 0 2 1471 1472 196
/**
 * Replaces the indicated column of the matrix from a three-component vector.
 */

/**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */
123
inline void LMatrix3d::set_col(int col, LVecBase3d const &v);
inline void LMatrix3d::set_col(int col, LVecBase2d const &v);

3217 7 get_row 0 4 3580 18 LMatrix3d::get_row 0 2 1473 1474 192
// these versions inline better

/**
 * Returns the indicated row of the matrix as a three-component vector.
 */

/**
 * Stores the indicated row of the matrix as a three-component vector.
 */
123
inline LVecBase3d LMatrix3d::get_row(int row) const;
inline void LMatrix3d::get_row(LVecBase3d &result_vec, int row) const;

3218 7 get_col 0 4 3580 18 LMatrix3d::get_col 0 1 1475 82
/**
 * Returns the indicated column of the matrix as a three-component vector.
 */
52
inline LVecBase3d LMatrix3d::get_col(int col) const;

3219 0 0 0 0 0 0 0 0
0

3220 0 0 0 0 0 0 0 0
0

3221 8 get_row2 0 4 3580 19 LMatrix3d::get_row2 0 1 1476 106
/**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */
53
inline LVecBase2d LMatrix3d::get_row2(int row) const;

3222 8 get_col2 0 4 3580 19 LMatrix3d::get_col2 0 1 1477 106
/**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */
53
inline LVecBase2d LMatrix3d::get_col2(int col) const;

3223 11 operator () 0 4 3580 22 LMatrix3d::operator () 0 2 1478 1479 10
/**
 *
 */
118
inline double &LMatrix3d::operator ()(int row, int col);
inline double LMatrix3d::operator ()(int row, int col) const;

3224 6 is_nan 0 4 3580 17 LMatrix3d::is_nan 0 1 1480 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix3d::is_nan(void) const;

3225 11 is_identity 0 4 3580 22 LMatrix3d::is_identity 0 1 1481 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix3d::is_identity(void) const;

3226 8 get_cell 0 4 3580 19 LMatrix3d::get_cell 0 1 1482 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix3d::get_cell(int row, int col) const;

3227 8 set_cell 0 4 3580 19 LMatrix3d::set_cell 0 1 1483 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix3d::set_cell(int row, int col, double value);

3228 8 get_data 0 4 3580 19 LMatrix3d::get_data 0 1 1484 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix3d::get_data(void) const;

3229 18 get_num_components 0 4 3580 29 LMatrix3d::get_num_components 0 1 1485 62
/**
 * Returns the number of elements in the matrix, nine.
 */
53
inline int LMatrix3d::get_num_components(void) const;

3230 10 operator < 0 4 3580 21 LMatrix3d::operator < 0 1 1486 0
64
inline bool LMatrix3d::operator <(LMatrix3d const &other) const;

3231 11 operator == 0 4 3580 22 LMatrix3d::operator == 0 1 1487 0
65
inline bool LMatrix3d::operator ==(LMatrix3d const &other) const;

3232 11 operator != 0 4 3580 22 LMatrix3d::operator != 0 1 1488 0
65
inline bool LMatrix3d::operator !=(LMatrix3d const &other) const;

3233 10 compare_to 0 4 3580 21 LMatrix3d::compare_to 0 2 1489 1490 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix3d::compare_to(LMatrix3d const &other) const;
int LMatrix3d::compare_to(LMatrix3d const &other, double threshold) const;

3234 8 get_hash 0 4 3580 19 LMatrix3d::get_hash 0 2 1491 1492 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix3d::get_hash(void) const;
inline std::size_t LMatrix3d::get_hash(double threshold) const;

3235 8 add_hash 0 4 3580 19 LMatrix3d::add_hash 0 2 1493 1494 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix3d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix3d::add_hash(std::size_t hash, double threshold) const;

3236 5 xform 0 4 3580 16 LMatrix3d::xform 0 1 1495 52
/**
 * 3-component vector or point times matrix.
 */
62
inline LVecBase3d LMatrix3d::xform(LVecBase3d const &v) const;

3237 11 xform_point 0 4 3580 22 LMatrix3d::xform_point 0 1 1496 162
/**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase2d LMatrix3d::xform_point(LVecBase2d const &v) const;

3238 9 xform_vec 0 4 3580 20 LMatrix3d::xform_vec 0 2 1497 1498 357
/**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
133
inline LVecBase2d LMatrix3d::xform_vec(LVecBase2d const &v) const;
inline LVecBase3d LMatrix3d::xform_vec(LVecBase3d const &v) const;

3239 17 xform_vec_general 0 4 3580 28 LMatrix3d::xform_vec_general 0 1 1499 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix3d::xform_vec_general(LVecBase3d const &v) const;

3240 14 xform_in_place 0 4 3580 25 LMatrix3d::xform_in_place 0 1 1500 52
/**
 * 3-component vector or point times matrix.
 */
59
inline void LMatrix3d::xform_in_place(LVecBase3d &v) const;

3241 20 xform_point_in_place 0 4 3580 31 LMatrix3d::xform_point_in_place 0 1 1501 139
/**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix3d::xform_point_in_place(LVecBase2d &v) const;

3242 18 xform_vec_in_place 0 4 3580 29 LMatrix3d::xform_vec_in_place 0 2 1502 1503 310
/**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */

/**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */
127
inline void LMatrix3d::xform_vec_in_place(LVecBase2d &v) const;
inline void LMatrix3d::xform_vec_in_place(LVecBase3d &v) const;

3243 26 xform_vec_general_in_place 0 4 3580 37 LMatrix3d::xform_vec_general_in_place 0 1 1504 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix3d::xform_vec_general_in_place(LVecBase3d &v) const;

3244 8 multiply 0 4 3580 19 LMatrix3d::multiply 0 1 1505 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix3d::multiply(LMatrix3d const &other1, LMatrix3d const &other2);

3245 10 operator * 0 4 3580 21 LMatrix3d::operator * 0 2 1506 1507 0
130
inline LMatrix3d LMatrix3d::operator *(LMatrix3d const &other) const;
inline LMatrix3d LMatrix3d::operator *(double scalar) const;

3246 10 operator / 0 4 3580 21 LMatrix3d::operator / 0 1 1508 0
60
inline LMatrix3d LMatrix3d::operator /(double scalar) const;

3247 11 operator += 0 4 3580 22 LMatrix3d::operator += 0 1 1509 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator +=(LMatrix3d const &other);

3248 11 operator -= 0 4 3580 22 LMatrix3d::operator -= 0 1 1510 66
/**
 * Performs a memberwise subtraction between two matrices.
 */
65
inline LMatrix3d &LMatrix3d::operator -=(LMatrix3d const &other);

3249 11 operator *= 0 4 3580 22 LMatrix3d::operator *= 0 2 1511 1512 51
/**
 *
 */

/**
 * Performs a memberwise scale.
 */
122
inline LMatrix3d &LMatrix3d::operator *=(LMatrix3d const &other);
inline LMatrix3d &LMatrix3d::operator *=(double scalar);

3250 11 operator /= 0 4 3580 22 LMatrix3d::operator /= 0 1 1513 39
/**
 * Performs a memberwise scale.
 */
56
inline LMatrix3d &LMatrix3d::operator /=(double scalar);

3251 18 componentwise_mult 0 4 3580 29 LMatrix3d::componentwise_mult 0 1 1514 10
/**
 *
 */
66
inline void LMatrix3d::componentwise_mult(LMatrix3d const &other);

3252 11 determinant 0 4 3580 22 LMatrix3d::determinant 0 1 1515 49
/**
 * Returns the determinant of the matrix.
 */
49
inline double LMatrix3d::determinant(void) const;

3253 14 transpose_from 0 4 3580 25 LMatrix3d::transpose_from 0 1 1516 10
/**
 *
 */
62
inline void LMatrix3d::transpose_from(LMatrix3d const &other);

3254 18 transpose_in_place 0 4 3580 29 LMatrix3d::transpose_in_place 0 1 1517 10
/**
 *
 */
48
inline void LMatrix3d::transpose_in_place(void);

3255 11 invert_from 0 4 3580 22 LMatrix3d::invert_from 0 1 1518 463
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */
59
inline bool LMatrix3d::invert_from(LMatrix3d const &other);

3256 15 invert_in_place 0 4 3580 26 LMatrix3d::invert_in_place 0 1 1519 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix3d::invert_in_place(void);

3257 21 invert_transpose_from 0 4 3580 32 LMatrix3d::invert_transpose_from 0 2 1520 1521 230
/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */

/**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */
139
inline bool LMatrix3d::invert_transpose_from(LMatrix3d const &other);
inline bool LMatrix3d::invert_transpose_from(LMatrix4d const &other);

3258 9 ident_mat 0 4 3580 20 LMatrix3d::ident_mat 0 1 1522 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix3d const &LMatrix3d::ident_mat(void);

3259 17 set_translate_mat 0 4 3580 28 LMatrix3d::set_translate_mat 0 1 1523 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix3d::set_translate_mat(LVecBase2d const &trans);

3260 14 set_rotate_mat 0 4 3580 25 LMatrix3d::set_rotate_mat 0 2 1524 1525 225
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
158
inline void LMatrix3d::set_rotate_mat(double angle);
void LMatrix3d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3261 13 set_scale_mat 0 4 3580 24 LMatrix3d::set_scale_mat 0 2 1526 1527 194
/**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */

/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
125
inline void LMatrix3d::set_scale_mat(LVecBase2d const &scale);
inline void LMatrix3d::set_scale_mat(LVecBase3d const &scale);

3262 13 translate_mat 0 4 3580 24 LMatrix3d::translate_mat 0 2 1528 1529 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
146
static inline LMatrix3d LMatrix3d::translate_mat(LVecBase2d const &trans);
static inline LMatrix3d LMatrix3d::translate_mat(double tx, double ty);

3263 10 rotate_mat 0 4 3580 21 LMatrix3d::rotate_mat 0 2 1530 1531 211
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */

/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
181
static inline LMatrix3d LMatrix3d::rotate_mat(double angle);
static inline LMatrix3d LMatrix3d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3264 9 scale_mat 0 4 3580 20 LMatrix3d::scale_mat 0 4 1532 1533 1534 1535 356
/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */
288
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase2d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy);
static inline LMatrix3d LMatrix3d::scale_mat(LVecBase3d const &scale);
static inline LMatrix3d LMatrix3d::scale_mat(double sx, double sy, double sz);

3265 23 set_rotate_mat_normaxis 0 4 3580 34 LMatrix3d::set_rotate_mat_normaxis 0 1 1536 163
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
114
void LMatrix3d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3266 19 rotate_mat_normaxis 0 4 3580 30 LMatrix3d::rotate_mat_normaxis 0 1 1537 156
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */
129
static inline LMatrix3d LMatrix3d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3267 13 set_shear_mat 0 4 3580 24 LMatrix3d::set_shear_mat 0 1 1538 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix3d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3268 9 shear_mat 0 4 3580 20 LMatrix3d::shear_mat 0 2 1539 1540 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix3d LMatrix3d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3269 19 set_scale_shear_mat 0 4 3580 30 LMatrix3d::set_scale_shear_mat 0 1 1541 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
122
void LMatrix3d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3270 15 scale_shear_mat 0 4 3580 26 LMatrix3d::scale_shear_mat 0 2 1542 1543 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix3d LMatrix3d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix3d LMatrix3d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3271 11 convert_mat 0 4 3580 22 LMatrix3d::convert_mat 0 1 1544 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix3d const &LMatrix3d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3272 12 almost_equal 0 4 3580 23 LMatrix3d::almost_equal 0 2 1545 1546 212
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */
144
bool LMatrix3d::almost_equal(LMatrix3d const &other, double threshold) const;
inline bool LMatrix3d::almost_equal(LMatrix3d const &other) const;

3273 6 output 0 4 3580 17 LMatrix3d::output 0 1 1547 10
/**
 *
 */
48
void LMatrix3d::output(std::ostream &out) const;

3274 5 write 0 4 3580 16 LMatrix3d::write 0 1 1548 10
/**
 *
 */
69
void LMatrix3d::write(std::ostream &out, int indent_level = 0) const;

3275 8 __repr__ 0 4 3580 19 LMatrix3d::__repr__ 0 1 1549 0
51
inline std::string LMatrix3d::__repr__(void) const;

3276 13 generate_hash 0 4 3580 24 LMatrix3d::generate_hash 0 2 1550 1551 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
162
inline void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix3d::generate_hash(ChecksumHashGenerator &hashgen, double threshold) const;

3277 20 write_datagram_fixed 0 4 3580 31 LMatrix3d::write_datagram_fixed 0 1 1552 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix3d::write_datagram_fixed(Datagram &destination) const;

3278 19 read_datagram_fixed 0 4 3580 30 LMatrix3d::read_datagram_fixed 0 1 1553 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix3d::read_datagram_fixed(DatagramIterator &scan);

3279 14 write_datagram 0 4 3580 25 LMatrix3d::write_datagram 0 1 1554 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix3d::write_datagram(Datagram &destination) const;

3280 13 read_datagram 0 4 3580 24 LMatrix3d::read_datagram 0 1 1555 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix3d::read_datagram(DatagramIterator &source);

3281 14 get_class_type 0 4 3580 25 LMatrix3d::get_class_type 0 1 1556 0
50
static TypeHandle LMatrix3d::get_class_type(void);

3282 10 ~LMatrix3d 0 4 3580 21 LMatrix3d::~LMatrix3d 0 0 0
28
LMatrix3d::~LMatrix3d(void);

3283 11 operator [] 0 4 3586 27 LMatrix4d::Row::operator [] 0 2 1678 1679 10
/**
 *
 */
106
inline double LMatrix4d::Row::operator [](int i) const;
inline double &LMatrix4d::Row::operator [](int i);

3284 4 size 0 4 3586 20 LMatrix4d::Row::size 0 1 1680 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
45
static inline int LMatrix4d::Row::size(void);

3285 17 operator typecast 0 132 3586 33 LMatrix4d::Row::operator typecast 0 1 1681 0
47
inline operator LVecBase4d const &(void) const;

3286 3 Row 0 4 3586 19 LMatrix4d::Row::Row 0 1 1677 60
/**
 * Defines a row-level index accessor to the matrix.
 */
61
inline LMatrix4d::Row::Row(LMatrix4d::Row const &) = default;

3287 4 ~Row 0 4 3586 20 LMatrix4d::Row::~Row 0 0 0
27
LMatrix4d::Row::~Row(void);

3288 11 operator [] 0 4 3587 28 LMatrix4d::CRow::operator [] 0 1 1683 0
56
inline double LMatrix4d::CRow::operator [](int i) const;

3289 4 size 0 4 3587 21 LMatrix4d::CRow::size 0 1 1684 58
/**
 * Returns 4: the number of columns of a LMatrix4.
 */
46
static inline int LMatrix4d::CRow::size(void);

3290 17 operator typecast 0 132 3587 34 LMatrix4d::CRow::operator typecast 0 1 1685 0
47
inline operator LVecBase4d const &(void) const;

3291 4 CRow 0 4 3587 21 LMatrix4d::CRow::CRow 0 1 1682 63
/**
 * Defines a row-level constant accessor to the matrix.
 */
64
inline LMatrix4d::CRow::CRow(LMatrix4d::CRow const &) = default;

3292 5 ~CRow 0 4 3587 22 LMatrix4d::CRow::~CRow 0 0 0
29
LMatrix4d::CRow::~CRow(void);

3293 9 LMatrix4d 0 4 3584 20 LMatrix4d::LMatrix4d 0 7 1566 1567 1568 1569 1570 1571 1572 228
// Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component.

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * Constructs the matrix from four individual rows.
 */

/**
 *
 */

/**
 *
 */
564
inline LMatrix4d::LMatrix4d(void);
inline LMatrix4d::LMatrix4d(LMatrix4d const &other);
inline LMatrix4d::LMatrix4d(UnalignedLMatrix4d const &other);
inline LMatrix4d::LMatrix4d(double , double , double , double , double , double , double , double , double , double , double , double , double , double , double , double );
inline LMatrix4d::LMatrix4d(LVecBase4d const &, LVecBase4d const &, LVecBase4d const &, LVecBase4d const &);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3);
inline LMatrix4d::LMatrix4d(LMatrix3d const &upper3, LVecBase3d const &trans);

3294 10 operator = 0 4 3584 21 LMatrix4d::operator = 0 3 1573 1574 1575 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
180
inline void LMatrix4d::operator =(LMatrix4d const &other);
inline void LMatrix4d::operator =(UnalignedLMatrix4d const &other);
inline void LMatrix4d::operator =(double fill_value);

3295 12 operator new 0 4 3584 23 LMatrix4d::operator new 0 1 1576 0
122
inline void *LMatrix4d::operator new(std::size_t size);
inline void *LMatrix4d::operator new(std::size_t size, void *ptr);

3296 15 operator delete 0 4 3584 26 LMatrix4d::operator delete 0 0 0
106
inline void LMatrix4d::operator delete(void *ptr);
inline void LMatrix4d::operator delete(void *, void *);

3297 12 validate_ptr 0 4 3584 23 LMatrix4d::validate_ptr 0 0 0
60
static inline bool LMatrix4d::validate_ptr(void const *ptr);

3298 10 __reduce__ 0 4 3584 21 LMatrix4d::__reduce__ 0 1 1577 0
61
inline PyObject *LMatrix4d::__reduce__(PyObject *self) const;

3299 4 fill 0 4 3584 15 LMatrix4d::fill 0 1 1578 157
/**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */
47
inline void LMatrix4d::fill(double fill_value);

3300 3 set 0 4 3584 14 LMatrix4d::set 0 1 1579 10
/**
 *
 */
219
inline void LMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3301 11 set_upper_3 0 4 3584 22 LMatrix4d::set_upper_3 0 1 1580 87
// Get and set the upper 3x3 rotation matrix.

/**
 * Sets the upper 3x3 submatrix.
 */
60
inline void LMatrix4d::set_upper_3(LMatrix3d const &upper3);

3302 11 get_upper_3 0 4 3584 22 LMatrix4d::get_upper_3 0 1 1581 45
/**
 * Retrieves the upper 3x3 submatrix.
 */
52
inline LMatrix3d LMatrix4d::get_upper_3(void) const;

3303 11 operator [] 0 4 3584 22 LMatrix4d::operator [] 0 2 1582 1583 0
112
inline LMatrix4d::CRow LMatrix4d::operator [](int i) const;
inline LMatrix4d::Row LMatrix4d::operator [](int i);

3304 4 size 0 4 3584 15 LMatrix4d::size 0 1 1584 55
/**
 * Returns 4: the number of rows of a LMatrix4.
 */
40
static inline int LMatrix4d::size(void);

3305 7 set_row 0 4 3584 18 LMatrix4d::set_row 0 2 1585 1586 173
/**
 * Replaces the indicated row of the matrix.
 */

/**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */
123
inline void LMatrix4d::set_row(int row, LVecBase4d const &v);
inline void LMatrix4d::set_row(int row, LVecBase3d const &v);

3306 7 set_col 0 4 3584 18 LMatrix4d::set_col 0 2 1587 1588 176
/**
 * Replaces the indicated column of the matrix.
 */

/**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */
123
inline void LMatrix4d::set_col(int col, LVecBase4d const &v);
inline void LMatrix4d::set_col(int col, LVecBase3d const &v);

3307 7 get_row 0 4 3584 18 LMatrix4d::get_row 0 2 1589 1590 186
// these versions inline better

/**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */

/**
 * Stores the indicated row of the matrix as a 4-component vector.
 */
123
inline LVecBase4d LMatrix4d::get_row(int row) const;
inline void LMatrix4d::get_row(LVecBase4d &result_vec, int row) const;

3308 7 get_col 0 4 3584 18 LMatrix4d::get_col 0 1 1591 80
/**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */
52
inline LVecBase4d LMatrix4d::get_col(int col) const;

3309 8 get_row3 0 4 3584 19 LMatrix4d::get_row3 0 2 1592 1593 205
/**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */

/**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */
125
inline LVecBase3d LMatrix4d::get_row3(int row) const;
inline void LMatrix4d::get_row3(LVecBase3d &result_vec, int row) const;

3310 0 0 0 0 0 0 0 0
0

3311 0 0 0 0 0 0 0 0
0

3312 8 get_col3 0 4 3584 19 LMatrix4d::get_col3 0 1 1594 106
/**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */
53
inline LVecBase3d LMatrix4d::get_col3(int col) const;

3313 11 operator () 0 4 3584 22 LMatrix4d::operator () 0 2 1595 1596 10
/**
 *
 */
118
inline double &LMatrix4d::operator ()(int row, int col);
inline double LMatrix4d::operator ()(int row, int col) const;

3314 6 is_nan 0 4 3584 17 LMatrix4d::is_nan 0 1 1597 91
/**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */
42
inline bool LMatrix4d::is_nan(void) const;

3315 11 is_identity 0 4 3584 22 LMatrix4d::is_identity 0 1 1598 93
/**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */
47
inline bool LMatrix4d::is_identity(void) const;

3316 8 get_cell 0 4 3584 19 LMatrix4d::get_cell 0 1 1599 54
/**
 * Returns a particular element of the matrix.
 */
58
inline double LMatrix4d::get_cell(int row, int col) const;

3317 8 set_cell 0 4 3584 19 LMatrix4d::set_cell 0 1 1600 54
/**
 * Changes a particular element of the matrix.
 */
64
inline void LMatrix4d::set_cell(int row, int col, double value);

3318 8 get_data 0 4 3584 19 LMatrix4d::get_data 0 1 1601 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
53
inline double const *LMatrix4d::get_data(void) const;

3319 18 get_num_components 0 4 3584 29 LMatrix4d::get_num_components 0 1 1602 60
/**
 * Returns the number of elements in the matrix, 16.
 */
53
inline int LMatrix4d::get_num_components(void) const;

3320 5 begin 0 4 3584 16 LMatrix4d::begin 0 2 1603 1604 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
113
inline LMatrix4d::iterator LMatrix4d::begin(void);
inline LMatrix4d::const_iterator LMatrix4d::begin(void) const;

3321 3 end 0 4 3584 14 LMatrix4d::end 0 2 1605 1606 204
/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */

/**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */
109
inline LMatrix4d::iterator LMatrix4d::end(void);
inline LMatrix4d::const_iterator LMatrix4d::end(void) const;

3322 10 operator < 0 4 3584 21 LMatrix4d::operator < 0 1 1607 0
64
inline bool LMatrix4d::operator <(LMatrix4d const &other) const;

3323 11 operator == 0 4 3584 22 LMatrix4d::operator == 0 1 1608 0
65
inline bool LMatrix4d::operator ==(LMatrix4d const &other) const;

3324 11 operator != 0 4 3584 22 LMatrix4d::operator != 0 1 1609 0
65
inline bool LMatrix4d::operator !=(LMatrix4d const &other) const;

3325 10 compare_to 0 4 3584 21 LMatrix4d::compare_to 0 2 1610 1611 333
/**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */

/**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */
138
inline int LMatrix4d::compare_to(LMatrix4d const &other) const;
int LMatrix4d::compare_to(LMatrix4d const &other, double threshold) const;

3326 8 get_hash 0 4 3584 19 LMatrix4d::get_hash 0 2 1612 1613 100
/**
 * Returns a suitable hash for phash_map.
 */

/**
 * Returns a suitable hash for phash_map.
 */
115
inline std::size_t LMatrix4d::get_hash(void) const;
inline std::size_t LMatrix4d::get_hash(double threshold) const;

3327 8 add_hash 0 4 3584 19 LMatrix4d::add_hash 0 2 1614 1615 100
/**
 * Adds the vector into the running hash.
 */

/**
 * Adds the vector into the running hash.
 */
145
inline std::size_t LMatrix4d::add_hash(std::size_t hash) const;
inline std::size_t LMatrix4d::add_hash(std::size_t hash, double threshold) const;

3328 5 xform 0 4 3584 16 LMatrix4d::xform 0 1 1616 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
62
inline LVecBase4d LMatrix4d::xform(LVecBase4d const &v) const;

3329 11 xform_point 0 4 3584 22 LMatrix4d::xform_point 0 1 1617 162
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */
68
inline LVecBase3d LMatrix4d::xform_point(LVecBase3d const &v) const;

3330 19 xform_point_general 0 4 3584 30 LMatrix4d::xform_point_general 0 1 1618 143
/**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */
76
inline LVecBase3d LMatrix4d::xform_point_general(LVecBase3d const &v) const;

3331 9 xform_vec 0 4 3584 20 LMatrix4d::xform_vec 0 1 1619 169
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */
66
inline LVecBase3d LMatrix4d::xform_vec(LVecBase3d const &v) const;

3332 17 xform_vec_general 0 4 3584 28 LMatrix4d::xform_vec_general 0 1 1620 142
/**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */
74
inline LVecBase3d LMatrix4d::xform_vec_general(LVecBase3d const &v) const;

3333 14 xform_in_place 0 4 3584 25 LMatrix4d::xform_in_place 0 1 1621 91
/**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */
59
inline void LMatrix4d::xform_in_place(LVecBase4d &v) const;

3334 20 xform_point_in_place 0 4 3584 31 LMatrix4d::xform_point_in_place 0 1 1622 139
/**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */
65
inline void LMatrix4d::xform_point_in_place(LVecBase3d &v) const;

3335 28 xform_point_general_in_place 0 4 3584 39 LMatrix4d::xform_point_general_in_place 0 1 1623 120
/**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */
73
inline void LMatrix4d::xform_point_general_in_place(LVecBase3d &v) const;

3336 18 xform_vec_in_place 0 4 3584 29 LMatrix4d::xform_vec_in_place 0 1 1624 142
/**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */
63
inline void LMatrix4d::xform_vec_in_place(LVecBase3d &v) const;

3337 26 xform_vec_general_in_place 0 4 3584 37 LMatrix4d::xform_vec_general_in_place 0 1 1625 119
/**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */
71
inline void LMatrix4d::xform_vec_general_in_place(LVecBase3d &v) const;

3338 8 multiply 0 4 3584 19 LMatrix4d::multiply 0 1 1626 52
// this = other1 * other2

// this = other1 * other2
82
inline void LMatrix4d::multiply(LMatrix4d const &other1, LMatrix4d const &other2);

3339 10 operator * 0 4 3584 21 LMatrix4d::operator * 0 2 1627 1628 0
130
inline LMatrix4d LMatrix4d::operator *(LMatrix4d const &other) const;
inline LMatrix4d LMatrix4d::operator *(double scalar) const;

3340 10 operator / 0 4 3584 21 LMatrix4d::operator / 0 1 1629 0
60
inline LMatrix4d LMatrix4d::operator /(double scalar) const;

3341 11 operator += 0 4 3584 22 LMatrix4d::operator += 0 1 1630 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator +=(LMatrix4d const &other);

3342 11 operator -= 0 4 3584 22 LMatrix4d::operator -= 0 1 1631 63
/**
 * Performs a memberwise addition between two matrices.
 */
65
inline LMatrix4d &LMatrix4d::operator -=(LMatrix4d const &other);

3343 11 operator *= 0 4 3584 22 LMatrix4d::operator *= 0 2 1632 1633 22
/**
 *
 */

/**
 *
 */
122
inline LMatrix4d &LMatrix4d::operator *=(LMatrix4d const &other);
inline LMatrix4d &LMatrix4d::operator *=(double scalar);

3344 11 operator /= 0 4 3584 22 LMatrix4d::operator /= 0 1 1634 10
/**
 *
 */
56
inline LMatrix4d &LMatrix4d::operator /=(double scalar);

3345 18 componentwise_mult 0 4 3584 29 LMatrix4d::componentwise_mult 0 1 1635 10
/**
 *
 */
66
inline void LMatrix4d::componentwise_mult(LMatrix4d const &other);

3346 14 transpose_from 0 4 3584 25 LMatrix4d::transpose_from 0 1 1636 10
/**
 *
 */
62
inline void LMatrix4d::transpose_from(LMatrix4d const &other);

3347 18 transpose_in_place 0 4 3584 29 LMatrix4d::transpose_in_place 0 1 1637 10
/**
 *
 */
48
inline void LMatrix4d::transpose_in_place(void);

3348 11 invert_from 0 4 3584 22 LMatrix4d::invert_from 0 1 1638 461
/**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */
59
inline bool LMatrix4d::invert_from(LMatrix4d const &other);

3349 18 invert_affine_from 0 4 3584 29 LMatrix4d::invert_affine_from 0 1 1639 139
// bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component)
66
inline bool LMatrix4d::invert_affine_from(LMatrix4d const &other);

3350 15 invert_in_place 0 4 3584 26 LMatrix4d::invert_in_place 0 1 1640 119
/**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */
45
inline bool LMatrix4d::invert_in_place(void);

3351 10 accumulate 0 4 3584 21 LMatrix4d::accumulate 0 1 1641 46
/**
 * Computes (*this) += other * weight.
 */
73
inline void LMatrix4d::accumulate(LMatrix4d const &other, double weight);

3352 9 ident_mat 0 4 3584 20 LMatrix4d::ident_mat 0 1 1642 147
/**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */
58
static inline LMatrix4d const &LMatrix4d::ident_mat(void);

3353 8 ones_mat 0 4 3584 19 LMatrix4d::ones_mat 0 1 1643 46
/**
 * Returns an matrix filled with ones.
 */
57
static inline LMatrix4d const &LMatrix4d::ones_mat(void);

3354 9 zeros_mat 0 4 3584 20 LMatrix4d::zeros_mat 0 1 1644 47
/**
 * Returns an matrix filled with zeros.
 */
58
static inline LMatrix4d const &LMatrix4d::zeros_mat(void);

3355 17 set_translate_mat 0 4 3584 28 LMatrix4d::set_translate_mat 0 1 1645 74
/**
 * Fills mat with a matrix that applies the indicated translation.
 */
66
inline void LMatrix4d::set_translate_mat(LVecBase3d const &trans);

3356 14 set_rotate_mat 0 4 3584 25 LMatrix4d::set_rotate_mat 0 1 1646 122
/**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
105
void LMatrix4d::set_rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3357 23 set_rotate_mat_normaxis 0 4 3584 34 LMatrix4d::set_rotate_mat_normaxis 0 1 1647 166
/**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
114
void LMatrix4d::set_rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3358 13 set_scale_mat 0 4 3584 24 LMatrix4d::set_scale_mat 0 1 1648 97
/**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */
62
inline void LMatrix4d::set_scale_mat(LVecBase3d const &scale);

3359 13 set_shear_mat 0 4 3584 24 LMatrix4d::set_shear_mat 0 1 1649 99
/**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */
98
inline void LMatrix4d::set_shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3360 19 set_scale_shear_mat 0 4 3584 30 LMatrix4d::set_scale_shear_mat 0 1 1650 78
/**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */
129
inline void LMatrix4d::set_scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);

3361 13 translate_mat 0 4 3584 24 LMatrix4d::translate_mat 0 2 1651 1652 136
/**
 * Returns a matrix that applies the indicated translation.
 */

/**
 * Returns a matrix that applies the indicated translation.
 */
157
static inline LMatrix4d LMatrix4d::translate_mat(LVecBase3d const &trans);
static inline LMatrix4d LMatrix4d::translate_mat(double tx, double ty, double tz);

3362 10 rotate_mat 0 4 3584 21 LMatrix4d::rotate_mat 0 1 1653 118
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */
120
static inline LMatrix4d LMatrix4d::rotate_mat(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3363 19 rotate_mat_normaxis 0 4 3584 30 LMatrix4d::rotate_mat_normaxis 0 1 1654 159
/**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */
129
static inline LMatrix4d LMatrix4d::rotate_mat_normaxis(double angle, LVecBase3d const &axis, CoordinateSystem cs = ::CS_default);

3364 9 scale_mat 0 4 3584 20 LMatrix4d::scale_mat 0 3 1655 1656 1657 253
/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */

/**
 * Returns a matrix that applies the indicated uniform scale.
 */
209
static inline LMatrix4d LMatrix4d::scale_mat(LVecBase3d const &scale);
static inline LMatrix4d LMatrix4d::scale_mat(double sx, double sy, double sz);
static inline LMatrix4d LMatrix4d::scale_mat(double scale);

3365 9 shear_mat 0 4 3584 20 LMatrix4d::shear_mat 0 2 1658 1659 186
/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */

/**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */
227
static inline LMatrix4d LMatrix4d::shear_mat(LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::shear_mat(double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3366 15 scale_shear_mat 0 4 3584 26 LMatrix4d::scale_shear_mat 0 2 1660 1661 144
/**
 * Returns a matrix that applies the indicated scale and shear.
 */

/**
 * Returns a matrix that applies the indicated scale and shear.
 */
297
static inline LMatrix4d LMatrix4d::scale_shear_mat(LVecBase3d const &scale, LVecBase3d const &shear, CoordinateSystem cs = ::CS_default);
static inline LMatrix4d LMatrix4d::scale_shear_mat(double sx, double sy, double sz, double shxy, double shxz, double shyz, CoordinateSystem cs = ::CS_default);

3367 13 y_to_z_up_mat 0 4 3584 24 LMatrix4d::y_to_z_up_mat 0 1 1662 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::y_to_z_up_mat(void);

3368 13 z_to_y_up_mat 0 4 3584 24 LMatrix4d::z_to_y_up_mat 0 1 1663 109
/**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */
62
static inline LMatrix4d const &LMatrix4d::z_to_y_up_mat(void);

3369 11 convert_mat 0 4 3584 22 LMatrix4d::convert_mat 0 1 1664 119
/**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */
91
static LMatrix4d const &LMatrix4d::convert_mat(CoordinateSystem from, CoordinateSystem to);

3370 12 almost_equal 0 4 3584 23 LMatrix4d::almost_equal 0 2 1665 1666 318
/**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */
144
bool LMatrix4d::almost_equal(LMatrix4d const &other, double threshold) const;
inline bool LMatrix4d::almost_equal(LMatrix4d const &other) const;

3371 6 output 0 4 3584 17 LMatrix4d::output 0 1 1667 10
/**
 *
 */
48
void LMatrix4d::output(std::ostream &out) const;

3372 5 write 0 4 3584 16 LMatrix4d::write 0 1 1668 10
/**
 *
 */
69
void LMatrix4d::write(std::ostream &out, int indent_level = 0) const;

3373 8 __repr__ 0 4 3584 19 LMatrix4d::__repr__ 0 1 1669 0
51
inline std::string LMatrix4d::__repr__(void) const;

3374 13 generate_hash 0 4 3584 24 LMatrix4d::generate_hash 0 2 1670 1671 120
/**
 * Adds the vector to the indicated hash generator.
 */

/**
 * Adds the vector to the indicated hash generator.
 */
158
inline void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen) const;
void LMatrix4d::generate_hash(ChecksumHashGenerator &hashgen, double scale) const;

3375 20 write_datagram_fixed 0 4 3584 31 LMatrix4d::write_datagram_fixed 0 1 1672 332
/**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */
66
void LMatrix4d::write_datagram_fixed(Datagram &destination) const;

3376 19 read_datagram_fixed 0 4 3584 30 LMatrix4d::read_datagram_fixed 0 1 1673 114
/**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */
60
void LMatrix4d::read_datagram_fixed(DatagramIterator &scan);

3377 14 write_datagram 0 4 3584 25 LMatrix4d::write_datagram 0 1 1674 205
/**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */
60
void LMatrix4d::write_datagram(Datagram &destination) const;

3378 13 read_datagram 0 4 3584 24 LMatrix4d::read_datagram 0 1 1675 67
/**
 * Reads the matrix from the Datagram using get_stdfloat().
 */
56
void LMatrix4d::read_datagram(DatagramIterator &source);

3379 14 get_class_type 0 4 3584 25 LMatrix4d::get_class_type 0 1 1676 0
50
static TypeHandle LMatrix4d::get_class_type(void);

3380 10 ~LMatrix4d 0 4 3584 21 LMatrix4d::~LMatrix4d 0 0 0
28
LMatrix4d::~LMatrix4d(void);

3381 18 UnalignedLMatrix4d 0 4 3588 38 UnalignedLMatrix4d::UnalignedLMatrix4d 0 4 1686 1687 1688 1689 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
440
inline UnalignedLMatrix4d::UnalignedLMatrix4d(void);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(LMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(UnalignedLMatrix4d const &copy);
inline UnalignedLMatrix4d::UnalignedLMatrix4d(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3382 10 operator = 0 4 3588 30 UnalignedLMatrix4d::operator = 0 2 1690 1691 22
/**
 *
 */

/**
 *
 */
142
inline void UnalignedLMatrix4d::operator =(LMatrix4d const &copy);
inline void UnalignedLMatrix4d::operator =(UnalignedLMatrix4d const &copy);

3383 3 set 0 4 3588 23 UnalignedLMatrix4d::set 0 1 1692 10
/**
 *
 */
228
inline void UnalignedLMatrix4d::set(double e00, double e01, double e02, double e03, double e10, double e11, double e12, double e13, double e20, double e21, double e22, double e23, double e30, double e31, double e32, double e33);

3384 11 operator () 0 4 3588 31 UnalignedLMatrix4d::operator () 0 2 1693 1694 10
/**
 *
 */
136
inline double &UnalignedLMatrix4d::operator ()(int row, int col);
inline double UnalignedLMatrix4d::operator ()(int row, int col) const;

3385 8 get_data 0 4 3588 28 UnalignedLMatrix4d::get_data 0 1 1695 162
/**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */
62
inline double const *UnalignedLMatrix4d::get_data(void) const;

3386 18 get_num_components 0 4 3588 38 UnalignedLMatrix4d::get_num_components 0 1 1696 65
/**
 * Returns the number of elements in the matrix, sixteen.
 */
62
inline int UnalignedLMatrix4d::get_num_components(void) const;

3387 11 operator == 0 4 3588 31 UnalignedLMatrix4d::operator == 0 1 1697 0
83
inline bool UnalignedLMatrix4d::operator ==(UnalignedLMatrix4d const &other) const;

3388 11 operator != 0 4 3588 31 UnalignedLMatrix4d::operator != 0 1 1698 0
83
inline bool UnalignedLMatrix4d::operator !=(UnalignedLMatrix4d const &other) const;

3389 14 get_class_type 0 4 3588 34 UnalignedLMatrix4d::get_class_type 0 1 1699 0
59
static TypeHandle UnalignedLMatrix4d::get_class_type(void);

3390 19 ~UnalignedLMatrix4d 0 4 3588 39 UnalignedLMatrix4d::~UnalignedLMatrix4d 0 0 0
46
UnalignedLMatrix4d::~UnalignedLMatrix4d(void);

3391 10 operator * 0 1 0 10 operator * 0 24 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 0
1659
inline LVecBase3f operator *(LVecBase3f const &v, LMatrix3f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix3f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix3f const &m);
inline LVector2f operator *(LVector2f const &v, LMatrix3f const &m);
inline LPoint2f operator *(LPoint2f const &v, LMatrix3f const &m);
inline LVecBase4f operator *(LVecBase4f const &v, LMatrix4f const &m);
inline LPoint4f operator *(LPoint4f const &v, LMatrix4f const &m);
inline LVector4f operator *(LVector4f const &v, LMatrix4f const &m);
inline LVector3f operator *(LVector3f const &v, LMatrix4f const &m);
inline LPoint3f operator *(LPoint3f const &v, LMatrix4f const &m);
inline LVecBase3d operator *(LVecBase3d const &v, LMatrix3d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix3d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix3d const &m);
inline LVector2d operator *(LVector2d const &v, LMatrix3d const &m);
inline LPoint2d operator *(LPoint2d const &v, LMatrix3d const &m);
inline LVecBase4d operator *(LVecBase4d const &v, LMatrix4d const &m);
inline LPoint4d operator *(LPoint4d const &v, LMatrix4d const &m);
inline LVector4d operator *(LVector4d const &v, LMatrix4d const &m);
inline LVector3d operator *(LVector3d const &v, LMatrix4d const &m);
inline LPoint3d operator *(LPoint3d const &v, LMatrix4d const &m);
inline LMatrix3f operator *(LMatrix3f const &m, LQuaternionf const &q);
inline LMatrix4f operator *(LMatrix4f const &m, LQuaternionf const &q);
inline LMatrix3d operator *(LMatrix3d const &m, LQuaterniond const &q);
inline LMatrix4d operator *(LMatrix4d const &m, LQuaterniond const &q);

3392 11 operator *= 0 1 0 11 operator *= 0 16 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 0
941
inline void operator *=(LVecBase3f &v, LMatrix3f const &m);
inline void operator *=(LVector3f &v, LMatrix3f const &m);
inline void operator *=(LPoint3f &v, LMatrix3f const &m);
inline void operator *=(LVector2f &v, LMatrix3f const &m);
inline void operator *=(LPoint2f &v, LMatrix3f const &m);
inline void operator *=(LVecBase4f &v, LMatrix4f const &m);
inline void operator *=(LVector3f &v, LMatrix4f const &m);
inline void operator *=(LPoint3f &v, LMatrix4f const &m);
inline void operator *=(LVecBase3d &v, LMatrix3d const &m);
inline void operator *=(LVector3d &v, LMatrix3d const &m);
inline void operator *=(LPoint3d &v, LMatrix3d const &m);
inline void operator *=(LVector2d &v, LMatrix3d const &m);
inline void operator *=(LPoint2d &v, LMatrix3d const &m);
inline void operator *=(LVecBase4d &v, LMatrix4d const &m);
inline void operator *=(LVector3d &v, LMatrix4d const &m);
inline void operator *=(LPoint3d &v, LMatrix4d const &m);

3393 22 generic_write_datagram 0 1 0 22 generic_write_datagram 0 4 1934 1935 1936 1937 0
303
inline void generic_write_datagram(Datagram &dest, LMatrix3f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4f const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix3d const &value);
inline void generic_write_datagram(Datagram &dest, LMatrix4d const &value);

3394 21 generic_read_datagram 0 1 0 21 generic_read_datagram 0 4 1938 1939 1940 1941 0
319
inline void generic_read_datagram(LMatrix3f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4f &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix3d &result, DatagramIterator &source);
inline void generic_read_datagram(LMatrix4d &result, DatagramIterator &source);

3395 14 compose_matrix 0 1 0 14 compose_matrix 0 10 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 0
1484
void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &shear, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, float const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4f &mat, LVecBase3f const &scale, LVecBase3f const &hpr, LVecBase3f const &translate, CoordinateSystem cs = ::CS_default);
void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &shear, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, double const components[::num_matrix_components], CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix3d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);
inline void compose_matrix(LMatrix4d &mat, LVecBase3d const &scale, LVecBase3d const &hpr, LVecBase3d const &translate, CoordinateSystem cs = ::CS_default);

3396 16 decompose_matrix 0 1 0 16 decompose_matrix 0 10 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 0
1408
bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, float components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4f const &mat, LVecBase3f &scale, LVecBase3f &hpr, LVecBase3f &translate, CoordinateSystem cs = ::CS_default);
bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, double components[::num_matrix_components], CoordinateSystem CS = ::CS_default);
inline bool decompose_matrix(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);
inline bool decompose_matrix(LMatrix4d const &mat, LVecBase3d &scale, LVecBase3d &hpr, LVecBase3d &translate, CoordinateSystem cs = ::CS_default);

3397 24 decompose_matrix_old_hpr 0 1 0 24 decompose_matrix_old_hpr 0 2 1962 1963 0
287
bool decompose_matrix_old_hpr(LMatrix3f const &mat, LVecBase3f &scale, LVecBase3f &shear, LVecBase3f &hpr, CoordinateSystem cs = ::CS_default);
bool decompose_matrix_old_hpr(LMatrix3d const &mat, LVecBase3d &scale, LVecBase3d &shear, LVecBase3d &hpr, CoordinateSystem cs = ::CS_default);

3398 14 old_to_new_hpr 0 1 0 14 old_to_new_hpr 0 2 1964 1965 0
107
LVecBase3f old_to_new_hpr(LVecBase3f const &old_hpr);
LVecBase3d old_to_new_hpr(LVecBase3d const &old_hpr);

3399 12 LQuaternionf 0 4 3590 26 LQuaternionf::LQuaternionf 0 5 1700 1701 1702 1703 1704 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
305
inline LQuaternionf::LQuaternionf(void);
inline LQuaternionf::LQuaternionf(LVecBase4f const &copy);
inline LQuaternionf::LQuaternionf(float r, LVecBase3f const &copy);
inline LQuaternionf::LQuaternionf(float r, float i, float j, float k);
inline LQuaternionf::LQuaternionf(LQuaternionf const &) = default;

3400 14 pure_imaginary 0 4 3590 28 LQuaternionf::pure_imaginary 0 1 1705 10
/**
 *
 */
69
static LQuaternionf LQuaternionf::pure_imaginary(LVector3f const &v);

3401 9 conjugate 0 4 3590 23 LQuaternionf::conjugate 0 1 1706 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaternionf LQuaternionf::conjugate(void) const;

3402 5 xform 0 4 3590 19 LQuaternionf::xform 0 2 1707 1708 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3f LQuaternionf::xform(LVecBase3f const &v) const;
inline LVecBase4f LQuaternionf::xform(LVecBase4f const &v) const;

3403 8 multiply 0 4 3590 22 LQuaternionf::multiply 0 1 1709 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaternionf LQuaternionf::multiply(LQuaternionf const &rhs) const;

3404 10 operator - 0 68 3590 24 LQuaternionf::operator - 0 1 1710 0
57
inline LQuaternionf LQuaternionf::operator -(void) const;

3405 10 operator + 0 4 3590 24 LQuaternionf::operator + 0 1 1711 0
78
inline LQuaternionf LQuaternionf::operator +(LQuaternionf const &other) const;

3406 10 operator - 0 4 3590 24 LQuaternionf::operator - 0 1 1712 0
78
inline LQuaternionf LQuaternionf::operator -(LQuaternionf const &other) const;

3407 9 angle_rad 0 4 3590 23 LQuaternionf::angle_rad 0 1 1713 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
70
inline float LQuaternionf::angle_rad(LQuaternionf const &other) const;

3408 9 angle_deg 0 4 3590 23 LQuaternionf::angle_deg 0 1 1714 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
70
inline float LQuaternionf::angle_deg(LQuaternionf const &other) const;

3409 10 operator * 0 4 3590 24 LQuaternionf::operator * 0 4 1715 1716 1717 1718 0
263
inline LQuaternionf LQuaternionf::operator *(float scalar) const;
inline LQuaternionf LQuaternionf::operator *(LQuaternionf const &) const;
inline LMatrix3f LQuaternionf::operator *(LMatrix3f const &);
inline LMatrix4f LQuaternionf::operator *(LMatrix4f const &);

3410 10 operator / 0 4 3590 24 LQuaternionf::operator / 0 1 1719 0
65
inline LQuaternionf LQuaternionf::operator /(float scalar) const;

3411 11 operator *= 0 4 3590 25 LQuaternionf::operator *= 0 1 1720 10
/**
 *
 */
69
inline LQuaternionf &LQuaternionf::operator *=(LQuaternionf const &);

3412 7 __pow__ 0 4 3590 21 LQuaternionf::__pow__ 0 1 1721 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
49
LQuaternionf LQuaternionf::__pow__(float ) const;

3413 12 almost_equal 0 4 3590 26 LQuaternionf::almost_equal 0 2 1722 1723 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
162
inline bool LQuaternionf::almost_equal(LQuaternionf const &other) const;
inline bool LQuaternionf::almost_equal(LQuaternionf const &other, float threshold) const;

3414 17 is_same_direction 0 4 3590 31 LQuaternionf::is_same_direction 0 1 1724 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaternionf::is_same_direction(LQuaternionf const &other) const;

3415 21 almost_same_direction 0 4 3590 35 LQuaternionf::almost_same_direction 0 1 1725 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
98
inline bool LQuaternionf::almost_same_direction(LQuaternionf const &other, float threshold) const;

3416 6 output 0 4 3590 20 LQuaternionf::output 0 1 1726 10
/**
 *
 */
55
inline void LQuaternionf::output(std::ostream &) const;

3417 17 extract_to_matrix 0 4 3590 31 LQuaternionf::extract_to_matrix 0 2 1727 1728 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaternionf::extract_to_matrix(LMatrix3f &m) const;
void LQuaternionf::extract_to_matrix(LMatrix4f &m) const;

3418 15 set_from_matrix 0 4 3590 29 LQuaternionf::set_from_matrix 0 2 1729 1730 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaternionf::set_from_matrix(LMatrix3f const &m);
inline void LQuaternionf::set_from_matrix(LMatrix4f const &m);

3419 7 set_hpr 0 4 3590 21 LQuaternionf::set_hpr 0 1 1731 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaternionf::set_hpr(LVecBase3f const &hpr, CoordinateSystem cs = ::CS_default);

3420 7 get_hpr 0 4 3590 21 LQuaternionf::get_hpr 0 1 1732 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3f LQuaternionf::get_hpr(CoordinateSystem cs = ::CS_default) const;

3421 8 get_axis 0 4 3590 22 LQuaternionf::get_axis 0 1 1733 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3f LQuaternionf::get_axis(void) const;

3422 19 get_axis_normalized 0 4 3590 33 LQuaternionf::get_axis_normalized 0 1 1734 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3f LQuaternionf::get_axis_normalized(void) const;

3423 13 get_angle_rad 0 4 3590 27 LQuaternionf::get_angle_rad 0 1 1735 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
53
inline float LQuaternionf::get_angle_rad(void) const;

3424 9 get_angle 0 4 3590 23 LQuaternionf::get_angle 0 1 1736 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
49
inline float LQuaternionf::get_angle(void) const;

3425 23 set_from_axis_angle_rad 0 4 3590 37 LQuaternionf::set_from_axis_angle_rad 0 1 1737 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
90
inline void LQuaternionf::set_from_axis_angle_rad(float angle_rad, LVector3f const &axis);

3426 19 set_from_axis_angle 0 4 3590 33 LQuaternionf::set_from_axis_angle 0 1 1738 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
86
inline void LQuaternionf::set_from_axis_angle(float angle_deg, LVector3f const &axis);

3427 6 get_up 0 4 3590 20 LQuaternionf::get_up 0 1 1739 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3f LQuaternionf::get_up(CoordinateSystem cs = ::CS_default) const;

3428 9 get_right 0 4 3590 23 LQuaternionf::get_right 0 1 1740 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3f LQuaternionf::get_right(CoordinateSystem cs = ::CS_default) const;

3429 11 get_forward 0 4 3590 25 LQuaternionf::get_forward 0 1 1741 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3f LQuaternionf::get_forward(CoordinateSystem cs = ::CS_default) const;

3430 5 get_r 0 4 3590 19 LQuaternionf::get_r 0 1 1742 10
/**
 *
 */
45
inline float LQuaternionf::get_r(void) const;

3431 5 get_i 0 4 3590 19 LQuaternionf::get_i 0 1 1743 10
/**
 *
 */
45
inline float LQuaternionf::get_i(void) const;

3432 5 get_j 0 4 3590 19 LQuaternionf::get_j 0 1 1744 10
/**
 *
 */
45
inline float LQuaternionf::get_j(void) const;

3433 5 get_k 0 4 3590 19 LQuaternionf::get_k 0 1 1745 10
/**
 *
 */
45
inline float LQuaternionf::get_k(void) const;

3434 5 set_r 0 4 3590 19 LQuaternionf::set_r 0 1 1746 10
/**
 *
 */
41
inline void LQuaternionf::set_r(float r);

3435 5 set_i 0 4 3590 19 LQuaternionf::set_i 0 1 1747 10
/**
 *
 */
41
inline void LQuaternionf::set_i(float i);

3436 5 set_j 0 4 3590 19 LQuaternionf::set_j 0 1 1748 10
/**
 *
 */
41
inline void LQuaternionf::set_j(float j);

3437 5 set_k 0 4 3590 19 LQuaternionf::set_k 0 1 1749 10
/**
 *
 */
41
inline void LQuaternionf::set_k(float k);

3438 9 normalize 0 4 3590 23 LQuaternionf::normalize 0 1 1750 10
/**
 *
 */
42
inline bool LQuaternionf::normalize(void);

3439 14 conjugate_from 0 4 3590 28 LQuaternionf::conjugate_from 0 1 1751 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaternionf::conjugate_from(LQuaternionf const &other);

3440 18 conjugate_in_place 0 4 3590 32 LQuaternionf::conjugate_in_place 0 1 1752 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaternionf::conjugate_in_place(void);

3441 11 invert_from 0 4 3590 25 LQuaternionf::invert_from 0 1 1753 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaternionf::invert_from(LQuaternionf const &other);

3442 15 invert_in_place 0 4 3590 29 LQuaternionf::invert_in_place 0 1 1754 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaternionf::invert_in_place(void);

3443 11 is_identity 0 4 3590 25 LQuaternionf::is_identity 0 1 1755 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaternionf::is_identity(void) const;

3444 18 is_almost_identity 0 4 3590 32 LQuaternionf::is_almost_identity 0 1 1756 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
68
inline bool LQuaternionf::is_almost_identity(float tolerance) const;

3445 10 ident_quat 0 4 3590 24 LQuaternionf::ident_quat 0 1 1757 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaternionf const &LQuaternionf::ident_quat(void);

3446 14 get_class_type 0 4 3590 28 LQuaternionf::get_class_type 0 1 1758 0
53
static TypeHandle LQuaternionf::get_class_type(void);

3447 13 ~LQuaternionf 0 4 3590 27 LQuaternionf::~LQuaternionf 0 0 0
34
LQuaternionf::~LQuaternionf(void);

3448 12 LQuaterniond 0 4 3591 26 LQuaterniond::LQuaterniond 0 5 1759 1760 1761 1762 1763 46
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */
310
inline LQuaterniond::LQuaterniond(void);
inline LQuaterniond::LQuaterniond(LVecBase4d const &copy);
inline LQuaterniond::LQuaterniond(double r, LVecBase3d const &copy);
inline LQuaterniond::LQuaterniond(double r, double i, double j, double k);
inline LQuaterniond::LQuaterniond(LQuaterniond const &) = default;

3449 14 pure_imaginary 0 4 3591 28 LQuaterniond::pure_imaginary 0 1 1764 10
/**
 *
 */
69
static LQuaterniond LQuaterniond::pure_imaginary(LVector3d const &v);

3450 9 conjugate 0 4 3591 23 LQuaterniond::conjugate 0 1 1765 54
/**
 * Returns the complex conjugate of this quat.
 */
56
inline LQuaterniond LQuaterniond::conjugate(void) const;

3451 5 xform 0 4 3591 19 LQuaterniond::xform 0 2 1766 1767 122
/**
 * Transforms a 3-d vector by the indicated rotation
 */

/**
 * Transforms a 4-d vector by the indicated rotation
 */
131
inline LVecBase3d LQuaterniond::xform(LVecBase3d const &v) const;
inline LVecBase4d LQuaterniond::xform(LVecBase4d const &v) const;

3452 8 multiply 0 4 3591 22 LQuaterniond::multiply 0 1 1768 45
/**
 * actual multiply call (non virtual)
 */
74
inline LQuaterniond LQuaterniond::multiply(LQuaterniond const &rhs) const;

3453 10 operator - 0 68 3591 24 LQuaterniond::operator - 0 1 1769 0
57
inline LQuaterniond LQuaterniond::operator -(void) const;

3454 10 operator + 0 4 3591 24 LQuaterniond::operator + 0 1 1770 0
78
inline LQuaterniond LQuaterniond::operator +(LQuaterniond const &other) const;

3455 10 operator - 0 4 3591 24 LQuaterniond::operator - 0 1 1771 0
78
inline LQuaterniond LQuaterniond::operator -(LQuaterniond const &other) const;

3456 9 angle_rad 0 4 3591 23 LQuaterniond::angle_rad 0 1 1772 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */
71
inline double LQuaterniond::angle_rad(LQuaterniond const &other) const;

3457 9 angle_deg 0 4 3591 23 LQuaterniond::angle_deg 0 1 1773 127
/**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */
71
inline double LQuaterniond::angle_deg(LQuaterniond const &other) const;

3458 10 operator * 0 4 3591 24 LQuaterniond::operator * 0 4 1774 1775 1776 1777 0
264
inline LQuaterniond LQuaterniond::operator *(double scalar) const;
inline LQuaterniond LQuaterniond::operator *(LQuaterniond const &) const;
inline LMatrix3d LQuaterniond::operator *(LMatrix3d const &);
inline LMatrix4d LQuaterniond::operator *(LMatrix4d const &);

3459 10 operator / 0 4 3591 24 LQuaterniond::operator / 0 1 1778 0
66
inline LQuaterniond LQuaterniond::operator /(double scalar) const;

3460 11 operator *= 0 4 3591 25 LQuaterniond::operator *= 0 1 1779 10
/**
 *
 */
69
inline LQuaterniond &LQuaterniond::operator *=(LQuaterniond const &);

3461 7 __pow__ 0 4 3591 21 LQuaterniond::__pow__ 0 1 1780 97
/**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */
50
LQuaterniond LQuaterniond::__pow__(double ) const;

3462 12 almost_equal 0 4 3591 26 LQuaterniond::almost_equal 0 2 1781 1782 218
/**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */

/**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */
163
inline bool LQuaterniond::almost_equal(LQuaterniond const &other) const;
inline bool LQuaterniond::almost_equal(LQuaterniond const &other, double threshold) const;

3463 17 is_same_direction 0 4 3591 31 LQuaterniond::is_same_direction 0 1 1783 127
/**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */
77
inline bool LQuaterniond::is_same_direction(LQuaterniond const &other) const;

3464 21 almost_same_direction 0 4 3591 35 LQuaterniond::almost_same_direction 0 1 1784 103
/**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */
99
inline bool LQuaterniond::almost_same_direction(LQuaterniond const &other, double threshold) const;

3465 6 output 0 4 3591 20 LQuaterniond::output 0 1 1785 10
/**
 *
 */
55
inline void LQuaterniond::output(std::ostream &) const;

3466 17 extract_to_matrix 0 4 3591 31 LQuaterniond::extract_to_matrix 0 2 1786 1787 88
/**
 * Based on the quat lib from VRPN.
 */

/**
 * Based on the quat lib from VRPN.
 */
115
void LQuaterniond::extract_to_matrix(LMatrix3d &m) const;
void LQuaterniond::extract_to_matrix(LMatrix4d &m) const;

3467 15 set_from_matrix 0 4 3591 29 LQuaterniond::set_from_matrix 0 2 1788 1789 238
/**
 *
 */

/**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */
118
void LQuaterniond::set_from_matrix(LMatrix3d const &m);
inline void LQuaterniond::set_from_matrix(LMatrix4d const &m);

3468 7 set_hpr 0 4 3591 21 LQuaterniond::set_hpr 0 1 1790 132
/**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */
86
void LQuaterniond::set_hpr(LVecBase3d const &hpr, CoordinateSystem cs = ::CS_default);

3469 7 get_hpr 0 4 3591 21 LQuaterniond::get_hpr 0 1 1791 73
/**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */
75
LVecBase3d LQuaterniond::get_hpr(CoordinateSystem cs = ::CS_default) const;

3470 8 get_axis 0 4 3591 22 LQuaterniond::get_axis 0 1 1792 180
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */
52
inline LVector3d LQuaterniond::get_axis(void) const;

3471 19 get_axis_normalized 0 4 3591 33 LQuaterniond::get_axis_normalized 0 1 1793 169
/**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */
63
inline LVector3d LQuaterniond::get_axis_normalized(void) const;

3472 13 get_angle_rad 0 4 3591 27 LQuaterniond::get_angle_rad 0 1 1794 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
54
inline double LQuaterniond::get_angle_rad(void) const;

3473 9 get_angle 0 4 3591 23 LQuaterniond::get_angle 0 1 1795 343
/**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */
50
inline double LQuaterniond::get_angle(void) const;

3474 23 set_from_axis_angle_rad 0 4 3591 37 LQuaterniond::set_from_axis_angle_rad 0 1 1796 86
/**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */
91
inline void LQuaterniond::set_from_axis_angle_rad(double angle_rad, LVector3d const &axis);

3475 19 set_from_axis_angle 0 4 3591 33 LQuaterniond::set_from_axis_angle 0 1 1797 86
/**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */
87
inline void LQuaterniond::set_from_axis_angle(double angle_deg, LVector3d const &axis);

3476 6 get_up 0 4 3591 20 LQuaterniond::get_up 0 1 1798 96
/**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */
80
inline LVector3d LQuaterniond::get_up(CoordinateSystem cs = ::CS_default) const;

3477 9 get_right 0 4 3591 23 LQuaterniond::get_right 0 1 1799 98
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */
83
inline LVector3d LQuaterniond::get_right(CoordinateSystem cs = ::CS_default) const;

3478 11 get_forward 0 4 3591 25 LQuaterniond::get_forward 0 1 1800 100
/**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */
85
inline LVector3d LQuaterniond::get_forward(CoordinateSystem cs = ::CS_default) const;

3479 5 get_r 0 4 3591 19 LQuaterniond::get_r 0 1 1801 10
/**
 *
 */
46
inline double LQuaterniond::get_r(void) const;

3480 5 get_i 0 4 3591 19 LQuaterniond::get_i 0 1 1802 10
/**
 *
 */
46
inline double LQuaterniond::get_i(void) const;

3481 5 get_j 0 4 3591 19 LQuaterniond::get_j 0 1 1803 10
/**
 *
 */
46
inline double LQuaterniond::get_j(void) const;

3482 5 get_k 0 4 3591 19 LQuaterniond::get_k 0 1 1804 10
/**
 *
 */
46
inline double LQuaterniond::get_k(void) const;

3483 5 set_r 0 4 3591 19 LQuaterniond::set_r 0 1 1805 10
/**
 *
 */
42
inline void LQuaterniond::set_r(double r);

3484 5 set_i 0 4 3591 19 LQuaterniond::set_i 0 1 1806 10
/**
 *
 */
42
inline void LQuaterniond::set_i(double i);

3485 5 set_j 0 4 3591 19 LQuaterniond::set_j 0 1 1807 10
/**
 *
 */
42
inline void LQuaterniond::set_j(double j);

3486 5 set_k 0 4 3591 19 LQuaterniond::set_k 0 1 1808 10
/**
 *
 */
42
inline void LQuaterniond::set_k(double k);

3487 9 normalize 0 4 3591 23 LQuaterniond::normalize 0 1 1809 10
/**
 *
 */
42
inline bool LQuaterniond::normalize(void);

3488 14 conjugate_from 0 4 3591 28 LQuaterniond::conjugate_from 0 1 1810 466
/**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
68
inline bool LQuaterniond::conjugate_from(LQuaterniond const &other);

3489 18 conjugate_in_place 0 4 3591 32 LQuaterniond::conjugate_in_place 0 1 1811 129
/**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */
51
inline bool LQuaterniond::conjugate_in_place(void);

3490 11 invert_from 0 4 3591 25 LQuaterniond::invert_from 0 1 1812 448
/**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */
65
inline bool LQuaterniond::invert_from(LQuaterniond const &other);

3491 15 invert_in_place 0 4 3591 29 LQuaterniond::invert_in_place 0 1 1813 115
/**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */
48
inline bool LQuaterniond::invert_in_place(void);

3492 11 is_identity 0 4 3591 25 LQuaterniond::is_identity 0 1 1814 98
/**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */
50
inline bool LQuaterniond::is_identity(void) const;

3493 18 is_almost_identity 0 4 3591 32 LQuaterniond::is_almost_identity 0 1 1815 110
/**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */
69
inline bool LQuaterniond::is_almost_identity(double tolerance) const;

3494 10 ident_quat 0 4 3591 24 LQuaterniond::ident_quat 0 1 1816 42
/**
 * Returns an identity quaternion.
 */
65
static inline LQuaterniond const &LQuaterniond::ident_quat(void);

3495 14 get_class_type 0 4 3591 28 LQuaterniond::get_class_type 0 1 1817 0
53
static TypeHandle LQuaterniond::get_class_type(void);

3496 13 ~LQuaterniond 0 4 3591 27 LQuaterniond::~LQuaterniond 0 0 0
34
LQuaterniond::~LQuaterniond(void);

3497 10 LRotationf 0 4 3592 22 LRotationf::LRotationf 0 9 1818 1819 1820 1821 1822 1823 1824 1825 1826 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
500
inline LRotationf::LRotationf(void);
inline LRotationf::LRotationf(LQuaternionf const &c);
inline LRotationf::LRotationf(LVecBase4f const &copy);
inline LRotationf::LRotationf(float r, float i, float j, float k);
inline LRotationf::LRotationf(LVector3f const &axis, float angle);
inline LRotationf::LRotationf(LMatrix3f const &m);
inline LRotationf::LRotationf(LMatrix4f const &m);
inline LRotationf::LRotationf(float h, float p, float r);
inline LRotationf::LRotationf(LRotationf const &) = default;

3498 10 operator * 0 4 3592 22 LRotationf::operator * 0 3 1827 1828 1829 0
211
inline LRotationf LRotationf::operator *(float scalar) const;
inline LRotationf LRotationf::operator *(LRotationf const &other) const;
inline LQuaternionf LRotationf::operator *(LQuaternionf const &other) const;

3499 10 operator / 0 4 3592 22 LRotationf::operator / 0 1 1830 0
61
inline LRotationf LRotationf::operator /(float scalar) const;

3500 14 get_class_type 0 4 3592 26 LRotationf::get_class_type 0 1 1831 0
51
static TypeHandle LRotationf::get_class_type(void);

3501 11 ~LRotationf 0 4 3592 23 LRotationf::~LRotationf 0 0 0
30
LRotationf::~LRotationf(void);

3502 10 LRotationd 0 4 3593 22 LRotationd::LRotationd 0 9 1832 1833 1834 1835 1836 1837 1838 1839 1840 185
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * lmatrix3
 */

/**
 * lmatrix4
 */

/**
 * axis + angle (in degrees)
 */

/**
 * Sets the rotation from the given Euler angles.
 */
508
inline LRotationd::LRotationd(void);
inline LRotationd::LRotationd(LQuaterniond const &c);
inline LRotationd::LRotationd(LVecBase4d const &copy);
inline LRotationd::LRotationd(double r, double i, double j, double k);
inline LRotationd::LRotationd(LVector3d const &axis, double angle);
inline LRotationd::LRotationd(LMatrix3d const &m);
inline LRotationd::LRotationd(LMatrix4d const &m);
inline LRotationd::LRotationd(double h, double p, double r);
inline LRotationd::LRotationd(LRotationd const &) = default;

3503 10 operator * 0 4 3593 22 LRotationd::operator * 0 3 1841 1842 1843 0
212
inline LRotationd LRotationd::operator *(double scalar) const;
inline LRotationd LRotationd::operator *(LRotationd const &other) const;
inline LQuaterniond LRotationd::operator *(LQuaterniond const &other) const;

3504 10 operator / 0 4 3593 22 LRotationd::operator / 0 1 1844 0
62
inline LRotationd LRotationd::operator /(double scalar) const;

3505 14 get_class_type 0 4 3593 26 LRotationd::get_class_type 0 1 1845 0
51
static TypeHandle LRotationd::get_class_type(void);

3506 11 ~LRotationd 0 4 3593 23 LRotationd::~LRotationd 0 0 0
30
LRotationd::~LRotationd(void);

3507 13 LOrientationf 0 4 3594 28 LOrientationf::LOrientationf 0 7 1846 1847 1848 1849 1850 1851 1852 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
436
inline LOrientationf::LOrientationf(void);
inline LOrientationf::LOrientationf(LQuaternionf const &c);
inline LOrientationf::LOrientationf(float r, float i, float j, float k);
inline LOrientationf::LOrientationf(LVector3f const &point_at, float twist);
inline LOrientationf::LOrientationf(LMatrix3f const &m);
inline LOrientationf::LOrientationf(LMatrix4f const &m);
inline LOrientationf::LOrientationf(LOrientationf const &) = default;

3508 10 operator * 0 4 3594 25 LOrientationf::operator * 0 2 1853 1854 0
159
inline LOrientationf LOrientationf::operator *(LRotationf const &other) const;
inline LOrientationf LOrientationf::operator *(LQuaternionf const &other) const;

3509 14 get_class_type 0 4 3594 29 LOrientationf::get_class_type 0 1 1855 0
54
static TypeHandle LOrientationf::get_class_type(void);

3510 14 ~LOrientationf 0 4 3594 29 LOrientationf::~LOrientationf 0 0 0
36
LOrientationf::~LOrientationf(void);

3511 13 LOrientationd 0 4 3595 28 LOrientationd::LOrientationd 0 7 1856 1857 1858 1859 1860 1861 1862 101
/**
 *
 */

/**
 *
 */

/**
 *
 */

/**
 * vector + twist
 */

/**
 * matrix3
 */

/**
 * matrix4
 */
441
inline LOrientationd::LOrientationd(void);
inline LOrientationd::LOrientationd(LQuaterniond const &c);
inline LOrientationd::LOrientationd(double r, double i, double j, double k);
inline LOrientationd::LOrientationd(LVector3d const &point_at, double twist);
inline LOrientationd::LOrientationd(LMatrix3d const &m);
inline LOrientationd::LOrientationd(LMatrix4d const &m);
inline LOrientationd::LOrientationd(LOrientationd const &) = default;

3512 10 operator * 0 4 3595 25 LOrientationd::operator * 0 2 1863 1864 0
159
inline LOrientationd LOrientationd::operator *(LRotationd const &other) const;
inline LOrientationd LOrientationd::operator *(LQuaterniond const &other) const;

3513 14 get_class_type 0 4 3595 29 LOrientationd::get_class_type 0 1 1865 0
54
static TypeHandle LOrientationd::get_class_type(void);

3514 14 ~LOrientationd 0 4 3595 29 LOrientationd::~LOrientationd 0 0 0
36
LOrientationd::~LOrientationd(void);

3515 19 ConfigVariableColor 0 4 3666 40 ConfigVariableColor::ConfigVariableColor 0 4 1866 1867 1868 1869 34
/**
 *
 */

/**
 *
 */

/**
 *
 */
488
inline ConfigVariableColor::ConfigVariableColor(std::string const &name);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, LColor const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(std::string const &name, std::string const &default_value, std::string const &description = string(), int flags = 0);
inline ConfigVariableColor::ConfigVariableColor(ConfigVariableColor const &) = default;

3516 10 operator = 0 4 3666 31 ConfigVariableColor::operator = 0 1 1870 0
65
inline void ConfigVariableColor::operator =(LColor const &value);

3517 17 operator typecast 0 132 3666 38 ConfigVariableColor::operator typecast 0 1 1875 0
43
inline operator LColor const &(void) const;

3518 11 operator [] 0 4 3666 32 ConfigVariableColor::operator [] 0 1 1871 0
65
inline PN_stdfloat ConfigVariableColor::operator [](int n) const;

3519 9 set_value 0 4 3666 30 ConfigVariableColor::set_value 0 1 1872 48
/**
 * Reassigns the variable's local value.
 */
64
inline void ConfigVariableColor::set_value(LColor const &value);

3520 9 get_value 0 4 3666 30 ConfigVariableColor::get_value 0 1 1873 40
/**
 * Returns the variable's value.
 */
64
inline LColor const &ConfigVariableColor::get_value(void) const;

3521 17 get_default_value 0 4 3666 38 ConfigVariableColor::get_default_value 0 1 1874 48
/**
 * Returns the variable's default value.
 */
65
inline LColor ConfigVariableColor::get_default_value(void) const;

3522 20 ~ConfigVariableColor 0 4 3666 41 ConfigVariableColor::~ConfigVariableColor 0 0 0
48
ConfigVariableColor::~ConfigVariableColor(void);

1965
1 0 0 7 2 3668 1967 0 0 0 
2 0 0 7 2 3668 1967 0 0 1 6 param0 0 3669  
3 0 0 7 8 3671 2032 0 0 0 
4 0 0 7 8 3671 2032 0 0 1 6 param0 0 3672  
5 0 0 7 8 3671 2032 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
6 0 0 7 8 3671 2032 0 10 /**
 *
 */ 2 1 x 1 3526  1 y 1 3526  
7 0 0 4 9 3676 0 0 0 2 4 this 3 3671  4 size 1 3674  
8 0 0 6 12 3671 0 0 0 2 4 this 3 3671  4 copy 1 3672  
9 0 0 6 12 3671 0 0 0 2 4 this 3 3671  10 fill_value 1 3526  
10 0 0 6 13 3672 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
11 0 0 6 14 3672 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
12 0 0 6 15 3672 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
13 0 0 6 16 3677 0 0 0 1 4 this 3 3672  
14 0 0 6 17 3677 0 0 0 2 4 this 3 3672  9 attr_name 1 3680  
15 0 0 6 18 3532 0 0 0 3 4 this 3 3671  9 attr_name 1 3680  6 assign 1 3677  
16 0 0 4 19 3676 0 0 10 /**
 *
 */ 3 4 this 3 3671  1 i 1 3532  10 assign_val 1 3526  
17 0 0 6 19 3526 0 0 0 2 4 this 3 3672  1 i 1 3532  
18 0 0 6 20 3532 0 0 0 0 
19 0 0 6 21 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3672  
20 0 0 6 22 3526 0 0 10 /**
 *
 */ 2 4 this 3 3672  1 i 1 3532  
21 0 0 4 23 3676 0 0 10 /**
 *
 */ 3 4 this 3 3671  1 i 1 3532  5 value 1 3526  
22 0 0 6 24 3526 0 0 10 /**
 *
 */ 1 4 this 3 3672  
23 0 0 6 25 3526 0 0 10 /**
 *
 */ 1 4 this 3 3672  
24 0 0 4 26 3676 0 0 10 /**
 *
 */ 2 4 this 3 3671  5 value 1 3526  
25 0 0 4 27 3676 0 0 10 /**
 *
 */ 2 4 this 3 3671  5 value 1 3526  
26 0 0 4 31 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3671  1 i 1 3532  5 value 1 3526  
27 0 0 4 32 3676 0 0 10 /**
 *
 */ 2 4 this 3 3671  5 value 1 3526  
28 0 0 4 33 3676 0 0 10 /**
 *
 */ 2 4 this 3 3671  5 value 1 3526  
29 0 0 4 34 3676 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3672  
30 0 0 6 35 3532 0 0 0 0 
31 0 0 4 36 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3671  10 fill_value 1 3526  
32 0 0 4 37 3676 0 0 10 /**
 *
 */ 3 4 this 3 3671  1 x 1 3526  1 y 1 3526  
33 0 0 6 38 3526 0 0 10 /**
 *
 */ 2 4 this 3 3672  5 other 1 3672  
34 0 0 6 39 3526 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3672  
35 0 0 6 40 3526 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3672  
36 0 0 6 41 3681 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3671  
37 0 0 7 42 3671 2032 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3672  
38 0 0 7 43 3671 2032 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3672  4 onto 1 3672  
39 0 0 6 44 3681 0 0 0 2 4 this 3 3672  5 other 1 3672  
40 0 0 6 45 3681 0 0 0 2 4 this 3 3672  5 other 1 3672  
41 0 0 6 46 3681 0 0 0 2 4 this 3 3672  5 other 1 3672  
42 0 0 6 47 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3672  5 other 1 3672  
43 0 0 6 47 3532 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3672  5 other 1 3672  9 threshold 1 3526  
44 0 0 6 48 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3672  
45 0 0 6 48 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3672  9 threshold 1 3526  
46 0 0 6 49 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3672  4 hash 1 3674  
47 0 0 6 49 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3672  4 hash 1 3674  9 threshold 1 3526  
48 0 0 4 50 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3672  7 hashgen 1 3682  
49 0 0 4 50 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3672  7 hashgen 1 3682  9 threshold 1 3526  
50 0 0 7 51 3671 2032 0 0 1 4 this 3 3672  
51 0 0 7 52 3671 2032 0 0 2 4 this 3 3672  5 other 1 3672  
52 0 0 7 53 3671 2032 0 0 2 4 this 3 3672  5 other 1 3672  
53 0 0 7 54 3671 2032 0 0 2 4 this 3 3672  6 scalar 1 3526  
54 0 0 7 55 3671 2032 0 0 2 4 this 3 3672  6 scalar 1 3526  
55 0 0 6 56 3671 0 0 0 2 4 this 3 3671  5 other 1 3672  
56 0 0 6 57 3671 0 0 0 2 4 this 3 3671  5 other 1 3672  
57 0 0 6 58 3671 0 0 0 2 4 this 3 3671  6 scalar 1 3526  
58 0 0 6 59 3671 0 0 0 2 4 this 3 3671  6 scalar 1 3526  
59 0 0 4 60 3676 0 0 10 /**
 *
 */ 2 4 this 3 3671  5 other 1 3672  
60 0 0 7 61 3671 2032 0 0 2 4 this 3 3672  8 exponent 1 3526  
61 0 0 6 62 3677 0 0 0 2 4 this 3 3671  8 exponent 1 3526  
62 0 0 7 63 3671 2032 0 10 /**
 *
 */ 2 4 this 3 3672  5 other 1 3672  
63 0 0 7 64 3671 2032 0 10 /**
 *
 */ 2 4 this 3 3672  5 other 1 3672  
64 0 0 6 65 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3672  5 other 1 3672  
65 0 0 6 65 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3672  5 other 1 3672  9 threshold 1 3526  
66 0 0 4 66 3676 0 0 10 /**
 *
 */ 2 4 this 3 3672  3 out 1 3684  
67 0 0 6 67 3680 0 0 0 1 4 this 3 3672  
68 0 0 4 68 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3672  11 destination 1 3686  
69 0 0 4 69 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3671  6 source 1 3688  
70 0 0 4 70 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3672  11 destination 1 3686  
71 0 0 4 71 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3671  6 source 1 3688  
72 0 0 7 72 3691 0 0 0 0 
73 0 0 7 76 3692 2095 0 0 0 
74 0 0 7 76 3692 2095 0 0 1 6 param0 0 3693  
75 0 0 7 76 3692 2095 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
76 0 0 7 76 3692 2095 0 10 /**
 *
 */ 2 1 x 1 3529  1 y 1 3529  
77 0 0 4 77 3676 0 0 0 2 4 this 3 3692  4 size 1 3674  
78 0 0 6 80 3692 0 0 0 2 4 this 3 3692  4 copy 1 3693  
79 0 0 6 80 3692 0 0 0 2 4 this 3 3692  10 fill_value 1 3529  
80 0 0 6 81 3693 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
81 0 0 6 82 3693 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
82 0 0 6 83 3693 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
83 0 0 6 84 3677 0 0 0 1 4 this 3 3693  
84 0 0 6 85 3677 0 0 0 2 4 this 3 3693  9 attr_name 1 3680  
85 0 0 6 86 3532 0 0 0 3 4 this 3 3692  9 attr_name 1 3680  6 assign 1 3677  
86 0 0 4 87 3676 0 0 10 /**
 *
 */ 3 4 this 3 3692  1 i 1 3532  10 assign_val 1 3529  
87 0 0 6 87 3529 0 0 0 2 4 this 3 3693  1 i 1 3532  
88 0 0 6 88 3532 0 0 0 0 
89 0 0 6 89 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3693  
90 0 0 6 90 3529 0 0 10 /**
 *
 */ 2 4 this 3 3693  1 i 1 3532  
91 0 0 4 91 3676 0 0 10 /**
 *
 */ 3 4 this 3 3692  1 i 1 3532  5 value 1 3529  
92 0 0 6 92 3529 0 0 10 /**
 *
 */ 1 4 this 3 3693  
93 0 0 6 93 3529 0 0 10 /**
 *
 */ 1 4 this 3 3693  
94 0 0 4 94 3676 0 0 10 /**
 *
 */ 2 4 this 3 3692  5 value 1 3529  
95 0 0 4 95 3676 0 0 10 /**
 *
 */ 2 4 this 3 3692  5 value 1 3529  
96 0 0 4 99 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3692  1 i 1 3532  5 value 1 3529  
97 0 0 4 100 3676 0 0 10 /**
 *
 */ 2 4 this 3 3692  5 value 1 3529  
98 0 0 4 101 3676 0 0 10 /**
 *
 */ 2 4 this 3 3692  5 value 1 3529  
99 0 0 4 102 3676 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3693  
100 0 0 6 103 3532 0 0 0 0 
101 0 0 4 104 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3692  10 fill_value 1 3529  
102 0 0 4 105 3676 0 0 10 /**
 *
 */ 3 4 this 3 3692  1 x 1 3529  1 y 1 3529  
103 0 0 6 106 3529 0 0 10 /**
 *
 */ 2 4 this 3 3693  5 other 1 3693  
104 0 0 6 107 3529 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3693  
105 0 0 6 108 3529 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3693  
106 0 0 6 109 3681 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3692  
107 0 0 7 110 3692 2095 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3693  
108 0 0 7 111 3692 2095 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3693  4 onto 1 3693  
109 0 0 6 112 3681 0 0 0 2 4 this 3 3693  5 other 1 3693  
110 0 0 6 113 3681 0 0 0 2 4 this 3 3693  5 other 1 3693  
111 0 0 6 114 3681 0 0 0 2 4 this 3 3693  5 other 1 3693  
112 0 0 6 115 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3693  5 other 1 3693  
113 0 0 6 115 3532 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3693  5 other 1 3693  9 threshold 1 3529  
114 0 0 6 116 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3693  
115 0 0 6 116 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3693  9 threshold 1 3529  
116 0 0 6 117 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3693  4 hash 1 3674  
117 0 0 6 117 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3693  4 hash 1 3674  9 threshold 1 3529  
118 0 0 4 118 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3693  7 hashgen 1 3682  
119 0 0 4 118 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3693  7 hashgen 1 3682  9 threshold 1 3529  
120 0 0 7 119 3692 2095 0 0 1 4 this 3 3693  
121 0 0 7 120 3692 2095 0 0 2 4 this 3 3693  5 other 1 3693  
122 0 0 7 121 3692 2095 0 0 2 4 this 3 3693  5 other 1 3693  
123 0 0 7 122 3692 2095 0 0 2 4 this 3 3693  6 scalar 1 3529  
124 0 0 7 123 3692 2095 0 0 2 4 this 3 3693  6 scalar 1 3529  
125 0 0 6 124 3692 0 0 0 2 4 this 3 3692  5 other 1 3693  
126 0 0 6 125 3692 0 0 0 2 4 this 3 3692  5 other 1 3693  
127 0 0 6 126 3692 0 0 0 2 4 this 3 3692  6 scalar 1 3529  
128 0 0 6 127 3692 0 0 0 2 4 this 3 3692  6 scalar 1 3529  
129 0 0 4 128 3676 0 0 10 /**
 *
 */ 2 4 this 3 3692  5 other 1 3693  
130 0 0 7 129 3692 2095 0 0 2 4 this 3 3693  8 exponent 1 3529  
131 0 0 6 130 3677 0 0 0 2 4 this 3 3692  8 exponent 1 3529  
132 0 0 7 131 3692 2095 0 10 /**
 *
 */ 2 4 this 3 3693  5 other 1 3693  
133 0 0 7 132 3692 2095 0 10 /**
 *
 */ 2 4 this 3 3693  5 other 1 3693  
134 0 0 6 133 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3693  5 other 1 3693  
135 0 0 6 133 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3693  5 other 1 3693  9 threshold 1 3529  
136 0 0 4 134 3676 0 0 10 /**
 *
 */ 2 4 this 3 3693  3 out 1 3684  
137 0 0 6 135 3680 0 0 0 1 4 this 3 3693  
138 0 0 4 136 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3693  11 destination 1 3686  
139 0 0 4 137 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3692  6 source 1 3688  
140 0 0 4 138 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3693  11 destination 1 3686  
141 0 0 4 139 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3692  6 source 1 3688  
142 0 0 7 140 3691 0 0 0 0 
143 0 0 7 144 3695 2154 0 0 0 
144 0 0 7 144 3695 2154 0 0 1 6 param0 0 3696  
145 0 0 7 144 3695 2154 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
146 0 0 7 144 3695 2154 0 10 /**
 *
 */ 2 1 x 1 3532  1 y 1 3532  
147 0 0 4 145 3676 0 0 0 2 4 this 3 3695  4 size 1 3674  
148 0 0 6 148 3695 0 0 0 2 4 this 3 3695  4 copy 1 3696  
149 0 0 6 148 3695 0 0 0 2 4 this 3 3695  10 fill_value 1 3532  
150 0 0 6 149 3696 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
151 0 0 6 150 3696 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
152 0 0 6 151 3696 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
153 0 0 6 152 3677 0 0 0 1 4 this 3 3696  
154 0 0 6 153 3677 0 0 0 2 4 this 3 3696  9 attr_name 1 3680  
155 0 0 6 154 3532 0 0 0 3 4 this 3 3695  9 attr_name 1 3680  6 assign 1 3677  
156 0 0 4 155 3676 0 0 10 /**
 *
 */ 3 4 this 3 3695  1 i 1 3532  10 assign_val 1 3532  
157 0 0 6 155 3532 0 0 0 2 4 this 3 3696  1 i 1 3532  
158 0 0 6 156 3532 0 0 0 0 
159 0 0 6 157 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3696  
160 0 0 6 158 3532 0 0 10 /**
 *
 */ 2 4 this 3 3696  1 i 1 3532  
161 0 0 4 159 3676 0 0 10 /**
 *
 */ 3 4 this 3 3695  1 i 1 3532  5 value 1 3532  
162 0 0 6 160 3532 0 0 10 /**
 *
 */ 1 4 this 3 3696  
163 0 0 6 161 3532 0 0 10 /**
 *
 */ 1 4 this 3 3696  
164 0 0 4 162 3676 0 0 10 /**
 *
 */ 2 4 this 3 3695  5 value 1 3532  
165 0 0 4 163 3676 0 0 10 /**
 *
 */ 2 4 this 3 3695  5 value 1 3532  
166 0 0 4 167 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3695  1 i 1 3532  5 value 1 3532  
167 0 0 4 168 3676 0 0 10 /**
 *
 */ 2 4 this 3 3695  5 value 1 3532  
168 0 0 4 169 3676 0 0 10 /**
 *
 */ 2 4 this 3 3695  5 value 1 3532  
169 0 0 4 170 3676 0 0 155 /**
 * Returns the address of the first of the two data elements in the vector.
 * The next element occupies the next position consecutively in memory.
 */ 1 4 this 3 3696  
170 0 0 6 171 3532 0 0 0 0 
171 0 0 4 172 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3695  10 fill_value 1 3532  
172 0 0 4 173 3676 0 0 10 /**
 *
 */ 3 4 this 3 3695  1 x 1 3532  1 y 1 3532  
173 0 0 6 174 3532 0 0 10 /**
 *
 */ 2 4 this 3 3696  5 other 1 3696  
174 0 0 6 175 3532 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3696  
175 0 0 6 176 3681 0 0 0 2 4 this 3 3696  5 other 1 3696  
176 0 0 6 177 3681 0 0 0 2 4 this 3 3696  5 other 1 3696  
177 0 0 6 178 3681 0 0 0 2 4 this 3 3696  5 other 1 3696  
178 0 0 6 179 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3696  5 other 1 3696  
179 0 0 6 180 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3696  
180 0 0 6 181 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3696  4 hash 1 3674  
181 0 0 4 182 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3696  7 hashgen 1 3682  
182 0 0 7 183 3695 2154 0 0 1 4 this 3 3696  
183 0 0 7 184 3695 2154 0 0 2 4 this 3 3696  5 other 1 3696  
184 0 0 7 185 3695 2154 0 0 2 4 this 3 3696  5 other 1 3696  
185 0 0 7 186 3695 2154 0 0 2 4 this 3 3696  6 scalar 1 3532  
186 0 0 7 187 3695 2154 0 0 2 4 this 3 3696  6 scalar 1 3532  
187 0 0 6 188 3695 0 0 0 2 4 this 3 3695  5 other 1 3696  
188 0 0 6 189 3695 0 0 0 2 4 this 3 3695  5 other 1 3696  
189 0 0 6 190 3695 0 0 0 2 4 this 3 3695  6 scalar 1 3532  
190 0 0 6 191 3695 0 0 0 2 4 this 3 3695  6 scalar 1 3532  
191 0 0 4 192 3676 0 0 10 /**
 *
 */ 2 4 this 3 3695  5 other 1 3696  
192 0 0 7 193 3695 2154 0 0 2 4 this 3 3696  8 exponent 1 3532  
193 0 0 6 194 3677 0 0 0 2 4 this 3 3695  8 exponent 1 3532  
194 0 0 7 195 3695 2154 0 10 /**
 *
 */ 2 4 this 3 3696  5 other 1 3696  
195 0 0 7 196 3695 2154 0 10 /**
 *
 */ 2 4 this 3 3696  5 other 1 3696  
196 0 0 6 197 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3696  5 other 1 3696  
197 0 0 6 197 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3696  5 other 1 3696  9 threshold 1 3532  
198 0 0 4 198 3676 0 0 10 /**
 *
 */ 2 4 this 3 3696  3 out 1 3684  
199 0 0 6 199 3680 0 0 0 1 4 this 3 3696  
200 0 0 4 200 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3696  11 destination 1 3686  
201 0 0 4 201 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3695  6 source 1 3688  
202 0 0 4 202 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3696  11 destination 1 3686  
203 0 0 4 203 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3695  6 source 1 3688  
204 0 0 7 204 3691 0 0 0 0 
205 0 0 7 207 3698 2172 0 0 0 
206 0 0 7 207 3698 2172 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3672  
207 0 0 7 207 3698 2172 0 0 1 6 param0 0 3699  
208 0 0 7 207 3698 2172 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3526  
209 0 0 7 207 3698 2172 0 10 /**
 *
 */ 2 1 x 1 3526  1 y 1 3526  
210 0 0 6 208 3677 0 0 0 2 4 this 3 3699  9 attr_name 1 3680  
211 0 0 6 209 3532 0 0 0 3 4 this 3 3698  9 attr_name 1 3680  6 assign 1 3677  
212 0 0 6 210 3699 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
213 0 0 6 211 3699 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
214 0 0 6 212 3699 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
215 0 0 7 213 3698 2172 0 0 1 4 this 3 3699  
216 0 0 7 214 3671 2032 0 0 2 4 this 3 3699  5 other 1 3672  
217 0 0 7 214 3698 2172 0 0 2 4 this 3 3699  5 other 1 3699  
218 0 0 7 215 3671 2032 0 0 2 4 this 3 3699  5 other 1 3672  
219 0 0 7 215 3698 2172 0 0 2 4 this 3 3699  5 other 1 3699  
220 0 0 7 216 3698 2172 0 0 2 4 this 3 3699  6 scalar 1 3526  
221 0 0 7 217 3698 2172 0 0 2 4 this 3 3699  6 scalar 1 3526  
222 0 0 7 218 3698 2172 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3699  
223 0 0 7 219 3698 2172 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3699  4 onto 1 3672  
224 0 0 6 220 3526 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3699  5 other 1 3699  
225 0 0 6 221 3526 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3699  5 other 1 3699  
226 0 0 6 222 3680 0 0 0 1 4 this 3 3699  
227 0 0 7 223 3691 0 0 0 0 
228 0 0 7 226 3701 2190 0 0 0 
229 0 0 7 226 3701 2190 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3693  
230 0 0 7 226 3701 2190 0 0 1 6 param0 0 3702  
231 0 0 7 226 3701 2190 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3529  
232 0 0 7 226 3701 2190 0 10 /**
 *
 */ 2 1 x 1 3529  1 y 1 3529  
233 0 0 6 227 3677 0 0 0 2 4 this 3 3702  9 attr_name 1 3680  
234 0 0 6 228 3532 0 0 0 3 4 this 3 3701  9 attr_name 1 3680  6 assign 1 3677  
235 0 0 6 229 3702 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
236 0 0 6 230 3702 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
237 0 0 6 231 3702 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
238 0 0 7 232 3701 2190 0 0 1 4 this 3 3702  
239 0 0 7 233 3692 2095 0 0 2 4 this 3 3702  5 other 1 3693  
240 0 0 7 233 3701 2190 0 0 2 4 this 3 3702  5 other 1 3702  
241 0 0 7 234 3692 2095 0 0 2 4 this 3 3702  5 other 1 3693  
242 0 0 7 234 3701 2190 0 0 2 4 this 3 3702  5 other 1 3702  
243 0 0 7 235 3701 2190 0 0 2 4 this 3 3702  6 scalar 1 3529  
244 0 0 7 236 3701 2190 0 0 2 4 this 3 3702  6 scalar 1 3529  
245 0 0 7 237 3701 2190 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3702  
246 0 0 7 238 3701 2190 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3702  4 onto 1 3693  
247 0 0 6 239 3529 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3702  5 other 1 3702  
248 0 0 6 240 3529 0 0 92 /**
 * returns the signed angled between two vectors.  normalization is NOT
 * necessary
 */ 2 4 this 3 3702  5 other 1 3702  
249 0 0 6 241 3680 0 0 0 1 4 this 3 3702  
250 0 0 7 242 3691 0 0 0 0 
251 0 0 7 245 3704 2204 0 0 0 
252 0 0 7 245 3704 2204 0 53 /**
 * Constructs a new LVector2 from a LVecBase2
 */ 1 4 copy 1 3696  
253 0 0 7 245 3704 2204 0 0 1 6 param0 0 3705  
254 0 0 7 245 3704 2204 0 79 /**
 * Constructs a new LVector2 with all components set to the fill value.
 */ 1 10 fill_value 1 3532  
255 0 0 7 245 3704 2204 0 10 /**
 *
 */ 2 1 x 1 3532  1 y 1 3532  
256 0 0 6 246 3677 0 0 0 2 4 this 3 3705  9 attr_name 1 3680  
257 0 0 6 247 3532 0 0 0 3 4 this 3 3704  9 attr_name 1 3680  6 assign 1 3677  
258 0 0 6 248 3705 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
259 0 0 6 249 3705 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
260 0 0 6 250 3705 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
261 0 0 7 251 3704 2204 0 0 1 4 this 3 3705  
262 0 0 7 252 3695 2154 0 0 2 4 this 3 3705  5 other 1 3696  
263 0 0 7 252 3704 2204 0 0 2 4 this 3 3705  5 other 1 3705  
264 0 0 7 253 3695 2154 0 0 2 4 this 3 3705  5 other 1 3696  
265 0 0 7 253 3704 2204 0 0 2 4 this 3 3705  5 other 1 3705  
266 0 0 7 254 3704 2204 0 0 2 4 this 3 3705  6 scalar 1 3532  
267 0 0 7 255 3704 2204 0 0 2 4 this 3 3705  6 scalar 1 3532  
268 0 0 6 256 3680 0 0 0 1 4 this 3 3705  
269 0 0 7 257 3691 0 0 0 0 
270 0 0 7 260 3707 2220 0 0 0 
271 0 0 7 260 3707 2220 0 0 1 6 param0 0 3708  
272 0 0 7 260 3707 2220 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3672  
273 0 0 7 260 3707 2220 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3526  
274 0 0 7 260 3707 2220 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3526  1 y 1 3526  
275 0 0 6 261 3677 0 0 0 2 4 this 3 3708  9 attr_name 1 3680  
276 0 0 6 262 3532 0 0 0 3 4 this 3 3707  9 attr_name 1 3680  6 assign 1 3677  
277 0 0 6 263 3708 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
278 0 0 6 264 3708 0 0 34 /**
 * Returns a unit X point.
 */ 0 
279 0 0 6 265 3708 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
280 0 0 7 266 3707 2220 0 0 1 4 this 3 3708  
281 0 0 7 267 3671 2032 0 0 2 4 this 3 3708  5 other 1 3672  
282 0 0 7 267 3707 2220 0 0 2 4 this 3 3708  5 other 1 3699  
283 0 0 7 268 3698 2172 0 0 2 4 this 3 3708  5 other 1 3708  
284 0 0 7 268 3671 2032 0 0 2 4 this 3 3708  5 other 1 3672  
285 0 0 7 268 3707 2220 0 0 2 4 this 3 3708  5 other 1 3699  
286 0 0 7 269 3707 2220 0 0 2 4 this 3 3708  6 scalar 1 3526  
287 0 0 7 270 3707 2220 0 0 2 4 this 3 3708  6 scalar 1 3526  
288 0 0 7 271 3707 2220 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3708  
289 0 0 7 272 3707 2220 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3708  4 onto 1 3672  
290 0 0 6 273 3680 0 0 0 1 4 this 3 3708  
291 0 0 7 274 3691 0 0 0 0 
292 0 0 7 277 3710 2236 0 0 0 
293 0 0 7 277 3710 2236 0 0 1 6 param0 0 3711  
294 0 0 7 277 3710 2236 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3693  
295 0 0 7 277 3710 2236 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3529  
296 0 0 7 277 3710 2236 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3529  1 y 1 3529  
297 0 0 6 278 3677 0 0 0 2 4 this 3 3711  9 attr_name 1 3680  
298 0 0 6 279 3532 0 0 0 3 4 this 3 3710  9 attr_name 1 3680  6 assign 1 3677  
299 0 0 6 280 3711 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
300 0 0 6 281 3711 0 0 34 /**
 * Returns a unit X point.
 */ 0 
301 0 0 6 282 3711 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
302 0 0 7 283 3710 2236 0 0 1 4 this 3 3711  
303 0 0 7 284 3692 2095 0 0 2 4 this 3 3711  5 other 1 3693  
304 0 0 7 284 3710 2236 0 0 2 4 this 3 3711  5 other 1 3702  
305 0 0 7 285 3701 2190 0 0 2 4 this 3 3711  5 other 1 3711  
306 0 0 7 285 3692 2095 0 0 2 4 this 3 3711  5 other 1 3693  
307 0 0 7 285 3710 2236 0 0 2 4 this 3 3711  5 other 1 3702  
308 0 0 7 286 3710 2236 0 0 2 4 this 3 3711  6 scalar 1 3529  
309 0 0 7 287 3710 2236 0 0 2 4 this 3 3711  6 scalar 1 3529  
310 0 0 7 288 3710 2236 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3711  
311 0 0 7 289 3710 2236 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3711  4 onto 1 3693  
312 0 0 6 290 3680 0 0 0 1 4 this 3 3711  
313 0 0 7 291 3691 0 0 0 0 
314 0 0 7 294 3713 2250 0 0 0 
315 0 0 7 294 3713 2250 0 0 1 6 param0 0 3714  
316 0 0 7 294 3713 2250 0 52 /**
 * Constructs a new LPoint2 from a LVecBase2
 */ 1 4 copy 1 3696  
317 0 0 7 294 3713 2250 0 73 /**
 * Constructs a new LPoint2 all components set to the fill value.
 */ 1 10 fill_value 1 3532  
318 0 0 7 294 3713 2250 0 61 /**
 * Constructs a new LPoint2 with the given components
 */ 2 1 x 1 3532  1 y 1 3532  
319 0 0 6 295 3677 0 0 0 2 4 this 3 3714  9 attr_name 1 3680  
320 0 0 6 296 3532 0 0 0 3 4 this 3 3713  9 attr_name 1 3680  6 assign 1 3677  
321 0 0 6 297 3714 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
322 0 0 6 298 3714 0 0 34 /**
 * Returns a unit X point.
 */ 0 
323 0 0 6 299 3714 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
324 0 0 7 300 3713 2250 0 0 1 4 this 3 3714  
325 0 0 7 301 3695 2154 0 0 2 4 this 3 3714  5 other 1 3696  
326 0 0 7 301 3713 2250 0 0 2 4 this 3 3714  5 other 1 3705  
327 0 0 7 302 3704 2204 0 0 2 4 this 3 3714  5 other 1 3714  
328 0 0 7 302 3695 2154 0 0 2 4 this 3 3714  5 other 1 3696  
329 0 0 7 302 3713 2250 0 0 2 4 this 3 3714  5 other 1 3705  
330 0 0 7 303 3713 2250 0 0 2 4 this 3 3714  6 scalar 1 3532  
331 0 0 7 304 3713 2250 0 0 2 4 this 3 3714  6 scalar 1 3532  
332 0 0 6 305 3680 0 0 0 1 4 this 3 3714  
333 0 0 7 306 3691 0 0 0 0 
334 0 0 7 310 3716 2323 0 0 0 
335 0 0 7 310 3716 2323 0 10 /**
 *
 */ 2 4 copy 1 3672  1 z 1 3526  
336 0 0 7 310 3716 2323 0 0 1 6 param0 0 3717  
337 0 0 7 310 3716 2323 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
338 0 0 7 310 3716 2323 0 10 /**
 *
 */ 3 1 x 1 3526  1 y 1 3526  1 z 1 3526  
339 0 0 4 311 3676 0 0 0 2 4 this 3 3716  4 size 1 3674  
340 0 0 6 314 3716 0 0 0 2 4 this 3 3716  4 copy 1 3717  
341 0 0 6 314 3716 0 0 0 2 4 this 3 3716  10 fill_value 1 3526  
342 0 0 6 315 3717 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
343 0 0 6 316 3717 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
344 0 0 6 317 3717 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
345 0 0 6 318 3717 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
346 0 0 6 319 3677 0 0 0 1 4 this 3 3717  
347 0 0 6 320 3677 0 0 0 2 4 this 3 3717  9 attr_name 1 3680  
348 0 0 6 321 3532 0 0 0 3 4 this 3 3716  9 attr_name 1 3680  6 assign 1 3677  
349 0 0 4 322 3676 0 0 10 /**
 *
 */ 3 4 this 3 3716  1 i 1 3532  10 assign_val 1 3526  
350 0 0 6 322 3526 0 0 0 2 4 this 3 3717  1 i 1 3532  
351 0 0 6 323 3532 0 0 0 0 
352 0 0 6 324 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3717  
353 0 0 6 325 3526 0 0 10 /**
 *
 */ 2 4 this 3 3717  1 i 1 3532  
354 0 0 6 326 3526 0 0 10 /**
 *
 */ 1 4 this 3 3717  
355 0 0 6 327 3526 0 0 10 /**
 *
 */ 1 4 this 3 3717  
356 0 0 6 328 3526 0 0 10 /**
 *
 */ 1 4 this 3 3717  
357 0 0 4 329 3676 0 0 10 /**
 *
 */ 3 4 this 3 3716  1 i 1 3532  5 value 1 3526  
358 0 0 4 330 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 value 1 3526  
359 0 0 4 331 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 value 1 3526  
360 0 0 4 332 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 value 1 3526  
361 0 0 7 333 3671 2032 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3717  
362 0 0 7 334 3671 2032 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3717  
363 0 0 7 335 3671 2032 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3717  
364 0 0 4 342 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3716  1 i 1 3532  5 value 1 3526  
365 0 0 4 343 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 value 1 3526  
366 0 0 4 344 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 value 1 3526  
367 0 0 4 345 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 value 1 3526  
368 0 0 4 346 3676 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3717  
369 0 0 6 347 3532 0 0 0 0 
370 0 0 4 348 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3716  10 fill_value 1 3526  
371 0 0 4 349 3676 0 0 10 /**
 *
 */ 4 4 this 3 3716  1 x 1 3526  1 y 1 3526  1 z 1 3526  
372 0 0 6 350 3526 0 0 10 /**
 *
 */ 2 4 this 3 3717  5 other 1 3717  
373 0 0 6 351 3526 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3717  
374 0 0 6 352 3526 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3717  
375 0 0 6 353 3681 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3716  
376 0 0 7 354 3716 2323 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3717  
377 0 0 7 355 3716 2323 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3717  4 onto 1 3717  
378 0 0 7 356 3716 2323 0 10 /**
 *
 */ 2 4 this 3 3717  5 other 1 3717  
379 0 0 6 357 3681 0 0 0 2 4 this 3 3717  5 other 1 3717  
380 0 0 6 358 3681 0 0 0 2 4 this 3 3717  5 other 1 3717  
381 0 0 6 359 3681 0 0 0 2 4 this 3 3717  5 other 1 3717  
382 0 0 7 360 3716 2323 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3717  
383 0 0 6 361 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3717  5 other 1 3717  
384 0 0 6 361 3532 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3717  5 other 1 3717  9 threshold 1 3526  
385 0 0 6 362 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3717  
386 0 0 6 362 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3717  9 threshold 1 3526  
387 0 0 6 363 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3717  4 hash 1 3674  
388 0 0 6 363 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3717  4 hash 1 3674  9 threshold 1 3526  
389 0 0 4 364 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3717  7 hashgen 1 3682  
390 0 0 4 364 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3717  7 hashgen 1 3682  9 threshold 1 3526  
391 0 0 7 365 3716 2323 0 0 1 4 this 3 3717  
392 0 0 7 366 3716 2323 0 0 2 4 this 3 3717  5 other 1 3717  
393 0 0 7 367 3716 2323 0 0 2 4 this 3 3717  5 other 1 3717  
394 0 0 7 368 3716 2323 0 0 2 4 this 3 3717  6 scalar 1 3526  
395 0 0 7 369 3716 2323 0 0 2 4 this 3 3717  6 scalar 1 3526  
396 0 0 6 370 3716 0 0 0 2 4 this 3 3716  5 other 1 3717  
397 0 0 6 371 3716 0 0 0 2 4 this 3 3716  5 other 1 3717  
398 0 0 6 372 3716 0 0 0 2 4 this 3 3716  6 scalar 1 3526  
399 0 0 6 373 3716 0 0 0 2 4 this 3 3716  6 scalar 1 3526  
400 0 0 4 374 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 other 1 3717  
401 0 0 7 375 3716 2323 0 0 2 4 this 3 3717  8 exponent 1 3526  
402 0 0 6 376 3677 0 0 0 2 4 this 3 3716  8 exponent 1 3526  
403 0 0 7 377 3716 2323 0 10 /**
 *
 */ 2 4 this 3 3717  5 other 1 3717  
404 0 0 7 378 3716 2323 0 10 /**
 *
 */ 2 4 this 3 3717  5 other 1 3717  
405 0 0 4 379 3676 0 0 10 /**
 *
 */ 2 4 this 3 3716  5 other 1 3717  
406 0 0 6 380 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3717  5 other 1 3717  
407 0 0 6 380 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3717  5 other 1 3717  9 threshold 1 3526  
408 0 0 4 381 3676 0 0 10 /**
 *
 */ 2 4 this 3 3717  3 out 1 3684  
409 0 0 6 382 3680 0 0 0 1 4 this 3 3717  
410 0 0 4 383 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3717  11 destination 1 3686  
411 0 0 4 384 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3716  6 source 1 3688  
412 0 0 4 385 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3717  11 destination 1 3686  
413 0 0 4 386 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3716  6 source 1 3688  
414 0 0 7 387 3691 0 0 0 0 
415 0 0 7 391 3719 2396 0 0 0 
416 0 0 7 391 3719 2396 0 10 /**
 *
 */ 2 4 copy 1 3693  1 z 1 3529  
417 0 0 7 391 3719 2396 0 0 1 6 param0 0 3720  
418 0 0 7 391 3719 2396 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
419 0 0 7 391 3719 2396 0 10 /**
 *
 */ 3 1 x 1 3529  1 y 1 3529  1 z 1 3529  
420 0 0 4 392 3676 0 0 0 2 4 this 3 3719  4 size 1 3674  
421 0 0 6 395 3719 0 0 0 2 4 this 3 3719  4 copy 1 3720  
422 0 0 6 395 3719 0 0 0 2 4 this 3 3719  10 fill_value 1 3529  
423 0 0 6 396 3720 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
424 0 0 6 397 3720 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
425 0 0 6 398 3720 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
426 0 0 6 399 3720 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
427 0 0 6 400 3677 0 0 0 1 4 this 3 3720  
428 0 0 6 401 3677 0 0 0 2 4 this 3 3720  9 attr_name 1 3680  
429 0 0 6 402 3532 0 0 0 3 4 this 3 3719  9 attr_name 1 3680  6 assign 1 3677  
430 0 0 4 403 3676 0 0 10 /**
 *
 */ 3 4 this 3 3719  1 i 1 3532  10 assign_val 1 3529  
431 0 0 6 403 3529 0 0 0 2 4 this 3 3720  1 i 1 3532  
432 0 0 6 404 3532 0 0 0 0 
433 0 0 6 405 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3720  
434 0 0 6 406 3529 0 0 10 /**
 *
 */ 2 4 this 3 3720  1 i 1 3532  
435 0 0 6 407 3529 0 0 10 /**
 *
 */ 1 4 this 3 3720  
436 0 0 6 408 3529 0 0 10 /**
 *
 */ 1 4 this 3 3720  
437 0 0 6 409 3529 0 0 10 /**
 *
 */ 1 4 this 3 3720  
438 0 0 4 410 3676 0 0 10 /**
 *
 */ 3 4 this 3 3719  1 i 1 3532  5 value 1 3529  
439 0 0 4 411 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 value 1 3529  
440 0 0 4 412 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 value 1 3529  
441 0 0 4 413 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 value 1 3529  
442 0 0 7 414 3692 2095 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3720  
443 0 0 7 415 3692 2095 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3720  
444 0 0 7 416 3692 2095 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3720  
445 0 0 4 423 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3719  1 i 1 3532  5 value 1 3529  
446 0 0 4 424 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 value 1 3529  
447 0 0 4 425 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 value 1 3529  
448 0 0 4 426 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 value 1 3529  
449 0 0 4 427 3676 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3720  
450 0 0 6 428 3532 0 0 0 0 
451 0 0 4 429 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3719  10 fill_value 1 3529  
452 0 0 4 430 3676 0 0 10 /**
 *
 */ 4 4 this 3 3719  1 x 1 3529  1 y 1 3529  1 z 1 3529  
453 0 0 6 431 3529 0 0 10 /**
 *
 */ 2 4 this 3 3720  5 other 1 3720  
454 0 0 6 432 3529 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3720  
455 0 0 6 433 3529 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3720  
456 0 0 6 434 3681 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3719  
457 0 0 7 435 3719 2396 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3720  
458 0 0 7 436 3719 2396 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3720  4 onto 1 3720  
459 0 0 7 437 3719 2396 0 10 /**
 *
 */ 2 4 this 3 3720  5 other 1 3720  
460 0 0 6 438 3681 0 0 0 2 4 this 3 3720  5 other 1 3720  
461 0 0 6 439 3681 0 0 0 2 4 this 3 3720  5 other 1 3720  
462 0 0 6 440 3681 0 0 0 2 4 this 3 3720  5 other 1 3720  
463 0 0 7 441 3719 2396 0 623 /**
 * Try to un-spin the hpr to a standard form.  Like all standards, someone
 * decides between many arbitrary possible standards.  This function assumes
 * that 0 and 360 are the same, as is 720 and -360.  Also 180 and -180 are the
 * same.  Another example is -90 and 270. Each element will be in the range
 * -180.0 to 179.99999. The original usage of this function is for human
 * readable output.
 *
 * It doesn't work so well for asserting that foo_hpr is roughly equal to
 * bar_hpr.  Try using LQuaternionf::is_same_direction() for that.  See Also:
 * get_standardized_rotation, LQuaternion::is_same_direction
 */ 1 4 this 3 3720  
464 0 0 6 442 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3720  5 other 1 3720  
465 0 0 6 442 3532 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3720  5 other 1 3720  9 threshold 1 3529  
466 0 0 6 443 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3720  
467 0 0 6 443 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3720  9 threshold 1 3529  
468 0 0 6 444 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3720  4 hash 1 3674  
469 0 0 6 444 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3720  4 hash 1 3674  9 threshold 1 3529  
470 0 0 4 445 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3720  7 hashgen 1 3682  
471 0 0 4 445 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3720  7 hashgen 1 3682  9 threshold 1 3529  
472 0 0 7 446 3719 2396 0 0 1 4 this 3 3720  
473 0 0 7 447 3719 2396 0 0 2 4 this 3 3720  5 other 1 3720  
474 0 0 7 448 3719 2396 0 0 2 4 this 3 3720  5 other 1 3720  
475 0 0 7 449 3719 2396 0 0 2 4 this 3 3720  6 scalar 1 3529  
476 0 0 7 450 3719 2396 0 0 2 4 this 3 3720  6 scalar 1 3529  
477 0 0 6 451 3719 0 0 0 2 4 this 3 3719  5 other 1 3720  
478 0 0 6 452 3719 0 0 0 2 4 this 3 3719  5 other 1 3720  
479 0 0 6 453 3719 0 0 0 2 4 this 3 3719  6 scalar 1 3529  
480 0 0 6 454 3719 0 0 0 2 4 this 3 3719  6 scalar 1 3529  
481 0 0 4 455 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 other 1 3720  
482 0 0 7 456 3719 2396 0 0 2 4 this 3 3720  8 exponent 1 3529  
483 0 0 6 457 3677 0 0 0 2 4 this 3 3719  8 exponent 1 3529  
484 0 0 7 458 3719 2396 0 10 /**
 *
 */ 2 4 this 3 3720  5 other 1 3720  
485 0 0 7 459 3719 2396 0 10 /**
 *
 */ 2 4 this 3 3720  5 other 1 3720  
486 0 0 4 460 3676 0 0 10 /**
 *
 */ 2 4 this 3 3719  5 other 1 3720  
487 0 0 6 461 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3720  5 other 1 3720  
488 0 0 6 461 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3720  5 other 1 3720  9 threshold 1 3529  
489 0 0 4 462 3676 0 0 10 /**
 *
 */ 2 4 this 3 3720  3 out 1 3684  
490 0 0 6 463 3680 0 0 0 1 4 this 3 3720  
491 0 0 4 464 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3720  11 destination 1 3686  
492 0 0 4 465 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3719  6 source 1 3688  
493 0 0 4 466 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3720  11 destination 1 3686  
494 0 0 4 467 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3719  6 source 1 3688  
495 0 0 7 468 3691 0 0 0 0 
496 0 0 7 472 3722 2464 0 0 0 
497 0 0 7 472 3722 2464 0 10 /**
 *
 */ 2 4 copy 1 3696  1 z 1 3532  
498 0 0 7 472 3722 2464 0 0 1 6 param0 0 3723  
499 0 0 7 472 3722 2464 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
500 0 0 7 472 3722 2464 0 10 /**
 *
 */ 3 1 x 1 3532  1 y 1 3532  1 z 1 3532  
501 0 0 4 473 3676 0 0 0 2 4 this 3 3722  4 size 1 3674  
502 0 0 6 476 3722 0 0 0 2 4 this 3 3722  4 copy 1 3723  
503 0 0 6 476 3722 0 0 0 2 4 this 3 3722  10 fill_value 1 3532  
504 0 0 6 477 3723 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
505 0 0 6 478 3723 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
506 0 0 6 479 3723 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
507 0 0 6 480 3723 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
508 0 0 6 481 3677 0 0 0 1 4 this 3 3723  
509 0 0 6 482 3677 0 0 0 2 4 this 3 3723  9 attr_name 1 3680  
510 0 0 6 483 3532 0 0 0 3 4 this 3 3722  9 attr_name 1 3680  6 assign 1 3677  
511 0 0 4 484 3676 0 0 10 /**
 *
 */ 3 4 this 3 3722  1 i 1 3532  10 assign_val 1 3532  
512 0 0 6 484 3532 0 0 0 2 4 this 3 3723  1 i 1 3532  
513 0 0 6 485 3532 0 0 0 0 
514 0 0 6 486 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3723  
515 0 0 6 487 3532 0 0 10 /**
 *
 */ 2 4 this 3 3723  1 i 1 3532  
516 0 0 6 488 3532 0 0 10 /**
 *
 */ 1 4 this 3 3723  
517 0 0 6 489 3532 0 0 10 /**
 *
 */ 1 4 this 3 3723  
518 0 0 6 490 3532 0 0 10 /**
 *
 */ 1 4 this 3 3723  
519 0 0 4 491 3676 0 0 10 /**
 *
 */ 3 4 this 3 3722  1 i 1 3532  5 value 1 3532  
520 0 0 4 492 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3532  
521 0 0 4 493 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3532  
522 0 0 4 494 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3532  
523 0 0 7 495 3695 2154 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3723  
524 0 0 7 496 3695 2154 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3723  
525 0 0 7 497 3695 2154 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3723  
526 0 0 4 504 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3722  1 i 1 3532  5 value 1 3532  
527 0 0 4 505 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3532  
528 0 0 4 506 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3532  
529 0 0 4 507 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 value 1 3532  
530 0 0 4 508 3676 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3723  
531 0 0 6 509 3532 0 0 0 0 
532 0 0 4 510 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3722  10 fill_value 1 3532  
533 0 0 4 511 3676 0 0 10 /**
 *
 */ 4 4 this 3 3722  1 x 1 3532  1 y 1 3532  1 z 1 3532  
534 0 0 6 512 3532 0 0 10 /**
 *
 */ 2 4 this 3 3723  5 other 1 3723  
535 0 0 6 513 3532 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3723  
536 0 0 7 514 3722 2464 0 10 /**
 *
 */ 2 4 this 3 3723  5 other 1 3723  
537 0 0 6 515 3681 0 0 0 2 4 this 3 3723  5 other 1 3723  
538 0 0 6 516 3681 0 0 0 2 4 this 3 3723  5 other 1 3723  
539 0 0 6 517 3681 0 0 0 2 4 this 3 3723  5 other 1 3723  
540 0 0 6 518 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3723  5 other 1 3723  
541 0 0 6 519 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3723  
542 0 0 6 520 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3723  4 hash 1 3674  
543 0 0 4 521 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3723  7 hashgen 1 3682  
544 0 0 7 522 3722 2464 0 0 1 4 this 3 3723  
545 0 0 7 523 3722 2464 0 0 2 4 this 3 3723  5 other 1 3723  
546 0 0 7 524 3722 2464 0 0 2 4 this 3 3723  5 other 1 3723  
547 0 0 7 525 3722 2464 0 0 2 4 this 3 3723  6 scalar 1 3532  
548 0 0 7 526 3722 2464 0 0 2 4 this 3 3723  6 scalar 1 3532  
549 0 0 6 527 3722 0 0 0 2 4 this 3 3722  5 other 1 3723  
550 0 0 6 528 3722 0 0 0 2 4 this 3 3722  5 other 1 3723  
551 0 0 6 529 3722 0 0 0 2 4 this 3 3722  6 scalar 1 3532  
552 0 0 6 530 3722 0 0 0 2 4 this 3 3722  6 scalar 1 3532  
553 0 0 4 531 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 other 1 3723  
554 0 0 7 532 3722 2464 0 0 2 4 this 3 3723  8 exponent 1 3532  
555 0 0 6 533 3677 0 0 0 2 4 this 3 3722  8 exponent 1 3532  
556 0 0 7 534 3722 2464 0 10 /**
 *
 */ 2 4 this 3 3723  5 other 1 3723  
557 0 0 7 535 3722 2464 0 10 /**
 *
 */ 2 4 this 3 3723  5 other 1 3723  
558 0 0 4 536 3676 0 0 10 /**
 *
 */ 2 4 this 3 3722  5 other 1 3723  
559 0 0 6 537 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3723  5 other 1 3723  
560 0 0 6 537 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3723  5 other 1 3723  9 threshold 1 3532  
561 0 0 4 538 3676 0 0 10 /**
 *
 */ 2 4 this 3 3723  3 out 1 3684  
562 0 0 6 539 3680 0 0 0 1 4 this 3 3723  
563 0 0 4 540 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3723  11 destination 1 3686  
564 0 0 4 541 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3722  6 source 1 3688  
565 0 0 4 542 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3723  11 destination 1 3686  
566 0 0 4 543 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3722  6 source 1 3688  
567 0 0 7 544 3691 0 0 0 0 
568 0 0 7 552 3725 2502 0 0 0 
569 0 0 7 552 3725 2502 0 10 /**
 *
 */ 2 4 copy 1 3672  1 z 1 3526  
570 0 0 7 552 3725 2502 0 10 /**
 *
 */ 1 4 copy 1 3717  
571 0 0 7 552 3725 2502 0 0 1 6 param0 0 3726  
572 0 0 7 552 3725 2502 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
573 0 0 7 552 3725 2502 0 10 /**
 *
 */ 3 1 x 1 3526  1 y 1 3526  1 z 1 3526  
574 0 0 6 553 3677 0 0 0 2 4 this 3 3726  9 attr_name 1 3680  
575 0 0 6 554 3532 0 0 0 3 4 this 3 3725  9 attr_name 1 3680  6 assign 1 3677  
576 0 0 6 555 3726 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
577 0 0 6 556 3726 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
578 0 0 6 557 3726 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
579 0 0 6 558 3726 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
580 0 0 7 559 3698 2172 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3726  
581 0 0 7 560 3698 2172 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3726  
582 0 0 7 561 3698 2172 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3726  
583 0 0 7 565 3725 2502 0 0 1 4 this 3 3726  
584 0 0 7 566 3716 2323 0 0 2 4 this 3 3726  5 other 1 3717  
585 0 0 7 566 3725 2502 0 0 2 4 this 3 3726  5 other 1 3726  
586 0 0 7 567 3716 2323 0 0 2 4 this 3 3726  5 other 1 3717  
587 0 0 7 567 3725 2502 0 0 2 4 this 3 3726  5 other 1 3726  
588 0 0 7 568 3725 2502 0 10 /**
 *
 */ 2 4 this 3 3726  5 other 1 3717  
589 0 0 7 569 3725 2502 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3726  
590 0 0 7 570 3725 2502 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3726  4 onto 1 3717  
591 0 0 6 571 3526 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3726  5 other 1 3726  
592 0 0 6 572 3526 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3726  5 other 1 3726  
593 0 0 6 573 3526 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3726  5 other 1 3726  3 ref 1 3726  
594 0 0 6 574 3526 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3726  5 other 1 3726  3 ref 1 3726  
595 0 0 6 575 3526 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3726  5 other 1 3726  
596 0 0 6 576 3526 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3726  5 other 1 3726  
597 0 0 7 577 3725 2502 0 0 2 4 this 3 3726  6 scalar 1 3526  
598 0 0 7 578 3725 2502 0 0 2 4 this 3 3726  6 scalar 1 3526  
599 0 0 7 579 3725 2502 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3545  
600 0 0 7 580 3725 2502 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3545  
601 0 0 7 581 3725 2502 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3545  
602 0 0 7 582 3725 2502 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3545  
603 0 0 7 583 3725 2502 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3545  
604 0 0 7 584 3725 2502 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3545  
605 0 0 7 585 3725 2502 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3526  3 fwd 1 3526  2 up 1 3526  2 cs 1 3545  
606 0 0 6 586 3680 0 0 0 1 4 this 3 3726  
607 0 0 7 587 3691 0 0 0 0 
608 0 0 7 590 3728 2536 0 0 0 
609 0 0 7 590 3728 2536 0 10 /**
 *
 */ 2 4 copy 1 3693  1 z 1 3529  
610 0 0 7 590 3728 2536 0 10 /**
 *
 */ 1 4 copy 1 3720  
611 0 0 7 590 3728 2536 0 0 1 6 param0 0 3729  
612 0 0 7 590 3728 2536 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
613 0 0 7 590 3728 2536 0 10 /**
 *
 */ 3 1 x 1 3529  1 y 1 3529  1 z 1 3529  
614 0 0 6 591 3677 0 0 0 2 4 this 3 3729  9 attr_name 1 3680  
615 0 0 6 592 3532 0 0 0 3 4 this 3 3728  9 attr_name 1 3680  6 assign 1 3677  
616 0 0 6 593 3729 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
617 0 0 6 594 3729 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
618 0 0 6 595 3729 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
619 0 0 6 596 3729 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
620 0 0 7 597 3701 2190 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3729  
621 0 0 7 598 3701 2190 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3729  
622 0 0 7 599 3701 2190 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3729  
623 0 0 7 603 3728 2536 0 0 1 4 this 3 3729  
624 0 0 7 604 3719 2396 0 0 2 4 this 3 3729  5 other 1 3720  
625 0 0 7 604 3728 2536 0 0 2 4 this 3 3729  5 other 1 3729  
626 0 0 7 605 3719 2396 0 0 2 4 this 3 3729  5 other 1 3720  
627 0 0 7 605 3728 2536 0 0 2 4 this 3 3729  5 other 1 3729  
628 0 0 7 606 3728 2536 0 10 /**
 *
 */ 2 4 this 3 3729  5 other 1 3720  
629 0 0 7 607 3728 2536 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3729  
630 0 0 7 608 3728 2536 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3729  4 onto 1 3720  
631 0 0 6 609 3529 0 0 147 /**
 * Returns the unsigned angle between this vector and the other one, expressed
 * in radians.  Both vectors should be initially normalized.
 */ 2 4 this 3 3729  5 other 1 3729  
632 0 0 6 610 3529 0 0 138 /**
 * Returns the angle between this vector and the other one, expressed in
 * degrees.  Both vectors should be initially normalized.
 */ 2 4 this 3 3729  5 other 1 3729  
633 0 0 6 611 3529 0 0 259 /**
 * returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3729  5 other 1 3729  3 ref 1 3729  
634 0 0 6 612 3529 0 0 259 /**
 * Returns the signed angle between two vectors.  The angle is positive if the
 * rotation from this vector to other is clockwise when looking in the
 * direction of the ref vector.
 *
 * Vectors (except the ref vector) should be initially normalized.
 */ 3 4 this 3 3729  5 other 1 3729  3 ref 1 3729  
635 0 0 6 613 3529 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3729  5 other 1 3729  
636 0 0 6 614 3529 0 0 50 /**
 * This method is deprecated.  Do not use.
 */ 2 4 this 3 3729  5 other 1 3729  
637 0 0 7 615 3728 2536 0 0 2 4 this 3 3729  6 scalar 1 3529  
638 0 0 7 616 3728 2536 0 0 2 4 this 3 3729  6 scalar 1 3529  
639 0 0 7 617 3728 2536 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3545  
640 0 0 7 618 3728 2536 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3545  
641 0 0 7 619 3728 2536 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3545  
642 0 0 7 620 3728 2536 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3545  
643 0 0 7 621 3728 2536 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3545  
644 0 0 7 622 3728 2536 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3545  
645 0 0 7 623 3728 2536 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3529  3 fwd 1 3529  2 up 1 3529  2 cs 1 3545  
646 0 0 6 624 3680 0 0 0 1 4 this 3 3729  
647 0 0 7 625 3691 0 0 0 0 
648 0 0 7 628 3731 2562 0 0 0 
649 0 0 7 628 3731 2562 0 10 /**
 *
 */ 2 4 copy 1 3696  1 z 1 3532  
650 0 0 7 628 3731 2562 0 10 /**
 *
 */ 1 4 copy 1 3723  
651 0 0 7 628 3731 2562 0 0 1 6 param0 0 3732  
652 0 0 7 628 3731 2562 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
653 0 0 7 628 3731 2562 0 10 /**
 *
 */ 3 1 x 1 3532  1 y 1 3532  1 z 1 3532  
654 0 0 6 629 3677 0 0 0 2 4 this 3 3732  9 attr_name 1 3680  
655 0 0 6 630 3532 0 0 0 3 4 this 3 3731  9 attr_name 1 3680  6 assign 1 3677  
656 0 0 6 631 3732 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
657 0 0 6 632 3732 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
658 0 0 6 633 3732 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
659 0 0 6 634 3732 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
660 0 0 7 635 3704 2204 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3732  
661 0 0 7 636 3704 2204 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3732  
662 0 0 7 637 3704 2204 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3732  
663 0 0 7 641 3731 2562 0 0 1 4 this 3 3732  
664 0 0 7 642 3722 2464 0 0 2 4 this 3 3732  5 other 1 3723  
665 0 0 7 642 3731 2562 0 0 2 4 this 3 3732  5 other 1 3732  
666 0 0 7 643 3722 2464 0 0 2 4 this 3 3732  5 other 1 3723  
667 0 0 7 643 3731 2562 0 0 2 4 this 3 3732  5 other 1 3732  
668 0 0 7 644 3731 2562 0 10 /**
 *
 */ 2 4 this 3 3732  5 other 1 3723  
669 0 0 7 645 3731 2562 0 0 2 4 this 3 3732  6 scalar 1 3532  
670 0 0 7 646 3731 2562 0 0 2 4 this 3 3732  6 scalar 1 3532  
671 0 0 7 647 3731 2562 0 65 /**
 * Returns the up vector for the given coordinate system.
 */ 1 2 cs 1 3545  
672 0 0 7 648 3731 2562 0 68 /**
 * Returns the right vector for the given coordinate system.
 */ 1 2 cs 1 3545  
673 0 0 7 649 3731 2562 0 70 /**
 * Returns the forward vector for the given coordinate system.
 */ 1 2 cs 1 3545  
674 0 0 7 650 3731 2562 0 67 /**
 * Returns the down vector for the given coordinate system.
 */ 1 2 cs 1 3545  
675 0 0 7 651 3731 2562 0 67 /**
 * Returns the left vector for the given coordinate system.
 */ 1 2 cs 1 3545  
676 0 0 7 652 3731 2562 0 67 /**
 * Returns the back vector for the given coordinate system.
 */ 1 2 cs 1 3545  
677 0 0 7 653 3731 2562 0 152 /**
 * Returns a vector that is described by its right, forward, and up
 * components, in whatever way the coordinate system represents that vector.
 */ 4 5 right 1 3532  3 fwd 1 3532  2 up 1 3532  2 cs 1 3545  
678 0 0 6 654 3680 0 0 0 1 4 this 3 3732  
679 0 0 7 655 3691 0 0 0 0 
680 0 0 7 658 3734 2585 0 0 0 
681 0 0 7 658 3734 2585 0 0 1 6 param0 0 3735  
682 0 0 7 658 3734 2585 0 10 /**
 *
 */ 2 4 copy 1 3672  1 z 1 3526  
683 0 0 7 658 3734 2585 0 10 /**
 *
 */ 1 4 copy 1 3717  
684 0 0 7 658 3734 2585 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
685 0 0 7 658 3734 2585 0 10 /**
 *
 */ 3 1 x 1 3526  1 y 1 3526  1 z 1 3526  
686 0 0 6 659 3677 0 0 0 2 4 this 3 3735  9 attr_name 1 3680  
687 0 0 6 660 3532 0 0 0 3 4 this 3 3734  9 attr_name 1 3680  6 assign 1 3677  
688 0 0 6 661 3735 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
689 0 0 6 662 3735 0 0 34 /**
 * Returns a unit X point.
 */ 0 
690 0 0 6 663 3735 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
691 0 0 6 664 3735 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
692 0 0 7 665 3707 2220 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3735  
693 0 0 7 666 3707 2220 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3735  
694 0 0 7 667 3707 2220 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3735  
695 0 0 7 671 3734 2585 0 0 1 4 this 3 3735  
696 0 0 7 672 3716 2323 0 0 2 4 this 3 3735  5 other 1 3717  
697 0 0 7 672 3734 2585 0 0 2 4 this 3 3735  5 other 1 3726  
698 0 0 7 673 3725 2502 0 0 2 4 this 3 3735  5 other 1 3735  
699 0 0 7 673 3716 2323 0 0 2 4 this 3 3735  5 other 1 3717  
700 0 0 7 673 3734 2585 0 0 2 4 this 3 3735  5 other 1 3726  
701 0 0 7 674 3734 2585 0 10 /**
 *
 */ 2 4 this 3 3735  5 other 1 3717  
702 0 0 7 675 3734 2585 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3735  
703 0 0 7 676 3734 2585 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3735  4 onto 1 3717  
704 0 0 7 677 3734 2585 0 0 2 4 this 3 3735  6 scalar 1 3526  
705 0 0 7 678 3734 2585 0 0 2 4 this 3 3735  6 scalar 1 3526  
706 0 0 6 679 3735 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3545  
707 0 0 7 680 3734 2585 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3526  3 fwd 1 3526  2 up 1 3526  2 cs 1 3545  
708 0 0 6 681 3680 0 0 0 1 4 this 3 3735  
709 0 0 7 682 3691 0 0 0 0 
710 0 0 7 685 3737 2608 0 0 0 
711 0 0 7 685 3737 2608 0 0 1 6 param0 0 3738  
712 0 0 7 685 3737 2608 0 10 /**
 *
 */ 2 4 copy 1 3693  1 z 1 3529  
713 0 0 7 685 3737 2608 0 10 /**
 *
 */ 1 4 copy 1 3720  
714 0 0 7 685 3737 2608 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
715 0 0 7 685 3737 2608 0 10 /**
 *
 */ 3 1 x 1 3529  1 y 1 3529  1 z 1 3529  
716 0 0 6 686 3677 0 0 0 2 4 this 3 3738  9 attr_name 1 3680  
717 0 0 6 687 3532 0 0 0 3 4 this 3 3737  9 attr_name 1 3680  6 assign 1 3677  
718 0 0 6 688 3738 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
719 0 0 6 689 3738 0 0 34 /**
 * Returns a unit X point.
 */ 0 
720 0 0 6 690 3738 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
721 0 0 6 691 3738 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
722 0 0 7 692 3710 2236 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3738  
723 0 0 7 693 3710 2236 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3738  
724 0 0 7 694 3710 2236 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3738  
725 0 0 7 698 3737 2608 0 0 1 4 this 3 3738  
726 0 0 7 699 3719 2396 0 0 2 4 this 3 3738  5 other 1 3720  
727 0 0 7 699 3737 2608 0 0 2 4 this 3 3738  5 other 1 3729  
728 0 0 7 700 3728 2536 0 0 2 4 this 3 3738  5 other 1 3738  
729 0 0 7 700 3719 2396 0 0 2 4 this 3 3738  5 other 1 3720  
730 0 0 7 700 3737 2608 0 0 2 4 this 3 3738  5 other 1 3729  
731 0 0 7 701 3737 2608 0 10 /**
 *
 */ 2 4 this 3 3738  5 other 1 3720  
732 0 0 7 702 3737 2608 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3738  
733 0 0 7 703 3737 2608 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3738  4 onto 1 3720  
734 0 0 7 704 3737 2608 0 0 2 4 this 3 3738  6 scalar 1 3529  
735 0 0 7 705 3737 2608 0 0 2 4 this 3 3738  6 scalar 1 3529  
736 0 0 6 706 3738 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3545  
737 0 0 7 707 3737 2608 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3529  3 fwd 1 3529  2 up 1 3529  2 cs 1 3545  
738 0 0 6 708 3680 0 0 0 1 4 this 3 3738  
739 0 0 7 709 3691 0 0 0 0 
740 0 0 7 712 3740 2629 0 0 0 
741 0 0 7 712 3740 2629 0 0 1 6 param0 0 3741  
742 0 0 7 712 3740 2629 0 10 /**
 *
 */ 2 4 copy 1 3696  1 z 1 3532  
743 0 0 7 712 3740 2629 0 10 /**
 *
 */ 1 4 copy 1 3723  
744 0 0 7 712 3740 2629 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
745 0 0 7 712 3740 2629 0 10 /**
 *
 */ 3 1 x 1 3532  1 y 1 3532  1 z 1 3532  
746 0 0 6 713 3677 0 0 0 2 4 this 3 3741  9 attr_name 1 3680  
747 0 0 6 714 3532 0 0 0 3 4 this 3 3740  9 attr_name 1 3680  6 assign 1 3677  
748 0 0 6 715 3741 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
749 0 0 6 716 3741 0 0 34 /**
 * Returns a unit X point.
 */ 0 
750 0 0 6 717 3741 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
751 0 0 6 718 3741 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
752 0 0 7 719 3713 2250 0 100 /**
 * Returns a 2-component vector that shares just the first two components of
 * this vector.
 */ 1 4 this 3 3741  
753 0 0 7 720 3713 2250 0 105 /**
 * Returns a 2-component vector that shares just the first and last components
 * of this vector.
 */ 1 4 this 3 3741  
754 0 0 7 721 3713 2250 0 99 /**
 * Returns a 2-component vector that shares just the last two components of
 * this vector.
 */ 1 4 this 3 3741  
755 0 0 7 725 3740 2629 0 0 1 4 this 3 3741  
756 0 0 7 726 3722 2464 0 0 2 4 this 3 3741  5 other 1 3723  
757 0 0 7 726 3740 2629 0 0 2 4 this 3 3741  5 other 1 3732  
758 0 0 7 727 3731 2562 0 0 2 4 this 3 3741  5 other 1 3741  
759 0 0 7 727 3722 2464 0 0 2 4 this 3 3741  5 other 1 3723  
760 0 0 7 727 3740 2629 0 0 2 4 this 3 3741  5 other 1 3732  
761 0 0 7 728 3740 2629 0 10 /**
 *
 */ 2 4 this 3 3741  5 other 1 3723  
762 0 0 7 729 3740 2629 0 0 2 4 this 3 3741  6 scalar 1 3532  
763 0 0 7 730 3740 2629 0 0 2 4 this 3 3741  6 scalar 1 3532  
764 0 0 6 731 3741 0 0 186 /**
 * Returns the origin of the indicated coordinate system.  This is always 0,
 * 0, 0 with all of our existing coordinate systems; it's hard to imagine it
 * ever being different.
 */ 1 2 cs 1 3545  
765 0 0 7 732 3740 2629 0 146 /**
 * Returns a point described by right, forward, up displacements from the
 * origin, wherever that maps to in the given coordinate system.
 */ 4 5 right 1 3532  3 fwd 1 3532  2 up 1 3532  2 cs 1 3545  
766 0 0 6 733 3680 0 0 0 1 4 this 3 3741  
767 0 0 7 734 3691 0 0 0 0 
768 0 0 7 738 3743 2703 0 0 0 
769 0 0 7 738 3743 2703 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3735  
770 0 0 7 738 3743 2703 0 10 /**
 *
 */ 2 4 copy 1 3717  1 w 1 3526  
771 0 0 7 738 3743 2703 0 0 1 6 param0 0 3744  
772 0 0 7 738 3743 2703 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3726  
773 0 0 7 738 3743 2703 0 10 /**
 *
 */ 1 4 copy 1 3746  
774 0 0 7 738 3743 2703 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
775 0 0 7 738 3743 2703 0 10 /**
 *
 */ 4 1 x 1 3526  1 y 1 3526  1 z 1 3526  1 w 1 3526  
776 0 0 4 739 3676 0 0 0 2 4 this 3 3743  4 size 1 3674  
777 0 0 6 742 3743 0 0 0 2 4 this 3 3743  4 copy 1 3744  
778 0 0 6 742 3743 0 0 0 2 4 this 3 3743  10 fill_value 1 3526  
779 0 0 6 743 3744 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
780 0 0 6 744 3744 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
781 0 0 6 745 3744 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
782 0 0 6 746 3744 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
783 0 0 6 747 3744 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
784 0 0 6 748 3677 0 0 0 1 4 this 3 3744  
785 0 0 6 749 3677 0 0 0 2 4 this 3 3744  9 attr_name 1 3680  
786 0 0 6 750 3532 0 0 0 3 4 this 3 3743  9 attr_name 1 3680  6 assign 1 3677  
787 0 0 4 751 3676 0 0 10 /**
 *
 */ 3 4 this 3 3743  1 i 1 3532  10 assign_val 1 3526  
788 0 0 6 751 3526 0 0 0 2 4 this 3 3744  1 i 1 3532  
789 0 0 6 752 3532 0 0 0 0 
790 0 0 6 753 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3744  
791 0 0 6 754 3526 0 0 10 /**
 *
 */ 2 4 this 3 3744  1 i 1 3532  
792 0 0 4 755 3676 0 0 10 /**
 *
 */ 3 4 this 3 3743  1 i 1 3532  5 value 1 3526  
793 0 0 6 756 3526 0 0 10 /**
 *
 */ 1 4 this 3 3744  
794 0 0 6 757 3526 0 0 10 /**
 *
 */ 1 4 this 3 3744  
795 0 0 6 758 3526 0 0 10 /**
 *
 */ 1 4 this 3 3744  
796 0 0 6 759 3526 0 0 10 /**
 *
 */ 1 4 this 3 3744  
797 0 0 7 760 3716 2323 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3744  
798 0 0 7 761 3671 2032 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3744  
799 0 0 4 762 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
800 0 0 4 763 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
801 0 0 4 764 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
802 0 0 4 765 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
803 0 0 4 771 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3743  1 i 1 3532  5 value 1 3526  
804 0 0 4 772 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
805 0 0 4 773 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
806 0 0 4 774 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
807 0 0 4 775 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 value 1 3526  
808 0 0 4 776 3676 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3744  
809 0 0 6 777 3532 0 0 0 0 
810 0 0 4 779 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3743  10 fill_value 1 3526  
811 0 0 4 780 3676 0 0 10 /**
 *
 */ 5 4 this 3 3743  1 x 1 3526  1 y 1 3526  1 z 1 3526  1 w 1 3526  
812 0 0 6 781 3526 0 0 10 /**
 *
 */ 2 4 this 3 3744  5 other 1 3744  
813 0 0 6 782 3526 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3744  
814 0 0 6 783 3526 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3744  
815 0 0 6 784 3681 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3743  
816 0 0 7 785 3743 2703 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3744  
817 0 0 7 786 3743 2703 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3744  4 onto 1 3744  
818 0 0 6 787 3681 0 0 0 2 4 this 3 3744  5 other 1 3744  
819 0 0 6 788 3681 0 0 0 2 4 this 3 3744  5 other 1 3744  
820 0 0 6 789 3681 0 0 0 2 4 this 3 3744  5 other 1 3744  
821 0 0 6 790 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3744  5 other 1 3744  
822 0 0 6 790 3532 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3744  5 other 1 3744  9 threshold 1 3526  
823 0 0 6 791 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3744  
824 0 0 6 791 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3744  9 threshold 1 3526  
825 0 0 6 792 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3744  4 hash 1 3674  
826 0 0 6 792 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3744  4 hash 1 3674  9 threshold 1 3526  
827 0 0 4 793 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3744  7 hashgen 1 3682  
828 0 0 4 793 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3744  7 hashgen 1 3682  9 threshold 1 3526  
829 0 0 7 794 3743 2703 0 0 1 4 this 3 3744  
830 0 0 7 795 3743 2703 0 0 2 4 this 3 3744  5 other 1 3744  
831 0 0 7 796 3743 2703 0 0 2 4 this 3 3744  5 other 1 3744  
832 0 0 7 797 3743 2703 0 0 2 4 this 3 3744  6 scalar 1 3526  
833 0 0 7 798 3743 2703 0 0 2 4 this 3 3744  6 scalar 1 3526  
834 0 0 6 799 3743 0 0 0 2 4 this 3 3743  5 other 1 3744  
835 0 0 6 800 3743 0 0 0 2 4 this 3 3743  5 other 1 3744  
836 0 0 6 801 3743 0 0 0 2 4 this 3 3743  6 scalar 1 3526  
837 0 0 6 802 3743 0 0 0 2 4 this 3 3743  6 scalar 1 3526  
838 0 0 4 803 3676 0 0 10 /**
 *
 */ 2 4 this 3 3743  5 other 1 3744  
839 0 0 7 804 3743 2703 0 0 2 4 this 3 3744  8 exponent 1 3526  
840 0 0 6 805 3677 0 0 0 2 4 this 3 3743  8 exponent 1 3526  
841 0 0 7 806 3743 2703 0 10 /**
 *
 */ 2 4 this 3 3744  5 other 1 3744  
842 0 0 7 807 3743 2703 0 10 /**
 *
 */ 2 4 this 3 3744  5 other 1 3744  
843 0 0 6 808 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3744  5 other 1 3744  
844 0 0 6 808 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3744  5 other 1 3744  9 threshold 1 3526  
845 0 0 4 809 3676 0 0 10 /**
 *
 */ 2 4 this 3 3744  3 out 1 3684  
846 0 0 6 810 3680 0 0 0 1 4 this 3 3744  
847 0 0 4 811 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3744  11 destination 1 3686  
848 0 0 4 812 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3743  6 source 1 3688  
849 0 0 4 813 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3744  11 destination 1 3686  
850 0 0 4 814 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3743  6 source 1 3688  
851 0 0 7 815 3691 0 0 0 0 
852 0 0 7 819 3748 2714 0 0 0 
853 0 0 7 819 3748 2714 0 10 /**
 *
 */ 1 4 copy 1 3744  
854 0 0 7 819 3748 2714 0 0 1 6 param0 0 3746  
855 0 0 7 819 3748 2714 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
856 0 0 7 819 3748 2714 0 10 /**
 *
 */ 4 1 x 1 3526  1 y 1 3526  1 z 1 3526  1 w 1 3526  
857 0 0 4 820 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3748  10 fill_value 1 3526  
858 0 0 4 821 3676 0 0 10 /**
 *
 */ 5 4 this 3 3748  1 x 1 3526  1 y 1 3526  1 z 1 3526  1 w 1 3526  
859 0 0 4 822 3676 0 0 10 /**
 *
 */ 3 4 this 3 3748  1 i 1 3532  10 assign_val 1 3526  
860 0 0 6 822 3526 0 0 0 2 4 this 3 3746  1 i 1 3532  
861 0 0 6 823 3532 0 0 0 0 
862 0 0 4 824 3676 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3746  
863 0 0 6 825 3532 0 0 0 0 
864 0 0 6 826 3681 0 0 0 2 4 this 3 3746  5 other 1 3746  
865 0 0 6 827 3681 0 0 0 2 4 this 3 3746  5 other 1 3746  
866 0 0 7 828 3691 0 0 0 0 
867 0 0 7 832 3749 2788 0 0 0 
868 0 0 7 832 3749 2788 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3738  
869 0 0 7 832 3749 2788 0 10 /**
 *
 */ 2 4 copy 1 3720  1 w 1 3529  
870 0 0 7 832 3749 2788 0 0 1 6 param0 0 3750  
871 0 0 7 832 3749 2788 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3729  
872 0 0 7 832 3749 2788 0 10 /**
 *
 */ 1 4 copy 1 3752  
873 0 0 7 832 3749 2788 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
874 0 0 7 832 3749 2788 0 10 /**
 *
 */ 4 1 x 1 3529  1 y 1 3529  1 z 1 3529  1 w 1 3529  
875 0 0 4 833 3676 0 0 0 2 4 this 3 3749  4 size 1 3674  
876 0 0 6 836 3749 0 0 0 2 4 this 3 3749  4 copy 1 3750  
877 0 0 6 836 3749 0 0 0 2 4 this 3 3749  10 fill_value 1 3529  
878 0 0 6 837 3750 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
879 0 0 6 838 3750 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
880 0 0 6 839 3750 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
881 0 0 6 840 3750 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
882 0 0 6 841 3750 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
883 0 0 6 842 3677 0 0 0 1 4 this 3 3750  
884 0 0 6 843 3677 0 0 0 2 4 this 3 3750  9 attr_name 1 3680  
885 0 0 6 844 3532 0 0 0 3 4 this 3 3749  9 attr_name 1 3680  6 assign 1 3677  
886 0 0 4 845 3676 0 0 10 /**
 *
 */ 3 4 this 3 3749  1 i 1 3532  10 assign_val 1 3529  
887 0 0 6 845 3529 0 0 0 2 4 this 3 3750  1 i 1 3532  
888 0 0 6 846 3532 0 0 0 0 
889 0 0 6 847 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3750  
890 0 0 6 848 3529 0 0 10 /**
 *
 */ 2 4 this 3 3750  1 i 1 3532  
891 0 0 4 849 3676 0 0 10 /**
 *
 */ 3 4 this 3 3749  1 i 1 3532  5 value 1 3529  
892 0 0 6 850 3529 0 0 10 /**
 *
 */ 1 4 this 3 3750  
893 0 0 6 851 3529 0 0 10 /**
 *
 */ 1 4 this 3 3750  
894 0 0 6 852 3529 0 0 10 /**
 *
 */ 1 4 this 3 3750  
895 0 0 6 853 3529 0 0 10 /**
 *
 */ 1 4 this 3 3750  
896 0 0 7 854 3719 2396 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3750  
897 0 0 7 855 3692 2095 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3750  
898 0 0 4 856 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
899 0 0 4 857 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
900 0 0 4 858 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
901 0 0 4 859 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
902 0 0 4 865 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3749  1 i 1 3532  5 value 1 3529  
903 0 0 4 866 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
904 0 0 4 867 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
905 0 0 4 868 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
906 0 0 4 869 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 value 1 3529  
907 0 0 4 870 3676 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3750  
908 0 0 6 871 3532 0 0 0 0 
909 0 0 4 873 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3749  10 fill_value 1 3529  
910 0 0 4 874 3676 0 0 10 /**
 *
 */ 5 4 this 3 3749  1 x 1 3529  1 y 1 3529  1 z 1 3529  1 w 1 3529  
911 0 0 6 875 3529 0 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3750  
912 0 0 6 876 3529 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3750  
913 0 0 6 877 3529 0 0 72 /**
 * Returns the length of the vector, by the Pythagorean theorem.
 */ 1 4 this 3 3750  
914 0 0 6 878 3681 0 0 127 /**
 * Normalizes the vector in place.  Returns true if the vector was normalized,
 * false if it was a zero-length vector.
 */ 1 4 this 3 3749  
915 0 0 7 879 3749 2788 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3750  
916 0 0 7 880 3749 2788 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3750  4 onto 1 3750  
917 0 0 6 881 3681 0 0 0 2 4 this 3 3750  5 other 1 3750  
918 0 0 6 882 3681 0 0 0 2 4 this 3 3750  5 other 1 3750  
919 0 0 6 883 3681 0 0 0 2 4 this 3 3750  5 other 1 3750  
920 0 0 6 884 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3750  5 other 1 3750  
921 0 0 6 884 3532 0 0 233 /**
 * Sorts vectors lexicographically, componentwise.  Returns a number less than
 * 0 if this vector sorts before the other one, greater than zero if it sorts
 * after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3750  5 other 1 3750  9 threshold 1 3529  
922 0 0 6 885 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3750  
923 0 0 6 885 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3750  9 threshold 1 3529  
924 0 0 6 886 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3750  4 hash 1 3674  
925 0 0 6 886 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3750  4 hash 1 3674  9 threshold 1 3529  
926 0 0 4 887 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3750  7 hashgen 1 3682  
927 0 0 4 887 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3750  7 hashgen 1 3682  9 threshold 1 3529  
928 0 0 7 888 3749 2788 0 0 1 4 this 3 3750  
929 0 0 7 889 3749 2788 0 0 2 4 this 3 3750  5 other 1 3750  
930 0 0 7 890 3749 2788 0 0 2 4 this 3 3750  5 other 1 3750  
931 0 0 7 891 3749 2788 0 0 2 4 this 3 3750  6 scalar 1 3529  
932 0 0 7 892 3749 2788 0 0 2 4 this 3 3750  6 scalar 1 3529  
933 0 0 6 893 3749 0 0 0 2 4 this 3 3749  5 other 1 3750  
934 0 0 6 894 3749 0 0 0 2 4 this 3 3749  5 other 1 3750  
935 0 0 6 895 3749 0 0 0 2 4 this 3 3749  6 scalar 1 3529  
936 0 0 6 896 3749 0 0 0 2 4 this 3 3749  6 scalar 1 3529  
937 0 0 4 897 3676 0 0 10 /**
 *
 */ 2 4 this 3 3749  5 other 1 3750  
938 0 0 7 898 3749 2788 0 0 2 4 this 3 3750  8 exponent 1 3529  
939 0 0 6 899 3677 0 0 0 2 4 this 3 3749  8 exponent 1 3529  
940 0 0 7 900 3749 2788 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3750  
941 0 0 7 901 3749 2788 0 10 /**
 *
 */ 2 4 this 3 3750  5 other 1 3750  
942 0 0 6 902 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3750  5 other 1 3750  
943 0 0 6 902 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3750  5 other 1 3750  9 threshold 1 3529  
944 0 0 4 903 3676 0 0 10 /**
 *
 */ 2 4 this 3 3750  3 out 1 3684  
945 0 0 6 904 3680 0 0 0 1 4 this 3 3750  
946 0 0 4 905 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3750  11 destination 1 3686  
947 0 0 4 906 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3749  6 source 1 3688  
948 0 0 4 907 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3750  11 destination 1 3686  
949 0 0 4 908 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3749  6 source 1 3688  
950 0 0 7 909 3691 0 0 0 0 
951 0 0 7 913 3754 2799 0 0 0 
952 0 0 7 913 3754 2799 0 10 /**
 *
 */ 1 4 copy 1 3750  
953 0 0 7 913 3754 2799 0 0 1 6 param0 0 3752  
954 0 0 7 913 3754 2799 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
955 0 0 7 913 3754 2799 0 10 /**
 *
 */ 4 1 x 1 3529  1 y 1 3529  1 z 1 3529  1 w 1 3529  
956 0 0 4 914 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3754  10 fill_value 1 3529  
957 0 0 4 915 3676 0 0 10 /**
 *
 */ 5 4 this 3 3754  1 x 1 3529  1 y 1 3529  1 z 1 3529  1 w 1 3529  
958 0 0 4 916 3676 0 0 10 /**
 *
 */ 3 4 this 3 3754  1 i 1 3532  10 assign_val 1 3529  
959 0 0 6 916 3529 0 0 0 2 4 this 3 3752  1 i 1 3532  
960 0 0 6 917 3532 0 0 0 0 
961 0 0 4 918 3676 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3752  
962 0 0 6 919 3532 0 0 0 0 
963 0 0 6 920 3681 0 0 0 2 4 this 3 3752  5 other 1 3752  
964 0 0 6 921 3681 0 0 0 2 4 this 3 3752  5 other 1 3752  
965 0 0 7 922 3691 0 0 0 0 
966 0 0 7 926 3755 2869 0 0 0 
967 0 0 7 926 3755 2869 0 84 /**
 * Constructs an LVecBase4 from an LPoint3.  The w coordinate is set to 1.0.
 */ 1 5 point 1 3741  
968 0 0 7 926 3755 2869 0 10 /**
 *
 */ 2 4 copy 1 3723  1 w 1 3532  
969 0 0 7 926 3755 2869 0 0 1 6 param0 0 3756  
970 0 0 7 926 3755 2869 0 85 /**
 * Constructs an LVecBase4 from an LVector3.  The w coordinate is set to 0.0.
 */ 1 6 vector 1 3732  
971 0 0 7 926 3755 2869 0 10 /**
 *
 */ 1 4 copy 1 3758  
972 0 0 7 926 3755 2869 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
973 0 0 7 926 3755 2869 0 10 /**
 *
 */ 4 1 x 1 3532  1 y 1 3532  1 z 1 3532  1 w 1 3532  
974 0 0 4 927 3676 0 0 0 2 4 this 3 3755  4 size 1 3674  
975 0 0 6 930 3755 0 0 0 2 4 this 3 3755  4 copy 1 3756  
976 0 0 6 930 3755 0 0 0 2 4 this 3 3755  10 fill_value 1 3532  
977 0 0 6 931 3756 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
978 0 0 6 932 3756 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
979 0 0 6 933 3756 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
980 0 0 6 934 3756 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
981 0 0 6 935 3756 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
982 0 0 6 936 3677 0 0 0 1 4 this 3 3756  
983 0 0 6 937 3677 0 0 0 2 4 this 3 3756  9 attr_name 1 3680  
984 0 0 6 938 3532 0 0 0 3 4 this 3 3755  9 attr_name 1 3680  6 assign 1 3677  
985 0 0 4 939 3676 0 0 10 /**
 *
 */ 3 4 this 3 3755  1 i 1 3532  10 assign_val 1 3532  
986 0 0 6 939 3532 0 0 0 2 4 this 3 3756  1 i 1 3532  
987 0 0 6 940 3532 0 0 0 0 
988 0 0 6 941 3681 0 0 91 /**
 * Returns true if any component of the vector is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3756  
989 0 0 6 942 3532 0 0 10 /**
 *
 */ 2 4 this 3 3756  1 i 1 3532  
990 0 0 4 943 3676 0 0 10 /**
 *
 */ 3 4 this 3 3755  1 i 1 3532  5 value 1 3532  
991 0 0 6 944 3532 0 0 10 /**
 *
 */ 1 4 this 3 3756  
992 0 0 6 945 3532 0 0 10 /**
 *
 */ 1 4 this 3 3756  
993 0 0 6 946 3532 0 0 10 /**
 *
 */ 1 4 this 3 3756  
994 0 0 6 947 3532 0 0 10 /**
 *
 */ 1 4 this 3 3756  
995 0 0 7 948 3722 2464 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3756  
996 0 0 7 949 3695 2154 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3756  
997 0 0 4 950 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
998 0 0 4 951 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
999 0 0 4 952 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
1000 0 0 4 953 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
1001 0 0 4 959 3676 0 0 152 // These next functions add to an existing value.  i.e.
// foo.set_x(foo.get_x() + value) These are useful to reduce overhead in
// scripting languages: 3 4 this 3 3755  1 i 1 3532  5 value 1 3532  
1002 0 0 4 960 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
1003 0 0 4 961 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
1004 0 0 4 962 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
1005 0 0 4 963 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 value 1 3532  
1006 0 0 4 964 3676 0 0 161 /**
 * Returns the address of the first of the four data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3756  
1007 0 0 6 965 3532 0 0 0 0 
1008 0 0 4 967 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3755  10 fill_value 1 3532  
1009 0 0 4 968 3676 0 0 10 /**
 *
 */ 5 4 this 3 3755  1 x 1 3532  1 y 1 3532  1 z 1 3532  1 w 1 3532  
1010 0 0 6 969 3532 0 0 10 /**
 *
 */ 2 4 this 3 3756  5 other 1 3756  
1011 0 0 6 970 3532 0 0 69 /**
 * Returns the square of the vector's length, cheap and easy.
 */ 1 4 this 3 3756  
1012 0 0 6 971 3681 0 0 0 2 4 this 3 3756  5 other 1 3756  
1013 0 0 6 972 3681 0 0 0 2 4 this 3 3756  5 other 1 3756  
1014 0 0 6 973 3681 0 0 0 2 4 this 3 3756  5 other 1 3756  
1015 0 0 6 974 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3756  5 other 1 3756  
1016 0 0 6 975 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3756  
1017 0 0 6 976 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3756  4 hash 1 3674  
1018 0 0 4 977 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3756  7 hashgen 1 3682  
1019 0 0 7 978 3755 2869 0 0 1 4 this 3 3756  
1020 0 0 7 979 3755 2869 0 0 2 4 this 3 3756  5 other 1 3756  
1021 0 0 7 980 3755 2869 0 0 2 4 this 3 3756  5 other 1 3756  
1022 0 0 7 981 3755 2869 0 0 2 4 this 3 3756  6 scalar 1 3532  
1023 0 0 7 982 3755 2869 0 0 2 4 this 3 3756  6 scalar 1 3532  
1024 0 0 6 983 3755 0 0 0 2 4 this 3 3755  5 other 1 3756  
1025 0 0 6 984 3755 0 0 0 2 4 this 3 3755  5 other 1 3756  
1026 0 0 6 985 3755 0 0 0 2 4 this 3 3755  6 scalar 1 3532  
1027 0 0 6 986 3755 0 0 0 2 4 this 3 3755  6 scalar 1 3532  
1028 0 0 4 987 3676 0 0 10 /**
 *
 */ 2 4 this 3 3755  5 other 1 3756  
1029 0 0 7 988 3755 2869 0 0 2 4 this 3 3756  8 exponent 1 3532  
1030 0 0 6 989 3677 0 0 0 2 4 this 3 3755  8 exponent 1 3532  
1031 0 0 7 990 3755 2869 0 10 /**
 *
 */ 2 4 this 3 3756  5 other 1 3756  
1032 0 0 7 991 3755 2869 0 10 /**
 *
 */ 2 4 this 3 3756  5 other 1 3756  
1033 0 0 6 992 3681 0 0 116 /**
 * Returns true if two vectors are memberwise equal within a default tolerance
 * based on the numeric type.
 */ 2 4 this 3 3756  5 other 1 3756  
1034 0 0 6 992 3681 0 0 92 /**
 * Returns true if two vectors are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3756  5 other 1 3756  9 threshold 1 3532  
1035 0 0 4 993 3676 0 0 10 /**
 *
 */ 2 4 this 3 3756  3 out 1 3684  
1036 0 0 6 994 3680 0 0 0 1 4 this 3 3756  
1037 0 0 4 995 3676 0 0 332 /**
 * Writes the vector to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the vector, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3756  11 destination 1 3686  
1038 0 0 4 996 3676 0 0 114 /**
 * Reads the vector from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3755  6 source 1 3688  
1039 0 0 4 997 3676 0 0 205 /**
 * Writes the vector to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the vector using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3756  11 destination 1 3686  
1040 0 0 4 998 3676 0 0 67 /**
 * Reads the vector from the Datagram using get_stdfloat().
 */ 2 4 this 3 3755  6 source 1 3688  
1041 0 0 7 999 3691 0 0 0 0 
1042 0 0 7 1003 3760 2880 0 0 0 
1043 0 0 7 1003 3760 2880 0 10 /**
 *
 */ 1 4 copy 1 3756  
1044 0 0 7 1003 3760 2880 0 0 1 6 param0 0 3758  
1045 0 0 7 1003 3760 2880 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
1046 0 0 7 1003 3760 2880 0 10 /**
 *
 */ 4 1 x 1 3532  1 y 1 3532  1 z 1 3532  1 w 1 3532  
1047 0 0 4 1004 3676 0 0 129 /**
 * Sets each element of the vector to the indicated fill_value.  This is
 * particularly useful for initializing to zero.
 */ 2 4 this 3 3760  10 fill_value 1 3532  
1048 0 0 4 1005 3676 0 0 10 /**
 *
 */ 5 4 this 3 3760  1 x 1 3532  1 y 1 3532  1 z 1 3532  1 w 1 3532  
1049 0 0 4 1006 3676 0 0 10 /**
 *
 */ 3 4 this 3 3760  1 i 1 3532  10 assign_val 1 3532  
1050 0 0 6 1006 3532 0 0 0 2 4 this 3 3758  1 i 1 3532  
1051 0 0 6 1007 3532 0 0 0 0 
1052 0 0 4 1008 3676 0 0 162 /**
 * Returns the address of the first of the three data elements in the vector.
 * The remaining elements occupy the next positions consecutively in memory.
 */ 1 4 this 3 3758  
1053 0 0 6 1009 3532 0 0 0 0 
1054 0 0 6 1010 3681 0 0 0 2 4 this 3 3758  5 other 1 3758  
1055 0 0 6 1011 3681 0 0 0 2 4 this 3 3758  5 other 1 3758  
1056 0 0 7 1012 3691 0 0 0 0 
1057 0 0 7 1015 3761 2900 0 0 0 
1058 0 0 7 1015 3761 2900 0 10 /**
 *
 */ 2 4 copy 1 3717  1 w 1 3526  
1059 0 0 7 1015 3761 2900 0 10 /**
 *
 */ 1 4 copy 1 3744  
1060 0 0 7 1015 3761 2900 0 0 1 6 param0 0 3762  
1061 0 0 7 1015 3761 2900 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
1062 0 0 7 1015 3761 2900 0 10 /**
 *
 */ 4 1 x 1 3526  1 y 1 3526  1 z 1 3526  1 w 1 3526  
1063 0 0 6 1016 3677 0 0 0 2 4 this 3 3762  9 attr_name 1 3680  
1064 0 0 6 1017 3532 0 0 0 3 4 this 3 3761  9 attr_name 1 3680  6 assign 1 3677  
1065 0 0 6 1018 3762 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1066 0 0 6 1019 3762 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1067 0 0 6 1020 3762 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1068 0 0 6 1021 3762 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1069 0 0 6 1022 3762 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1070 0 0 7 1023 3725 2502 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3762  
1071 0 0 7 1024 3698 2172 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3762  
1072 0 0 7 1027 3761 2900 0 0 1 4 this 3 3762  
1073 0 0 7 1028 3743 2703 0 0 2 4 this 3 3762  5 other 1 3744  
1074 0 0 7 1028 3761 2900 0 0 2 4 this 3 3762  5 other 1 3762  
1075 0 0 7 1029 3743 2703 0 0 2 4 this 3 3762  5 other 1 3744  
1076 0 0 7 1029 3761 2900 0 0 2 4 this 3 3762  5 other 1 3762  
1077 0 0 7 1030 3761 2900 0 0 2 4 this 3 3762  6 scalar 1 3526  
1078 0 0 7 1031 3761 2900 0 0 2 4 this 3 3762  6 scalar 1 3526  
1079 0 0 7 1032 3761 2900 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3762  
1080 0 0 7 1033 3761 2900 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3762  4 onto 1 3744  
1081 0 0 6 1034 3680 0 0 0 1 4 this 3 3762  
1082 0 0 7 1035 3691 0 0 0 0 
1083 0 0 7 1038 3764 2920 0 0 0 
1084 0 0 7 1038 3764 2920 0 10 /**
 *
 */ 2 4 copy 1 3720  1 w 1 3529  
1085 0 0 7 1038 3764 2920 0 10 /**
 *
 */ 1 4 copy 1 3750  
1086 0 0 7 1038 3764 2920 0 0 1 6 param0 0 3765  
1087 0 0 7 1038 3764 2920 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
1088 0 0 7 1038 3764 2920 0 10 /**
 *
 */ 4 1 x 1 3529  1 y 1 3529  1 z 1 3529  1 w 1 3529  
1089 0 0 6 1039 3677 0 0 0 2 4 this 3 3765  9 attr_name 1 3680  
1090 0 0 6 1040 3532 0 0 0 3 4 this 3 3764  9 attr_name 1 3680  6 assign 1 3677  
1091 0 0 6 1041 3765 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1092 0 0 6 1042 3765 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1093 0 0 6 1043 3765 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1094 0 0 6 1044 3765 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1095 0 0 6 1045 3765 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1096 0 0 7 1046 3728 2536 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3765  
1097 0 0 7 1047 3701 2190 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3765  
1098 0 0 7 1050 3764 2920 0 0 1 4 this 3 3765  
1099 0 0 7 1051 3749 2788 0 0 2 4 this 3 3765  5 other 1 3750  
1100 0 0 7 1051 3764 2920 0 0 2 4 this 3 3765  5 other 1 3765  
1101 0 0 7 1052 3749 2788 0 0 2 4 this 3 3765  5 other 1 3750  
1102 0 0 7 1052 3764 2920 0 0 2 4 this 3 3765  5 other 1 3765  
1103 0 0 7 1053 3764 2920 0 0 2 4 this 3 3765  6 scalar 1 3529  
1104 0 0 7 1054 3764 2920 0 0 2 4 this 3 3765  6 scalar 1 3529  
1105 0 0 7 1055 3764 2920 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3765  
1106 0 0 7 1056 3764 2920 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3765  4 onto 1 3750  
1107 0 0 6 1057 3680 0 0 0 1 4 this 3 3765  
1108 0 0 7 1058 3691 0 0 0 0 
1109 0 0 7 1061 3767 2938 0 0 0 
1110 0 0 7 1061 3767 2938 0 10 /**
 *
 */ 2 4 copy 1 3723  1 w 1 3532  
1111 0 0 7 1061 3767 2938 0 10 /**
 *
 */ 1 4 copy 1 3756  
1112 0 0 7 1061 3767 2938 0 0 1 6 param0 0 3768  
1113 0 0 7 1061 3767 2938 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
1114 0 0 7 1061 3767 2938 0 10 /**
 *
 */ 4 1 x 1 3532  1 y 1 3532  1 z 1 3532  1 w 1 3532  
1115 0 0 6 1062 3677 0 0 0 2 4 this 3 3768  9 attr_name 1 3680  
1116 0 0 6 1063 3532 0 0 0 3 4 this 3 3767  9 attr_name 1 3680  6 assign 1 3677  
1117 0 0 6 1064 3768 0 0 40 /**
 * Returns a zero-length vector.
 */ 0 
1118 0 0 6 1065 3768 0 0 35 /**
 * Returns a unit X vector.
 */ 0 
1119 0 0 6 1066 3768 0 0 35 /**
 * Returns a unit Y vector.
 */ 0 
1120 0 0 6 1067 3768 0 0 35 /**
 * Returns a unit Z vector.
 */ 0 
1121 0 0 6 1068 3768 0 0 35 /**
 * Returns a unit W vector.
 */ 0 
1122 0 0 7 1069 3731 2562 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3768  
1123 0 0 7 1070 3704 2204 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3768  
1124 0 0 7 1073 3767 2938 0 0 1 4 this 3 3768  
1125 0 0 7 1074 3755 2869 0 0 2 4 this 3 3768  5 other 1 3756  
1126 0 0 7 1074 3767 2938 0 0 2 4 this 3 3768  5 other 1 3768  
1127 0 0 7 1075 3755 2869 0 0 2 4 this 3 3768  5 other 1 3756  
1128 0 0 7 1075 3767 2938 0 0 2 4 this 3 3768  5 other 1 3768  
1129 0 0 7 1076 3767 2938 0 0 2 4 this 3 3768  6 scalar 1 3532  
1130 0 0 7 1077 3767 2938 0 0 2 4 this 3 3768  6 scalar 1 3532  
1131 0 0 6 1078 3680 0 0 0 1 4 this 3 3768  
1132 0 0 7 1079 3691 0 0 0 0 
1133 0 0 7 1082 3770 2958 0 0 0 
1134 0 0 7 1082 3770 2958 0 0 1 6 param0 0 3771  
1135 0 0 7 1082 3770 2958 0 10 /**
 *
 */ 2 4 copy 1 3717  1 w 1 3526  
1136 0 0 7 1082 3770 2958 0 10 /**
 *
 */ 1 4 copy 1 3744  
1137 0 0 7 1082 3770 2958 0 10 /**
 *
 */ 1 10 fill_value 1 3526  
1138 0 0 7 1082 3770 2958 0 10 /**
 *
 */ 4 1 x 1 3526  1 y 1 3526  1 z 1 3526  1 w 1 3526  
1139 0 0 6 1083 3677 0 0 0 2 4 this 3 3771  9 attr_name 1 3680  
1140 0 0 6 1084 3532 0 0 0 3 4 this 3 3770  9 attr_name 1 3680  6 assign 1 3677  
1141 0 0 6 1085 3771 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1142 0 0 6 1086 3771 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1143 0 0 6 1087 3771 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1144 0 0 6 1088 3771 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1145 0 0 6 1089 3771 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1146 0 0 7 1090 3734 2585 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3771  
1147 0 0 7 1091 3707 2220 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3771  
1148 0 0 7 1094 3770 2958 0 0 1 4 this 3 3771  
1149 0 0 7 1095 3743 2703 0 0 2 4 this 3 3771  5 other 1 3744  
1150 0 0 7 1095 3770 2958 0 0 2 4 this 3 3771  5 other 1 3762  
1151 0 0 7 1096 3761 2900 0 0 2 4 this 3 3771  5 other 1 3771  
1152 0 0 7 1096 3743 2703 0 0 2 4 this 3 3771  5 other 1 3744  
1153 0 0 7 1096 3770 2958 0 0 2 4 this 3 3771  5 other 1 3762  
1154 0 0 7 1097 3770 2958 0 0 2 4 this 3 3771  6 scalar 1 3526  
1155 0 0 7 1098 3770 2958 0 0 2 4 this 3 3771  6 scalar 1 3526  
1156 0 0 7 1099 3770 2958 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3771  
1157 0 0 7 1100 3770 2958 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3771  4 onto 1 3744  
1158 0 0 6 1101 3680 0 0 0 1 4 this 3 3771  
1159 0 0 7 1102 3691 0 0 0 0 
1160 0 0 7 1105 3773 2978 0 0 0 
1161 0 0 7 1105 3773 2978 0 0 1 6 param0 0 3774  
1162 0 0 7 1105 3773 2978 0 10 /**
 *
 */ 2 4 copy 1 3720  1 w 1 3529  
1163 0 0 7 1105 3773 2978 0 10 /**
 *
 */ 1 4 copy 1 3750  
1164 0 0 7 1105 3773 2978 0 10 /**
 *
 */ 1 10 fill_value 1 3529  
1165 0 0 7 1105 3773 2978 0 10 /**
 *
 */ 4 1 x 1 3529  1 y 1 3529  1 z 1 3529  1 w 1 3529  
1166 0 0 6 1106 3677 0 0 0 2 4 this 3 3774  9 attr_name 1 3680  
1167 0 0 6 1107 3532 0 0 0 3 4 this 3 3773  9 attr_name 1 3680  6 assign 1 3677  
1168 0 0 6 1108 3774 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1169 0 0 6 1109 3774 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1170 0 0 6 1110 3774 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1171 0 0 6 1111 3774 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1172 0 0 6 1112 3774 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1173 0 0 7 1113 3737 2608 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3774  
1174 0 0 7 1114 3710 2236 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3774  
1175 0 0 7 1117 3773 2978 0 0 1 4 this 3 3774  
1176 0 0 7 1118 3749 2788 0 0 2 4 this 3 3774  5 other 1 3750  
1177 0 0 7 1118 3773 2978 0 0 2 4 this 3 3774  5 other 1 3765  
1178 0 0 7 1119 3764 2920 0 0 2 4 this 3 3774  5 other 1 3774  
1179 0 0 7 1119 3749 2788 0 0 2 4 this 3 3774  5 other 1 3750  
1180 0 0 7 1119 3773 2978 0 0 2 4 this 3 3774  5 other 1 3765  
1181 0 0 7 1120 3773 2978 0 0 2 4 this 3 3774  6 scalar 1 3529  
1182 0 0 7 1121 3773 2978 0 0 2 4 this 3 3774  6 scalar 1 3529  
1183 0 0 7 1122 3773 2978 0 160 /**
 * Normalizes the vector and returns the normalized vector as a copy.  If the
 * vector was a zero-length vector, a zero length vector will be returned.
 */ 1 4 this 3 3774  
1184 0 0 7 1123 3773 2978 0 152 /**
 * Returns a new vector representing the projection of this vector onto
 * another one.  The resulting vector will be a scalar multiple of onto.
 */ 2 4 this 3 3774  4 onto 1 3750  
1185 0 0 6 1124 3680 0 0 0 1 4 this 3 3774  
1186 0 0 7 1125 3691 0 0 0 0 
1187 0 0 7 1128 3776 2996 0 0 0 
1188 0 0 7 1128 3776 2996 0 0 1 6 param0 0 3777  
1189 0 0 7 1128 3776 2996 0 10 /**
 *
 */ 2 4 copy 1 3723  1 w 1 3532  
1190 0 0 7 1128 3776 2996 0 10 /**
 *
 */ 1 4 copy 1 3756  
1191 0 0 7 1128 3776 2996 0 10 /**
 *
 */ 1 10 fill_value 1 3532  
1192 0 0 7 1128 3776 2996 0 10 /**
 *
 */ 4 1 x 1 3532  1 y 1 3532  1 z 1 3532  1 w 1 3532  
1193 0 0 6 1129 3677 0 0 0 2 4 this 3 3777  9 attr_name 1 3680  
1194 0 0 6 1130 3532 0 0 0 3 4 this 3 3776  9 attr_name 1 3680  6 assign 1 3677  
1195 0 0 6 1131 3777 0 0 39 /**
 * Returns a zero-length point.
 */ 0 
1196 0 0 6 1132 3777 0 0 34 /**
 * Returns a unit X point.
 */ 0 
1197 0 0 6 1133 3777 0 0 34 /**
 * Returns a unit Y point.
 */ 0 
1198 0 0 6 1134 3777 0 0 34 /**
 * Returns a unit Z point.
 */ 0 
1199 0 0 6 1135 3777 0 0 34 /**
 * Returns a unit W point.
 */ 0 
1200 0 0 7 1136 3740 2629 0 58 /**
 * Returns the x, y and z component of this vector
 */ 1 4 this 3 3777  
1201 0 0 7 1137 3713 2250 0 55 /**
 * Returns the x and y component of this vector
 */ 1 4 this 3 3777  
1202 0 0 7 1140 3776 2996 0 0 1 4 this 3 3777  
1203 0 0 7 1141 3755 2869 0 0 2 4 this 3 3777  5 other 1 3756  
1204 0 0 7 1141 3776 2996 0 0 2 4 this 3 3777  5 other 1 3768  
1205 0 0 7 1142 3767 2938 0 0 2 4 this 3 3777  5 other 1 3777  
1206 0 0 7 1142 3755 2869 0 0 2 4 this 3 3777  5 other 1 3756  
1207 0 0 7 1142 3776 2996 0 0 2 4 this 3 3777  5 other 1 3768  
1208 0 0 7 1143 3776 2996 0 0 2 4 this 3 3777  6 scalar 1 3532  
1209 0 0 7 1144 3776 2996 0 0 2 4 this 3 3777  6 scalar 1 3532  
1210 0 0 6 1145 3680 0 0 0 1 4 this 3 3777  
1211 0 0 7 1146 3691 0 0 0 0 
1212 0 0 7 1162 3779 3084 0 10 /**
 *
 */ 0 
1213 0 0 7 1162 3779 3084 0 10 /**
 *
 */ 1 5 other 1 3780  
1214 0 0 7 1162 3779 3084 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3717  6 param1 0 3717  6 param2 0 3717  
1215 0 0 7 1162 3779 3084 0 10 /**
 *
 */ 9 6 param0 0 3526  6 param1 0 3526  6 param2 0 3526  6 param3 0 3526  6 param4 0 3526  6 param5 0 3526  6 param6 0 3526  6 param7 0 3526  6 param8 0 3526  
1216 0 0 6 1163 3779 0 0 10 /**
 *
 */ 2 4 this 3 3779  5 other 1 3780  
1217 0 0 6 1163 3779 0 0 10 /**
 *
 */ 2 4 this 3 3779  10 fill_value 1 3526  
1218 0 0 4 1164 3676 0 0 0 2 4 this 3 3779  4 size 1 3674  
1219 0 0 6 1167 3677 0 0 0 1 4 this 3 3780  
1220 0 0 4 1168 3676 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3779  10 fill_value 1 3526  
1221 0 0 4 1169 3676 0 0 10 /**
 *
 */ 10 4 this 3 3779  3 e00 1 3526  3 e01 1 3526  3 e02 1 3526  3 e10 1 3526  3 e11 1 3526  3 e12 1 3526  3 e20 1 3526  3 e21 1 3526  3 e22 1 3526  
1222 0 0 7 1170 3782 3001 0 0 2 4 this 3 3779  1 i 1 3532  
1223 0 0 7 1170 3783 3006 0 0 2 4 this 3 3780  1 i 1 3532  
1224 0 0 6 1171 3532 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1225 0 0 4 1172 3676 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3779  3 row 1 3532  1 v 1 3672  
1226 0 0 4 1172 3676 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3779  3 row 1 3532  1 v 1 3717  
1227 0 0 4 1173 3676 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3779  3 col 1 3532  1 v 1 3672  
1228 0 0 4 1173 3676 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3779  3 col 1 3532  1 v 1 3717  
1229 0 0 4 1174 3676 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3780  10 result_vec 1 3716  3 row 1 3532  
1230 0 0 7 1174 3716 2323 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3780  3 row 1 3532  
1231 0 0 7 1175 3716 2323 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3780  3 col 1 3532  
1232 0 0 7 1182 3671 2032 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3780  3 row 1 3532  
1233 0 0 7 1183 3671 2032 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3780  3 col 1 3532  
1234 0 0 4 1186 3676 0 0 10 /**
 *
 */ 3 4 this 3 3779  3 row 1 3532  3 col 1 3532  
1235 0 0 6 1186 3526 0 0 0 3 4 this 3 3780  3 row 1 3532  3 col 1 3532  
1236 0 0 6 1187 3681 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3780  
1237 0 0 6 1188 3681 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3780  
1238 0 0 6 1189 3526 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3780  3 row 1 3532  3 col 1 3532  
1239 0 0 4 1190 3676 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3779  3 row 1 3532  3 col 1 3532  5 value 1 3526  
1240 0 0 4 1191 3676 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3780  
1241 0 0 6 1192 3532 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3780  
1242 0 0 6 1193 3681 0 0 0 2 4 this 3 3780  5 other 1 3780  
1243 0 0 6 1194 3681 0 0 0 2 4 this 3 3780  5 other 1 3780  
1244 0 0 6 1195 3681 0 0 0 2 4 this 3 3780  5 other 1 3780  
1245 0 0 6 1196 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3780  5 other 1 3780  
1246 0 0 6 1196 3532 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3780  5 other 1 3780  9 threshold 1 3526  
1247 0 0 6 1197 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3780  
1248 0 0 6 1197 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3780  9 threshold 1 3526  
1249 0 0 6 1198 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3780  4 hash 1 3674  
1250 0 0 6 1198 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3780  4 hash 1 3674  9 threshold 1 3526  
1251 0 0 7 1199 3716 2323 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3780  1 v 1 3717  
1252 0 0 7 1200 3671 2032 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3780  1 v 1 3672  
1253 0 0 7 1201 3671 2032 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3780  1 v 1 3672  
1254 0 0 7 1201 3716 2323 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3780  1 v 1 3717  
1255 0 0 7 1202 3716 2323 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3780  1 v 1 3717  
1256 0 0 4 1203 3676 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3780  1 v 1 3716  
1257 0 0 4 1204 3676 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3780  1 v 1 3671  
1258 0 0 4 1205 3676 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3780  1 v 1 3671  
1259 0 0 4 1205 3676 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3780  1 v 1 3716  
1260 0 0 4 1206 3676 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3780  1 v 1 3716  
1261 0 0 4 1207 3676 0 0 25 // this = other1 * other2 3 4 this 3 3779  6 other1 1 3780  6 other2 1 3780  
1262 0 0 7 1208 3779 3084 0 0 2 4 this 3 3780  5 other 1 3780  
1263 0 0 7 1208 3779 3084 0 0 2 4 this 3 3780  6 scalar 1 3526  
1264 0 0 7 1209 3779 3084 0 0 2 4 this 3 3780  6 scalar 1 3526  
1265 0 0 6 1210 3779 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3779  5 other 1 3780  
1266 0 0 6 1211 3779 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3779  5 other 1 3780  
1267 0 0 6 1212 3779 0 0 10 /**
 *
 */ 2 4 this 3 3779  5 other 1 3780  
1268 0 0 6 1212 3779 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3779  6 scalar 1 3526  
1269 0 0 6 1213 3779 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3779  6 scalar 1 3526  
1270 0 0 4 1214 3676 0 0 10 /**
 *
 */ 2 4 this 3 3779  5 other 1 3780  
1271 0 0 6 1215 3526 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3780  
1272 0 0 4 1216 3676 0 0 10 /**
 *
 */ 2 4 this 3 3779  5 other 1 3780  
1273 0 0 4 1217 3676 0 0 10 /**
 *
 */ 1 4 this 3 3779  
1274 0 0 6 1218 3681 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3779  5 other 1 3780  
1275 0 0 6 1219 3681 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3779  
1276 0 0 6 1220 3681 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3779  5 other 1 3780  
1277 0 0 6 1220 3681 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3779  5 other 1 3784  
1278 0 0 6 1221 3780 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1279 0 0 4 1222 3676 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3779  5 trans 1 3672  
1280 0 0 4 1223 3676 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3779  5 angle 1 3526  
1281 0 0 4 1223 3676 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3779  5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1282 0 0 4 1224 3676 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3779  5 scale 1 3672  
1283 0 0 4 1224 3676 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3779  5 scale 1 3717  
1284 0 0 7 1225 3779 3084 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3672  
1285 0 0 7 1225 3779 3084 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3526  2 ty 1 3526  
1286 0 0 7 1226 3779 3084 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3526  
1287 0 0 7 1226 3779 3084 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1288 0 0 7 1227 3779 3084 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3672  
1289 0 0 7 1227 3779 3084 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3717  
1290 0 0 7 1227 3779 3084 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3526  2 sy 1 3526  
1291 0 0 7 1227 3779 3084 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3526  2 sy 1 3526  2 sz 1 3526  
1292 0 0 4 1228 3676 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3779  5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1293 0 0 7 1229 3779 3084 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1294 0 0 4 1230 3676 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3779  5 shear 1 3717  2 cs 1 3545  
1295 0 0 7 1231 3779 3084 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3717  2 cs 1 3545  
1296 0 0 7 1231 3779 3084 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3526  4 shxz 1 3526  4 shyz 1 3526  2 cs 1 3545  
1297 0 0 4 1232 3676 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3779  5 scale 1 3717  5 shear 1 3717  2 cs 1 3545  
1298 0 0 7 1233 3779 3084 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3717  5 shear 1 3717  2 cs 1 3545  
1299 0 0 7 1233 3779 3084 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3526  2 sy 1 3526  2 sz 1 3526  4 shxy 1 3526  4 shxz 1 3526  4 shyz 1 3526  2 cs 1 3545  
1300 0 0 6 1234 3780 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3545  2 to 1 3545  
1301 0 0 6 1235 3681 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3780  5 other 1 3780  
1302 0 0 6 1235 3681 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3780  5 other 1 3780  9 threshold 1 3526  
1303 0 0 4 1236 3676 0 0 10 /**
 *
 */ 2 4 this 3 3780  3 out 1 3684  
1304 0 0 4 1237 3676 0 0 10 /**
 *
 */ 3 4 this 3 3780  3 out 1 3684  12 indent_level 1 3532  
1305 0 0 6 1238 3680 0 0 0 1 4 this 3 3780  
1306 0 0 4 1239 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3780  7 hashgen 1 3682  
1307 0 0 4 1239 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3780  7 hashgen 1 3682  9 threshold 1 3526  
1308 0 0 4 1240 3676 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3780  11 destination 1 3686  
1309 0 0 4 1241 3676 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3779  4 scan 1 3688  
1310 0 0 4 1242 3676 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3780  11 destination 1 3686  
1311 0 0 4 1243 3676 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3779  6 source 1 3688  
1312 0 0 7 1244 3691 0 0 0 0 
1313 0 0 7 1154 3782 3001 0 0 1 6 param0 0 3786  
1314 0 0 4 1151 3676 0 0 10 /**
 *
 */ 3 4 this 3 3782  1 i 1 3532  10 assign_val 1 3526  
1315 0 0 6 1151 3526 0 0 0 2 4 this 3 3786  1 i 1 3532  
1316 0 0 6 1152 3532 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1317 0 0 6 1153 3717 0 0 0 1 4 this 3 3786  
1318 0 0 7 1160 3783 3006 0 0 1 6 param0 0 3788  
1319 0 0 6 1157 3526 0 0 0 2 4 this 3 3788  1 i 1 3532  
1320 0 0 6 1158 3532 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1321 0 0 6 1159 3717 0 0 0 1 4 this 3 3788  
1322 0 0 7 1262 3790 3184 0 10 /**
 *
 */ 0 
1323 0 0 7 1262 3790 3184 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3780  
1324 0 0 7 1262 3790 3184 0 10 /**
 *
 */ 2 6 upper3 1 3780  5 trans 1 3717  
1325 0 0 7 1262 3790 3184 0 10 /**
 *
 */ 1 5 other 1 3784  
1326 0 0 7 1262 3790 3184 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3744  6 param1 0 3744  6 param2 0 3744  6 param3 0 3744  
1327 0 0 7 1262 3790 3184 0 10 /**
 *
 */ 1 5 other 1 3791  
1328 0 0 7 1262 3790 3184 0 10 /**
 *
 */ 16 6 param0 0 3526  6 param1 0 3526  6 param2 0 3526  6 param3 0 3526  6 param4 0 3526  6 param5 0 3526  6 param6 0 3526  6 param7 0 3526  6 param8 0 3526  6 param9 0 3526  7 param10 0 3526  7 param11 0 3526  7 param12 0 3526  7 param13 0 3526  7 param14 0 3526  7 param15 0 3526  
1329 0 0 6 1263 3790 0 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3784  
1330 0 0 6 1263 3790 0 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3791  
1331 0 0 6 1263 3790 0 0 10 /**
 *
 */ 2 4 this 3 3790  10 fill_value 1 3526  
1332 0 0 4 1264 3676 0 0 0 2 4 this 3 3790  4 size 1 3674  
1333 0 0 6 1267 3677 0 0 0 1 4 this 3 3784  
1334 0 0 4 1268 3676 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3790  10 fill_value 1 3526  
1335 0 0 4 1269 3676 0 0 10 /**
 *
 */ 17 4 this 3 3790  3 e00 1 3526  3 e01 1 3526  3 e02 1 3526  3 e03 1 3526  3 e10 1 3526  3 e11 1 3526  3 e12 1 3526  3 e13 1 3526  3 e20 1 3526  3 e21 1 3526  3 e22 1 3526  3 e23 1 3526  3 e30 1 3526  3 e31 1 3526  3 e32 1 3526  3 e33 1 3526  
1336 0 0 4 1270 3676 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3790  6 upper3 1 3780  
1337 0 0 7 1271 3779 3084 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3784  
1338 0 0 7 1272 3793 3091 0 0 2 4 this 3 3790  1 i 1 3532  
1339 0 0 7 1272 3794 3096 0 0 2 4 this 3 3784  1 i 1 3532  
1340 0 0 6 1273 3532 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1341 0 0 4 1274 3676 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3790  3 row 1 3532  1 v 1 3717  
1342 0 0 4 1274 3676 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3790  3 row 1 3532  1 v 1 3744  
1343 0 0 4 1275 3676 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3790  3 col 1 3532  1 v 1 3717  
1344 0 0 4 1275 3676 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3790  3 col 1 3532  1 v 1 3744  
1345 0 0 4 1276 3676 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3784  10 result_vec 1 3743  3 row 1 3532  
1346 0 0 7 1276 3743 2703 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3784  3 row 1 3532  
1347 0 0 7 1277 3743 2703 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3784  3 col 1 3532  
1348 0 0 4 1278 3676 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3784  10 result_vec 1 3716  3 row 1 3532  
1349 0 0 7 1278 3716 2323 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3784  3 row 1 3532  
1350 0 0 7 1286 3716 2323 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3784  3 col 1 3532  
1351 0 0 4 1287 3676 0 0 10 /**
 *
 */ 3 4 this 3 3790  3 row 1 3532  3 col 1 3532  
1352 0 0 6 1287 3526 0 0 0 3 4 this 3 3784  3 row 1 3532  3 col 1 3532  
1353 0 0 6 1288 3681 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3784  
1354 0 0 6 1289 3681 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3784  
1355 0 0 6 1290 3526 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3784  3 row 1 3532  3 col 1 3532  
1356 0 0 4 1291 3676 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3790  3 row 1 3532  3 col 1 3532  5 value 1 3526  
1357 0 0 4 1292 3676 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3784  
1358 0 0 6 1293 3532 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3784  
1359 0 0 4 1294 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3790  
1360 0 0 4 1294 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3784  
1361 0 0 4 1295 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3790  
1362 0 0 4 1295 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3784  
1363 0 0 6 1296 3681 0 0 0 2 4 this 3 3784  5 other 1 3784  
1364 0 0 6 1297 3681 0 0 0 2 4 this 3 3784  5 other 1 3784  
1365 0 0 6 1298 3681 0 0 0 2 4 this 3 3784  5 other 1 3784  
1366 0 0 6 1299 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3784  5 other 1 3784  
1367 0 0 6 1299 3532 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3784  5 other 1 3784  9 threshold 1 3526  
1368 0 0 6 1300 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3784  
1369 0 0 6 1300 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3784  9 threshold 1 3526  
1370 0 0 6 1301 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3784  4 hash 1 3674  
1371 0 0 6 1301 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3784  4 hash 1 3674  9 threshold 1 3526  
1372 0 0 7 1302 3743 2703 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3784  1 v 1 3744  
1373 0 0 7 1303 3716 2323 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3784  1 v 1 3717  
1374 0 0 7 1304 3716 2323 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3784  1 v 1 3717  
1375 0 0 7 1305 3716 2323 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3784  1 v 1 3717  
1376 0 0 7 1306 3716 2323 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3784  1 v 1 3717  
1377 0 0 4 1307 3676 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3784  1 v 1 3743  
1378 0 0 4 1308 3676 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3784  1 v 1 3716  
1379 0 0 4 1309 3676 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3784  1 v 1 3716  
1380 0 0 4 1310 3676 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3784  1 v 1 3716  
1381 0 0 4 1311 3676 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3784  1 v 1 3716  
1382 0 0 4 1312 3676 0 0 25 // this = other1 * other2 3 4 this 3 3790  6 other1 1 3784  6 other2 1 3784  
1383 0 0 7 1313 3790 3184 0 0 2 4 this 3 3784  5 other 1 3784  
1384 0 0 7 1313 3790 3184 0 0 2 4 this 3 3784  6 scalar 1 3526  
1385 0 0 7 1314 3790 3184 0 0 2 4 this 3 3784  6 scalar 1 3526  
1386 0 0 6 1315 3790 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3790  5 other 1 3784  
1387 0 0 6 1316 3790 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3790  5 other 1 3784  
1388 0 0 6 1317 3790 0 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3784  
1389 0 0 6 1317 3790 0 0 10 /**
 *
 */ 2 4 this 3 3790  6 scalar 1 3526  
1390 0 0 6 1318 3790 0 0 10 /**
 *
 */ 2 4 this 3 3790  6 scalar 1 3526  
1391 0 0 4 1319 3676 0 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3784  
1392 0 0 4 1320 3676 0 0 10 /**
 *
 */ 2 4 this 3 3790  5 other 1 3784  
1393 0 0 4 1321 3676 0 0 10 /**
 *
 */ 1 4 this 3 3790  
1394 0 0 6 1322 3681 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3790  5 other 1 3784  
1395 0 0 6 1323 3681 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3790  5 other 1 3784  
1396 0 0 6 1324 3681 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3790  
1397 0 0 4 1325 3676 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3790  5 other 1 3784  6 weight 1 3526  
1398 0 0 6 1326 3784 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1399 0 0 6 1327 3784 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1400 0 0 6 1328 3784 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1401 0 0 4 1329 3676 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3790  5 trans 1 3717  
1402 0 0 4 1330 3676 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3790  5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1403 0 0 4 1331 3676 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3790  5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1404 0 0 4 1332 3676 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3790  5 scale 1 3717  
1405 0 0 4 1333 3676 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3790  5 shear 1 3717  2 cs 1 3545  
1406 0 0 4 1334 3676 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3790  5 scale 1 3717  5 shear 1 3717  2 cs 1 3545  
1407 0 0 7 1335 3790 3184 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3717  
1408 0 0 7 1335 3790 3184 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3526  2 ty 1 3526  2 tz 1 3526  
1409 0 0 7 1336 3790 3184 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1410 0 0 7 1337 3790 3184 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3526  4 axis 1 3717  2 cs 1 3545  
1411 0 0 7 1338 3790 3184 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3717  
1412 0 0 7 1338 3790 3184 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3526  
1413 0 0 7 1338 3790 3184 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3526  2 sy 1 3526  2 sz 1 3526  
1414 0 0 7 1339 3790 3184 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3717  2 cs 1 3545  
1415 0 0 7 1339 3790 3184 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3526  4 shxz 1 3526  4 shyz 1 3526  2 cs 1 3545  
1416 0 0 7 1340 3790 3184 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3717  5 shear 1 3717  2 cs 1 3545  
1417 0 0 7 1340 3790 3184 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3526  2 sy 1 3526  2 sz 1 3526  4 shxy 1 3526  4 shxz 1 3526  4 shyz 1 3526  2 cs 1 3545  
1418 0 0 6 1341 3784 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1419 0 0 6 1342 3784 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1420 0 0 6 1343 3784 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3545  2 to 1 3545  
1421 0 0 6 1344 3681 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3784  5 other 1 3784  
1422 0 0 6 1344 3681 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3784  5 other 1 3784  9 threshold 1 3526  
1423 0 0 4 1345 3676 0 0 10 /**
 *
 */ 2 4 this 3 3784  3 out 1 3684  
1424 0 0 4 1346 3676 0 0 10 /**
 *
 */ 3 4 this 3 3784  3 out 1 3684  12 indent_level 1 3532  
1425 0 0 6 1347 3680 0 0 0 1 4 this 3 3784  
1426 0 0 4 1348 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3784  7 hashgen 1 3682  
1427 0 0 4 1348 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3784  7 hashgen 1 3682  5 scale 1 3526  
1428 0 0 4 1349 3676 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3784  11 destination 1 3686  
1429 0 0 4 1350 3676 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3790  4 scan 1 3688  
1430 0 0 4 1351 3676 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3784  11 destination 1 3686  
1431 0 0 4 1352 3676 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3790  6 source 1 3688  
1432 0 0 7 1353 3691 0 0 0 0 
1433 0 0 7 1254 3793 3091 0 0 1 6 param0 0 3795  
1434 0 0 4 1251 3676 0 0 10 /**
 *
 */ 3 4 this 3 3793  1 i 1 3532  10 assign_val 1 3526  
1435 0 0 6 1251 3526 0 0 0 2 4 this 3 3795  1 i 1 3532  
1436 0 0 6 1252 3532 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1437 0 0 6 1253 3744 0 0 0 1 4 this 3 3795  
1438 0 0 7 1260 3794 3096 0 0 1 6 param0 0 3797  
1439 0 0 6 1257 3526 0 0 0 2 4 this 3 3797  1 i 1 3532  
1440 0 0 6 1258 3532 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1441 0 0 6 1259 3744 0 0 0 1 4 this 3 3797  
1442 0 0 7 1357 3799 3194 0 10 /**
 *
 */ 0 
1443 0 0 7 1357 3799 3194 0 10 /**
 *
 */ 1 4 copy 1 3784  
1444 0 0 7 1357 3799 3194 0 10 /**
 *
 */ 1 4 copy 1 3791  
1445 0 0 7 1357 3799 3194 0 10 /**
 *
 */ 16 3 e00 1 3526  3 e01 1 3526  3 e02 1 3526  3 e03 1 3526  3 e10 1 3526  3 e11 1 3526  3 e12 1 3526  3 e13 1 3526  3 e20 1 3526  3 e21 1 3526  3 e22 1 3526  3 e23 1 3526  3 e30 1 3526  3 e31 1 3526  3 e32 1 3526  3 e33 1 3526  
1446 0 0 6 1358 3799 0 0 10 /**
 *
 */ 2 4 this 3 3799  4 copy 1 3784  
1447 0 0 6 1358 3799 0 0 10 /**
 *
 */ 2 4 this 3 3799  4 copy 1 3791  
1448 0 0 4 1359 3676 0 0 10 /**
 *
 */ 17 4 this 3 3799  3 e00 1 3526  3 e01 1 3526  3 e02 1 3526  3 e03 1 3526  3 e10 1 3526  3 e11 1 3526  3 e12 1 3526  3 e13 1 3526  3 e20 1 3526  3 e21 1 3526  3 e22 1 3526  3 e23 1 3526  3 e30 1 3526  3 e31 1 3526  3 e32 1 3526  3 e33 1 3526  
1449 0 0 4 1360 3676 0 0 10 /**
 *
 */ 3 4 this 3 3799  3 row 1 3532  3 col 1 3532  
1450 0 0 6 1360 3526 0 0 0 3 4 this 3 3791  3 row 1 3532  3 col 1 3532  
1451 0 0 4 1361 3676 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3791  
1452 0 0 6 1362 3532 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3791  
1453 0 0 6 1363 3681 0 0 0 2 4 this 3 3791  5 other 1 3791  
1454 0 0 6 1364 3681 0 0 0 2 4 this 3 3791  5 other 1 3791  
1455 0 0 7 1365 3691 0 0 0 0 
1456 0 0 7 1381 3800 3282 0 10 /**
 *
 */ 0 
1457 0 0 7 1381 3800 3282 0 10 /**
 *
 */ 1 5 other 1 3801  
1458 0 0 7 1381 3800 3282 0 60 /**
 * Constructs the matrix from three individual rows.
 */ 3 6 param0 0 3720  6 param1 0 3720  6 param2 0 3720  
1459 0 0 7 1381 3800 3282 0 10 /**
 *
 */ 9 6 param0 0 3529  6 param1 0 3529  6 param2 0 3529  6 param3 0 3529  6 param4 0 3529  6 param5 0 3529  6 param6 0 3529  6 param7 0 3529  6 param8 0 3529  
1460 0 0 6 1382 3800 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 other 1 3801  
1461 0 0 6 1382 3800 0 0 10 /**
 *
 */ 2 4 this 3 3800  10 fill_value 1 3529  
1462 0 0 4 1383 3676 0 0 0 2 4 this 3 3800  4 size 1 3674  
1463 0 0 6 1386 3677 0 0 0 1 4 this 3 3801  
1464 0 0 4 1387 3676 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3800  10 fill_value 1 3529  
1465 0 0 4 1388 3676 0 0 10 /**
 *
 */ 10 4 this 3 3800  3 e00 1 3529  3 e01 1 3529  3 e02 1 3529  3 e10 1 3529  3 e11 1 3529  3 e12 1 3529  3 e20 1 3529  3 e21 1 3529  3 e22 1 3529  
1466 0 0 7 1389 3803 3199 0 0 2 4 this 3 3800  1 i 1 3532  
1467 0 0 7 1389 3804 3204 0 0 2 4 this 3 3801  1 i 1 3532  
1468 0 0 6 1390 3532 0 0 55 /**
 * Returns 3: the number of rows of a LMatrix3.
 */ 0 
1469 0 0 4 1391 3676 0 0 109 /**
 * Replaces the indicated row of the matrix from a two-component vector,
 * ignoring the last column.
 */ 3 4 this 3 3800  3 row 1 3532  1 v 1 3693  
1470 0 0 4 1391 3676 0 0 82 /**
 * Replaces the indicated row of the matrix from a three-component vector.
 */ 3 4 this 3 3800  3 row 1 3532  1 v 1 3720  
1471 0 0 4 1392 3676 0 0 109 /**
 * Replaces the indicated column of the matrix from a two-component vector,
 * ignoring the last row.
 */ 3 4 this 3 3800  3 col 1 3532  1 v 1 3693  
1472 0 0 4 1392 3676 0 0 85 /**
 * Replaces the indicated column of the matrix from a three-component vector.
 */ 3 4 this 3 3800  3 col 1 3532  1 v 1 3720  
1473 0 0 4 1393 3676 0 0 78 /**
 * Stores the indicated row of the matrix as a three-component vector.
 */ 3 4 this 3 3801  10 result_vec 1 3719  3 row 1 3532  
1474 0 0 7 1393 3719 2396 0 79 /**
 * Returns the indicated row of the matrix as a three-component vector.
 */ 2 4 this 3 3801  3 row 1 3532  
1475 0 0 7 1394 3719 2396 0 82 /**
 * Returns the indicated column of the matrix as a three-component vector.
 */ 2 4 this 3 3801  3 col 1 3532  
1476 0 0 7 1401 3692 2095 0 106 /**
 * Returns the indicated row of the matrix as a two-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3801  3 row 1 3532  
1477 0 0 7 1402 3692 2095 0 106 /**
 * Returns the indicated column of the matrix as a two-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3801  3 col 1 3532  
1478 0 0 4 1405 3676 0 0 10 /**
 *
 */ 3 4 this 3 3800  3 row 1 3532  3 col 1 3532  
1479 0 0 6 1405 3529 0 0 0 3 4 this 3 3801  3 row 1 3532  3 col 1 3532  
1480 0 0 6 1406 3681 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3801  
1481 0 0 6 1407 3681 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3801  
1482 0 0 6 1408 3529 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3801  3 row 1 3532  3 col 1 3532  
1483 0 0 4 1409 3676 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3800  3 row 1 3532  3 col 1 3532  5 value 1 3529  
1484 0 0 4 1410 3676 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3801  
1485 0 0 6 1411 3532 0 0 62 /**
 * Returns the number of elements in the matrix, nine.
 */ 1 4 this 3 3801  
1486 0 0 6 1412 3681 0 0 0 2 4 this 3 3801  5 other 1 3801  
1487 0 0 6 1413 3681 0 0 0 2 4 this 3 3801  5 other 1 3801  
1488 0 0 6 1414 3681 0 0 0 2 4 this 3 3801  5 other 1 3801  
1489 0 0 6 1415 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3801  5 other 1 3801  
1490 0 0 6 1415 3532 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3801  5 other 1 3801  9 threshold 1 3529  
1491 0 0 6 1416 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3801  
1492 0 0 6 1416 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3801  9 threshold 1 3529  
1493 0 0 6 1417 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3801  4 hash 1 3674  
1494 0 0 6 1417 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3801  4 hash 1 3674  9 threshold 1 3529  
1495 0 0 7 1418 3719 2396 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3801  1 v 1 3720  
1496 0 0 7 1419 3692 2095 0 162 /**
 * The matrix transforms a 2-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3801  1 v 1 3693  
1497 0 0 7 1420 3692 2095 0 161 /**
 * The matrix transforms a 2-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3801  1 v 1 3693  
1498 0 0 7 1420 3719 2396 0 194 /**
 * The matrix transforms a 3-component vector and returns the result.  This
 * assumes the matrix is an orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3801  1 v 1 3720  
1499 0 0 7 1421 3719 2396 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3801  1 v 1 3720  
1500 0 0 4 1422 3676 0 0 52 /**
 * 3-component vector or point times matrix.
 */ 2 4 this 3 3801  1 v 1 3719  
1501 0 0 4 1423 3676 0 0 139 /**
 * The matrix transforms a 2-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3801  1 v 1 3692  
1502 0 0 4 1424 3676 0 0 137 /**
 * The matrix transforms a 2-component vector (without translation component).
 * This assumes the matrix is an affine transform.
 */ 2 4 this 3 3801  1 v 1 3692  
1503 0 0 4 1424 3676 0 0 171 /**
 * The matrix transforms a 3-component vector.  This assumes the matrix is an
 * orthonormal transform.
 *
 * In practice, this is the same computation as xform().
 */ 2 4 this 3 3801  1 v 1 3719  
1504 0 0 4 1425 3676 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3801  1 v 1 3719  
1505 0 0 4 1426 3676 0 0 25 // this = other1 * other2 3 4 this 3 3800  6 other1 1 3801  6 other2 1 3801  
1506 0 0 7 1427 3800 3282 0 0 2 4 this 3 3801  5 other 1 3801  
1507 0 0 7 1427 3800 3282 0 0 2 4 this 3 3801  6 scalar 1 3529  
1508 0 0 7 1428 3800 3282 0 0 2 4 this 3 3801  6 scalar 1 3529  
1509 0 0 6 1429 3800 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3800  5 other 1 3801  
1510 0 0 6 1430 3800 0 0 66 /**
 * Performs a memberwise subtraction between two matrices.
 */ 2 4 this 3 3800  5 other 1 3801  
1511 0 0 6 1431 3800 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 other 1 3801  
1512 0 0 6 1431 3800 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3800  6 scalar 1 3529  
1513 0 0 6 1432 3800 0 0 39 /**
 * Performs a memberwise scale.
 */ 2 4 this 3 3800  6 scalar 1 3529  
1514 0 0 4 1433 3676 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 other 1 3801  
1515 0 0 6 1434 3529 0 0 49 /**
 * Returns the determinant of the matrix.
 */ 1 4 this 3 3801  
1516 0 0 4 1435 3676 0 0 10 /**
 *
 */ 2 4 this 3 3800  5 other 1 3801  
1517 0 0 4 1436 3676 0 0 10 /**
 *
 */ 1 4 this 3 3800  
1518 0 0 6 1437 3681 0 0 463 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3800  5 other 1 3801  
1519 0 0 6 1438 3681 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3800  
1520 0 0 6 1439 3681 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3800  5 other 1 3801  
1521 0 0 6 1439 3681 0 0 114 /**
 * Simultaneously computes the inverse of the indicated matrix, and then the
 * transpose of that inverse.
 */ 2 4 this 3 3800  5 other 1 3805  
1522 0 0 6 1440 3801 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1523 0 0 4 1441 3676 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3800  5 trans 1 3693  
1524 0 0 4 1442 3676 0 0 98 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 2 4 this 3 3800  5 angle 1 3529  
1525 0 0 4 1442 3676 0 0 125 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3800  5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1526 0 0 4 1443 3676 0 0 95 /**
 * Fills mat with a matrix that applies the indicated scale in each of the two
 * axes.
 */ 2 4 this 3 3800  5 scale 1 3693  
1527 0 0 4 1443 3676 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3800  5 scale 1 3720  
1528 0 0 7 1444 3800 3282 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3693  
1529 0 0 7 1444 3800 3282 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 2 2 tx 1 3529  2 ty 1 3529  
1530 0 0 7 1445 3800 3282 0 91 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise.
 */ 1 5 angle 1 3529  
1531 0 0 7 1445 3800 3282 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1532 0 0 7 1446 3800 3282 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 1 5 scale 1 3693  
1533 0 0 7 1446 3800 3282 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3720  
1534 0 0 7 1446 3800 3282 0 85 /**
 * Returns a matrix that applies the indicated scale in each of the two axes.
 */ 2 2 sx 1 3529  2 sy 1 3529  
1535 0 0 7 1446 3800 3282 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3529  2 sy 1 3529  2 sz 1 3529  
1536 0 0 4 1447 3676 0 0 163 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 4 4 this 3 3800  5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1537 0 0 7 1448 3800 3282 0 156 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * normalized.
 */ 3 5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1538 0 0 4 1449 3676 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3800  5 shear 1 3720  2 cs 1 3545  
1539 0 0 7 1450 3800 3282 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3720  2 cs 1 3545  
1540 0 0 7 1450 3800 3282 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3529  4 shxz 1 3529  4 shyz 1 3529  2 cs 1 3545  
1541 0 0 4 1451 3676 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3800  5 scale 1 3720  5 shear 1 3720  2 cs 1 3545  
1542 0 0 7 1452 3800 3282 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3720  5 shear 1 3720  2 cs 1 3545  
1543 0 0 7 1452 3800 3282 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3529  2 sy 1 3529  2 sz 1 3529  4 shxy 1 3529  4 shxz 1 3529  4 shyz 1 3529  2 cs 1 3545  
1544 0 0 6 1453 3801 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3545  2 to 1 3545  
1545 0 0 6 1454 3681 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3801  5 other 1 3801  
1546 0 0 6 1454 3681 0 0 93 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3801  5 other 1 3801  9 threshold 1 3529  
1547 0 0 4 1455 3676 0 0 10 /**
 *
 */ 2 4 this 3 3801  3 out 1 3684  
1548 0 0 4 1456 3676 0 0 10 /**
 *
 */ 3 4 this 3 3801  3 out 1 3684  12 indent_level 1 3532  
1549 0 0 6 1457 3680 0 0 0 1 4 this 3 3801  
1550 0 0 4 1458 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3801  7 hashgen 1 3682  
1551 0 0 4 1458 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3801  7 hashgen 1 3682  9 threshold 1 3529  
1552 0 0 4 1459 3676 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3801  11 destination 1 3686  
1553 0 0 4 1460 3676 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3800  4 scan 1 3688  
1554 0 0 4 1461 3676 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3801  11 destination 1 3686  
1555 0 0 4 1462 3676 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3800  6 source 1 3688  
1556 0 0 7 1463 3691 0 0 0 0 
1557 0 0 7 1373 3803 3199 0 0 1 6 param0 0 3807  
1558 0 0 4 1370 3676 0 0 10 /**
 *
 */ 3 4 this 3 3803  1 i 1 3532  10 assign_val 1 3529  
1559 0 0 6 1370 3529 0 0 0 2 4 this 3 3807  1 i 1 3532  
1560 0 0 6 1371 3532 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1561 0 0 6 1372 3720 0 0 0 1 4 this 3 3807  
1562 0 0 7 1379 3804 3204 0 0 1 6 param0 0 3809  
1563 0 0 6 1376 3529 0 0 0 2 4 this 3 3809  1 i 1 3532  
1564 0 0 6 1377 3532 0 0 58 /**
 * Returns 3: the number of columns of a LMatrix3.
 */ 0 
1565 0 0 6 1378 3720 0 0 0 1 4 this 3 3809  
1566 0 0 7 1479 3811 3380 0 10 /**
 *
 */ 0 
1567 0 0 7 1479 3811 3380 0 95 // Construct a 4x4 matrix given a 3x3 rotation matrix and an optional
// translation component. 1 6 upper3 1 3801  
1568 0 0 7 1479 3811 3380 0 10 /**
 *
 */ 2 6 upper3 1 3801  5 trans 1 3720  
1569 0 0 7 1479 3811 3380 0 10 /**
 *
 */ 1 5 other 1 3805  
1570 0 0 7 1479 3811 3380 0 59 /**
 * Constructs the matrix from four individual rows.
 */ 4 6 param0 0 3750  6 param1 0 3750  6 param2 0 3750  6 param3 0 3750  
1571 0 0 7 1479 3811 3380 0 10 /**
 *
 */ 1 5 other 1 3812  
1572 0 0 7 1479 3811 3380 0 10 /**
 *
 */ 16 6 param0 0 3529  6 param1 0 3529  6 param2 0 3529  6 param3 0 3529  6 param4 0 3529  6 param5 0 3529  6 param6 0 3529  6 param7 0 3529  6 param8 0 3529  6 param9 0 3529  7 param10 0 3529  7 param11 0 3529  7 param12 0 3529  7 param13 0 3529  7 param14 0 3529  7 param15 0 3529  
1573 0 0 6 1480 3811 0 0 10 /**
 *
 */ 2 4 this 3 3811  5 other 1 3805  
1574 0 0 6 1480 3811 0 0 10 /**
 *
 */ 2 4 this 3 3811  5 other 1 3812  
1575 0 0 6 1480 3811 0 0 10 /**
 *
 */ 2 4 this 3 3811  10 fill_value 1 3529  
1576 0 0 4 1481 3676 0 0 0 2 4 this 3 3811  4 size 1 3674  
1577 0 0 6 1484 3677 0 0 0 1 4 this 3 3805  
1578 0 0 4 1485 3676 0 0 157 /**
 * Sets each element of the matrix to the indicated fill_value.  This is of
 * questionable value, but is sometimes useful when initializing to zero.
 */ 2 4 this 3 3811  10 fill_value 1 3529  
1579 0 0 4 1486 3676 0 0 10 /**
 *
 */ 17 4 this 3 3811  3 e00 1 3529  3 e01 1 3529  3 e02 1 3529  3 e03 1 3529  3 e10 1 3529  3 e11 1 3529  3 e12 1 3529  3 e13 1 3529  3 e20 1 3529  3 e21 1 3529  3 e22 1 3529  3 e23 1 3529  3 e30 1 3529  3 e31 1 3529  3 e32 1 3529  3 e33 1 3529  
1580 0 0 4 1487 3676 0 0 45 // Get and set the upper 3x3 rotation matrix. 2 4 this 3 3811  6 upper3 1 3801  
1581 0 0 7 1488 3800 3282 0 45 /**
 * Retrieves the upper 3x3 submatrix.
 */ 1 4 this 3 3805  
1582 0 0 7 1489 3814 3287 0 0 2 4 this 3 3811  1 i 1 3532  
1583 0 0 7 1489 3815 3292 0 0 2 4 this 3 3805  1 i 1 3532  
1584 0 0 6 1490 3532 0 0 55 /**
 * Returns 4: the number of rows of a LMatrix4.
 */ 0 
1585 0 0 4 1491 3676 0 0 119 /**
 * Replaces the indicated row of the matrix with the indicated 3-component
 * vector, ignoring the last column.
 */ 3 4 this 3 3811  3 row 1 3532  1 v 1 3720  
1586 0 0 4 1491 3676 0 0 52 /**
 * Replaces the indicated row of the matrix.
 */ 3 4 this 3 3811  3 row 1 3532  1 v 1 3750  
1587 0 0 4 1492 3676 0 0 119 /**
 * Replaces the indicated column of the matrix with the indicated 3-component
 * vector, ignoring the last row.
 */ 3 4 this 3 3811  3 col 1 3532  1 v 1 3720  
1588 0 0 4 1492 3676 0 0 55 /**
 * Replaces the indicated column of the matrix.
 */ 3 4 this 3 3811  3 col 1 3532  1 v 1 3750  
1589 0 0 4 1493 3676 0 0 74 /**
 * Stores the indicated row of the matrix as a 4-component vector.
 */ 3 4 this 3 3805  10 result_vec 1 3749  3 row 1 3532  
1590 0 0 7 1493 3749 2788 0 77 /**
 * Retrieves the indicated row of the matrix as a 4-component vector.
 */ 2 4 this 3 3805  3 row 1 3532  
1591 0 0 7 1494 3749 2788 0 80 /**
 * Retrieves the indicated column of the matrix as a 4-component vector.
 */ 2 4 this 3 3805  3 col 1 3532  
1592 0 0 4 1495 3676 0 0 100 /**
 * Stores the row column of the matrix as a 3-component vector, ignoring the
 * last column.
 */ 3 4 this 3 3805  10 result_vec 1 3719  3 row 1 3532  
1593 0 0 7 1495 3719 2396 0 103 /**
 * Retrieves the row column of the matrix as a 3-component vector, ignoring
 * the last column.
 */ 2 4 this 3 3805  3 row 1 3532  
1594 0 0 7 1503 3719 2396 0 106 /**
 * Retrieves the indicated column of the matrix as a 3-component vector,
 * ignoring the last row.
 */ 2 4 this 3 3805  3 col 1 3532  
1595 0 0 4 1504 3676 0 0 10 /**
 *
 */ 3 4 this 3 3811  3 row 1 3532  3 col 1 3532  
1596 0 0 6 1504 3529 0 0 0 3 4 this 3 3805  3 row 1 3532  3 col 1 3532  
1597 0 0 6 1505 3681 0 0 91 /**
 * Returns true if any component of the matrix is not-a-number, false
 * otherwise.
 */ 1 4 this 3 3805  
1598 0 0 6 1506 3681 0 0 93 /**
 * Returns true if this is (close enough to) the identity matrix, false
 * otherwise.
 */ 1 4 this 3 3805  
1599 0 0 6 1507 3529 0 0 54 /**
 * Returns a particular element of the matrix.
 */ 3 4 this 3 3805  3 row 1 3532  3 col 1 3532  
1600 0 0 4 1508 3676 0 0 54 /**
 * Changes a particular element of the matrix.
 */ 4 4 this 3 3811  3 row 1 3532  3 col 1 3532  5 value 1 3529  
1601 0 0 4 1509 3676 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3805  
1602 0 0 6 1510 3532 0 0 60 /**
 * Returns the number of elements in the matrix, 16.
 */ 1 4 this 3 3805  
1603 0 0 4 1511 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3811  
1604 0 0 4 1511 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3805  
1605 0 0 4 1512 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3811  
1606 0 0 4 1512 3676 0 0 101 /**
 * Returns an iterator that may be used to traverse the elements of the
 * matrix, STL-style.
 */ 1 4 this 3 3805  
1607 0 0 6 1513 3681 0 0 0 2 4 this 3 3805  5 other 1 3805  
1608 0 0 6 1514 3681 0 0 0 2 4 this 3 3805  5 other 1 3805  
1609 0 0 6 1515 3681 0 0 0 2 4 this 3 3805  5 other 1 3805  
1610 0 0 6 1516 3532 0 0 97 /**
 * This flavor of compare_to uses a default threshold value based on the
 * numeric type.
 */ 2 4 this 3 3805  5 other 1 3805  
1611 0 0 6 1516 3532 0 0 234 /**
 * Sorts matrices lexicographically, componentwise.  Returns a number less
 * than 0 if this matrix sorts before the other one, greater than zero if it
 * sorts after, 0 if they are equivalent (within the indicated tolerance).
 */ 3 4 this 3 3805  5 other 1 3805  9 threshold 1 3529  
1612 0 0 6 1517 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 1 4 this 3 3805  
1613 0 0 6 1517 3674 0 0 49 /**
 * Returns a suitable hash for phash_map.
 */ 2 4 this 3 3805  9 threshold 1 3529  
1614 0 0 6 1518 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 2 4 this 3 3805  4 hash 1 3674  
1615 0 0 6 1518 3674 0 0 49 /**
 * Adds the vector into the running hash.
 */ 3 4 this 3 3805  4 hash 1 3674  9 threshold 1 3529  
1616 0 0 7 1519 3749 2788 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3805  1 v 1 3750  
1617 0 0 7 1520 3719 2396 0 162 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result.  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3805  1 v 1 3720  
1618 0 0 7 1521 3719 2396 0 143 /**
 * The matrix transforms a 3-component point (including translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3805  1 v 1 3720  
1619 0 0 7 1522 3719 2396 0 169 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result.  This assumes the matrix is an orthonormal
 * transform.
 */ 2 4 this 3 3805  1 v 1 3720  
1620 0 0 7 1523 3719 2396 0 142 /**
 * The matrix transforms a 3-component vector (without translation component)
 * and returns the result, as a fully general operation.
 */ 2 4 this 3 3805  1 v 1 3720  
1621 0 0 4 1524 3676 0 0 91 /**
 * 4-component vector or point times matrix.  This is a fully general
 * operation.
 */ 2 4 this 3 3805  1 v 1 3749  
1622 0 0 4 1525 3676 0 0 139 /**
 * The matrix transforms a 3-component point (including translation
 * component).  This assumes the matrix is an affine transform.
 */ 2 4 this 3 3805  1 v 1 3719  
1623 0 0 4 1526 3676 0 0 120 /**
 * The matrix transforms a 3-component point (including translation
 * component), as a fully general operation.
 */ 2 4 this 3 3805  1 v 1 3719  
1624 0 0 4 1527 3676 0 0 142 /**
 * The matrix transforms a 3-component vector (without translation component).
 * This assumes the matrix is an orthonormal transform.
 */ 2 4 this 3 3805  1 v 1 3719  
1625 0 0 4 1528 3676 0 0 119 /**
 * The matrix transforms a 3-component vector (without translation component),
 * as a fully general operation.
 */ 2 4 this 3 3805  1 v 1 3719  
1626 0 0 4 1529 3676 0 0 25 // this = other1 * other2 3 4 this 3 3811  6 other1 1 3805  6 other2 1 3805  
1627 0 0 7 1530 3811 3380 0 0 2 4 this 3 3805  5 other 1 3805  
1628 0 0 7 1530 3811 3380 0 0 2 4 this 3 3805  6 scalar 1 3529  
1629 0 0 7 1531 3811 3380 0 0 2 4 this 3 3805  6 scalar 1 3529  
1630 0 0 6 1532 3811 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3811  5 other 1 3805  
1631 0 0 6 1533 3811 0 0 63 /**
 * Performs a memberwise addition between two matrices.
 */ 2 4 this 3 3811  5 other 1 3805  
1632 0 0 6 1534 3811 0 0 10 /**
 *
 */ 2 4 this 3 3811  5 other 1 3805  
1633 0 0 6 1534 3811 0 0 10 /**
 *
 */ 2 4 this 3 3811  6 scalar 1 3529  
1634 0 0 6 1535 3811 0 0 10 /**
 *
 */ 2 4 this 3 3811  6 scalar 1 3529  
1635 0 0 4 1536 3676 0 0 10 /**
 *
 */ 2 4 this 3 3811  5 other 1 3805  
1636 0 0 4 1537 3676 0 0 10 /**
 *
 */ 2 4 this 3 3811  5 other 1 3805  
1637 0 0 4 1538 3676 0 0 10 /**
 *
 */ 1 4 this 3 3811  
1638 0 0 6 1539 3681 0 0 461 /**
 * Computes the inverse of the other matrix, and stores the result in this
 * matrix.  This is a fully general operation and makes no assumptions about
 * the type of transform represented by the matrix.
 *
 * The other matrix must be a different object than this matrix.  However, if
 * you need to invert a matrix in place, see invert_in_place.
 *
 * The return value is true if the matrix was successfully inverted, false if
 * the was a singularity.
 */ 2 4 this 3 3811  5 other 1 3805  
1639 0 0 6 1540 3681 0 0 139 // bugbug: we could optimize this for rotationscaletranslation matrices
// (transpose upper 3x3 and take negative of translation component) 2 4 this 3 3811  5 other 1 3805  
1640 0 0 6 1541 3681 0 0 119 /**
 * Inverts the current matrix.  Returns true if the inverse is successful,
 * false if the matrix was singular.
 */ 1 4 this 3 3811  
1641 0 0 4 1542 3676 0 0 46 /**
 * Computes (*this) += other * weight.
 */ 3 4 this 3 3811  5 other 1 3805  6 weight 1 3529  
1642 0 0 6 1543 3805 0 0 147 /**
 * Returns an identity matrix.
 *
 * This function definition must appear first, since some inline functions
 * below take advantage of it.
 */ 0 
1643 0 0 6 1544 3805 0 0 46 /**
 * Returns an matrix filled with ones.
 */ 0 
1644 0 0 6 1545 3805 0 0 47 /**
 * Returns an matrix filled with zeros.
 */ 0 
1645 0 0 4 1546 3676 0 0 74 /**
 * Fills mat with a matrix that applies the indicated translation.
 */ 2 4 this 3 3811  5 trans 1 3720  
1646 0 0 4 1547 3676 0 0 122 /**
 * Sets mat to a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 4 4 this 3 3811  5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1647 0 0 4 1548 3676 0 0 166 /**
 * Fills mat with a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 4 4 this 3 3811  5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1648 0 0 4 1549 3676 0 0 97 /**
 * Fills mat with a matrix that applies the indicated scale in each of the
 * three axes.
 */ 2 4 this 3 3811  5 scale 1 3720  
1649 0 0 4 1550 3676 0 0 99 /**
 * Fills mat with a matrix that applies the indicated shear in each of the
 * three planes.
 */ 3 4 this 3 3811  5 shear 1 3720  2 cs 1 3545  
1650 0 0 4 1551 3676 0 0 78 /**
 * Fills mat with a matrix that applies the indicated scale and shear.
 */ 4 4 this 3 3811  5 scale 1 3720  5 shear 1 3720  2 cs 1 3545  
1651 0 0 7 1552 3811 3380 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 1 5 trans 1 3720  
1652 0 0 7 1552 3811 3380 0 67 /**
 * Returns a matrix that applies the indicated translation.
 */ 3 2 tx 1 3529  2 ty 1 3529  2 tz 1 3529  
1653 0 0 7 1553 3811 3380 0 118 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.
 */ 3 5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1654 0 0 7 1554 3811 3380 0 159 /**
 * Returns a matrix that rotates by the given angle in degrees
 * counterclockwise about the indicated vector.  Assumes axis has been
 * prenormalized.
 */ 3 5 angle 1 3529  4 axis 1 3720  2 cs 1 3545  
1655 0 0 7 1555 3811 3380 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 1 5 scale 1 3720  
1656 0 0 7 1555 3811 3380 0 69 /**
 * Returns a matrix that applies the indicated uniform scale.
 */ 1 5 scale 1 3529  
1657 0 0 7 1555 3811 3380 0 90 /**
 * Returns a matrix that applies the indicated scale in each of the three
 * axes.
 */ 3 2 sx 1 3529  2 sy 1 3529  2 sz 1 3529  
1658 0 0 7 1556 3811 3380 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 2 5 shear 1 3720  2 cs 1 3545  
1659 0 0 7 1556 3811 3380 0 92 /**
 * Returns a matrix that applies the indicated shear in each of the three
 * planes.
 */ 4 4 shxy 1 3529  4 shxz 1 3529  4 shyz 1 3529  2 cs 1 3545  
1660 0 0 7 1557 3811 3380 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 3 5 scale 1 3720  5 shear 1 3720  2 cs 1 3545  
1661 0 0 7 1557 3811 3380 0 71 /**
 * Returns a matrix that applies the indicated scale and shear.
 */ 7 2 sx 1 3529  2 sy 1 3529  2 sz 1 3529  4 shxy 1 3529  4 shxz 1 3529  4 shyz 1 3529  2 cs 1 3545  
1662 0 0 6 1558 3805 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1663 0 0 6 1559 3805 0 0 109 /**
 * Returns a matrix that transforms from the Y-up coordinate system to the
 * Z-up coordinate system.
 */ 0 
1664 0 0 6 1560 3805 0 0 119 /**
 * Returns a matrix that transforms from the indicated coordinate system to
 * the indicated coordinate system.
 */ 2 4 from 1 3545  2 to 1 3545  
1665 0 0 6 1561 3681 0 0 117 /**
 * Returns true if two matrices are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3805  5 other 1 3805  
1666 0 0 6 1561 3681 0 0 199 /**
 * Returns true if two matrices are memberwise equal within a specified
 * tolerance.  This is faster than the equivalence operator as this doesn't
 * have to guarantee that it is transitive.
 */ 3 4 this 3 3805  5 other 1 3805  9 threshold 1 3529  
1667 0 0 4 1562 3676 0 0 10 /**
 *
 */ 2 4 this 3 3805  3 out 1 3684  
1668 0 0 4 1563 3676 0 0 10 /**
 *
 */ 3 4 this 3 3805  3 out 1 3684  12 indent_level 1 3532  
1669 0 0 6 1564 3680 0 0 0 1 4 this 3 3805  
1670 0 0 4 1565 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 2 4 this 3 3805  7 hashgen 1 3682  
1671 0 0 4 1565 3676 0 0 59 /**
 * Adds the vector to the indicated hash generator.
 */ 3 4 this 3 3805  7 hashgen 1 3682  5 scale 1 3529  
1672 0 0 4 1566 3676 0 0 332 /**
 * Writes the matrix to the Datagram using add_float32() or add_float64(),
 * depending on the type of floats in the matrix, regardless of the setting of
 * Datagram::set_stdfloat_double().  This is appropriate when you want to
 * write a fixed-width value to the datagram, especially when you are not
 * writing a bam file.
 */ 2 4 this 3 3805  11 destination 1 3686  
1673 0 0 4 1567 3676 0 0 114 /**
 * Reads the matrix from the Datagram using get_float32() or get_float64().
 * See write_datagram_fixed().
 */ 2 4 this 3 3811  4 scan 1 3688  
1674 0 0 4 1568 3676 0 0 205 /**
 * Writes the matrix to the Datagram using add_stdfloat().  This is
 * appropriate when you want to write the matrix using the standard width
 * setting, especially when you are writing a bam file.
 */ 2 4 this 3 3805  11 destination 1 3686  
1675 0 0 4 1569 3676 0 0 67 /**
 * Reads the matrix from the Datagram using get_stdfloat().
 */ 2 4 this 3 3811  6 source 1 3688  
1676 0 0 7 1570 3691 0 0 0 0 
1677 0 0 7 1471 3814 3287 0 0 1 6 param0 0 3816  
1678 0 0 4 1468 3676 0 0 10 /**
 *
 */ 3 4 this 3 3814  1 i 1 3532  10 assign_val 1 3529  
1679 0 0 6 1468 3529 0 0 0 2 4 this 3 3816  1 i 1 3532  
1680 0 0 6 1469 3532 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1681 0 0 6 1470 3750 0 0 0 1 4 this 3 3816  
1682 0 0 7 1477 3815 3292 0 0 1 6 param0 0 3818  
1683 0 0 6 1474 3529 0 0 0 2 4 this 3 3818  1 i 1 3532  
1684 0 0 6 1475 3532 0 0 58 /**
 * Returns 4: the number of columns of a LMatrix4.
 */ 0 
1685 0 0 6 1476 3750 0 0 0 1 4 this 3 3818  
1686 0 0 7 1574 3820 3390 0 10 /**
 *
 */ 0 
1687 0 0 7 1574 3820 3390 0 10 /**
 *
 */ 1 4 copy 1 3805  
1688 0 0 7 1574 3820 3390 0 10 /**
 *
 */ 1 4 copy 1 3812  
1689 0 0 7 1574 3820 3390 0 10 /**
 *
 */ 16 3 e00 1 3529  3 e01 1 3529  3 e02 1 3529  3 e03 1 3529  3 e10 1 3529  3 e11 1 3529  3 e12 1 3529  3 e13 1 3529  3 e20 1 3529  3 e21 1 3529  3 e22 1 3529  3 e23 1 3529  3 e30 1 3529  3 e31 1 3529  3 e32 1 3529  3 e33 1 3529  
1690 0 0 6 1575 3820 0 0 10 /**
 *
 */ 2 4 this 3 3820  4 copy 1 3805  
1691 0 0 6 1575 3820 0 0 10 /**
 *
 */ 2 4 this 3 3820  4 copy 1 3812  
1692 0 0 4 1576 3676 0 0 10 /**
 *
 */ 17 4 this 3 3820  3 e00 1 3529  3 e01 1 3529  3 e02 1 3529  3 e03 1 3529  3 e10 1 3529  3 e11 1 3529  3 e12 1 3529  3 e13 1 3529  3 e20 1 3529  3 e21 1 3529  3 e22 1 3529  3 e23 1 3529  3 e30 1 3529  3 e31 1 3529  3 e32 1 3529  3 e33 1 3529  
1693 0 0 4 1577 3676 0 0 10 /**
 *
 */ 3 4 this 3 3820  3 row 1 3532  3 col 1 3532  
1694 0 0 6 1577 3529 0 0 0 3 4 this 3 3812  3 row 1 3532  3 col 1 3532  
1695 0 0 4 1578 3676 0 0 162 /**
 * Returns the address of the first of the nine data elements in the matrix.
 * The remaining elements occupy the next eight positions in row-major order.
 */ 1 4 this 3 3812  
1696 0 0 6 1579 3532 0 0 65 /**
 * Returns the number of elements in the matrix, sixteen.
 */ 1 4 this 3 3812  
1697 0 0 6 1580 3681 0 0 0 2 4 this 3 3812  5 other 1 3812  
1698 0 0 6 1581 3681 0 0 0 2 4 this 3 3812  5 other 1 3812  
1699 0 0 7 1582 3691 0 0 0 0 
1700 0 0 7 1593 3821 3447 0 10 /**
 *
 */ 0 
1701 0 0 7 1593 3821 3447 0 0 1 6 param0 0 3822  
1702 0 0 7 1593 3821 3447 0 10 /**
 *
 */ 1 4 copy 1 3744  
1703 0 0 7 1593 3821 3447 0 10 /**
 *
 */ 2 1 r 1 3526  4 copy 1 3717  
1704 0 0 7 1593 3821 3447 0 10 /**
 *
 */ 4 1 r 1 3526  1 i 1 3526  1 j 1 3526  1 k 1 3526  
1705 0 0 7 1594 3821 3447 0 10 /**
 *
 */ 1 1 v 1 3726  
1706 0 0 7 1595 3821 3447 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3822  
1707 0 0 7 1596 3716 2323 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3822  1 v 1 3717  
1708 0 0 7 1596 3743 2703 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3822  1 v 1 3744  
1709 0 0 7 1597 3821 3447 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3822  3 rhs 1 3822  
1710 0 0 7 1598 3821 3447 0 0 1 4 this 3 3822  
1711 0 0 7 1599 3821 3447 0 0 2 4 this 3 3822  5 other 1 3822  
1712 0 0 7 1600 3821 3447 0 0 2 4 this 3 3822  5 other 1 3822  
1713 0 0 6 1601 3526 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3822  5 other 1 3822  
1714 0 0 6 1602 3526 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3822  5 other 1 3822  
1715 0 0 7 1603 3779 3084 0 0 2 4 this 3 3821  6 param0 0 3780  
1716 0 0 7 1603 3790 3184 0 0 2 4 this 3 3821  6 param0 0 3784  
1717 0 0 7 1603 3821 3447 0 0 2 4 this 3 3822  6 param0 0 3822  
1718 0 0 7 1603 3821 3447 0 0 2 4 this 3 3822  6 scalar 1 3526  
1719 0 0 7 1604 3821 3447 0 0 2 4 this 3 3822  6 scalar 1 3526  
1720 0 0 6 1605 3821 0 0 10 /**
 *
 */ 2 4 this 3 3821  6 param0 0 3822  
1721 0 0 7 1606 3821 3447 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3822  6 param0 0 3526  
1722 0 0 6 1607 3681 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3822  5 other 1 3822  
1723 0 0 6 1607 3681 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3822  5 other 1 3822  9 threshold 1 3526  
1724 0 0 6 1608 3681 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3822  5 other 1 3822  
1725 0 0 6 1609 3681 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3822  5 other 1 3822  9 threshold 1 3526  
1726 0 0 4 1610 3676 0 0 10 /**
 *
 */ 2 4 this 3 3822  6 param0 0 3684  
1727 0 0 4 1611 3676 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3822  1 m 1 3779  
1728 0 0 4 1611 3676 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3822  1 m 1 3790  
1729 0 0 4 1612 3676 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3821  1 m 1 3780  
1730 0 0 4 1612 3676 0 0 10 /**
 *
 */ 2 4 this 3 3821  1 m 1 3784  
1731 0 0 4 1613 3676 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3821  3 hpr 1 3717  2 cs 1 3545  
1732 0 0 7 1614 3716 2323 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3822  2 cs 1 3545  
1733 0 0 7 1615 3725 2502 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3822  
1734 0 0 7 1616 3725 2502 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3822  
1735 0 0 6 1617 3526 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3822  
1736 0 0 6 1618 3526 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3822  
1737 0 0 4 1619 3676 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3821  9 angle_rad 1 3526  4 axis 1 3726  
1738 0 0 4 1620 3676 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3821  9 angle_deg 1 3526  4 axis 1 3726  
1739 0 0 7 1621 3725 2502 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3822  2 cs 1 3545  
1740 0 0 7 1622 3725 2502 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3822  2 cs 1 3545  
1741 0 0 7 1623 3725 2502 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3822  2 cs 1 3545  
1742 0 0 6 1624 3526 0 0 10 /**
 *
 */ 1 4 this 3 3822  
1743 0 0 6 1625 3526 0 0 10 /**
 *
 */ 1 4 this 3 3822  
1744 0 0 6 1626 3526 0 0 10 /**
 *
 */ 1 4 this 3 3822  
1745 0 0 6 1627 3526 0 0 10 /**
 *
 */ 1 4 this 3 3822  
1746 0 0 4 1628 3676 0 0 10 /**
 *
 */ 2 4 this 3 3821  1 r 1 3526  
1747 0 0 4 1629 3676 0 0 10 /**
 *
 */ 2 4 this 3 3821  1 i 1 3526  
1748 0 0 4 1630 3676 0 0 10 /**
 *
 */ 2 4 this 3 3821  1 j 1 3526  
1749 0 0 4 1631 3676 0 0 10 /**
 *
 */ 2 4 this 3 3821  1 k 1 3526  
1750 0 0 6 1632 3681 0 0 10 /**
 *
 */ 1 4 this 3 3821  
1751 0 0 6 1633 3681 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3821  5 other 1 3822  
1752 0 0 6 1634 3681 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3821  
1753 0 0 6 1635 3681 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3821  5 other 1 3822  
1754 0 0 6 1636 3681 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3821  
1755 0 0 6 1637 3681 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3822  
1756 0 0 6 1638 3681 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3822  9 tolerance 1 3526  
1757 0 0 6 1639 3822 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1758 0 0 7 1640 3691 0 0 0 0 
1759 0 0 7 1643 3824 3496 0 10 /**
 *
 */ 0 
1760 0 0 7 1643 3824 3496 0 0 1 6 param0 0 3825  
1761 0 0 7 1643 3824 3496 0 10 /**
 *
 */ 1 4 copy 1 3750  
1762 0 0 7 1643 3824 3496 0 10 /**
 *
 */ 2 1 r 1 3529  4 copy 1 3720  
1763 0 0 7 1643 3824 3496 0 10 /**
 *
 */ 4 1 r 1 3529  1 i 1 3529  1 j 1 3529  1 k 1 3529  
1764 0 0 7 1644 3824 3496 0 10 /**
 *
 */ 1 1 v 1 3729  
1765 0 0 7 1645 3824 3496 0 54 /**
 * Returns the complex conjugate of this quat.
 */ 1 4 this 3 3825  
1766 0 0 7 1646 3719 2396 0 60 /**
 * Transforms a 3-d vector by the indicated rotation
 */ 2 4 this 3 3825  1 v 1 3720  
1767 0 0 7 1646 3749 2788 0 60 /**
 * Transforms a 4-d vector by the indicated rotation
 */ 2 4 this 3 3825  1 v 1 3750  
1768 0 0 7 1647 3824 3496 0 45 /**
 * actual multiply call (non virtual)
 */ 2 4 this 3 3825  3 rhs 1 3825  
1769 0 0 7 1648 3824 3496 0 0 1 4 this 3 3825  
1770 0 0 7 1649 3824 3496 0 0 2 4 this 3 3825  5 other 1 3825  
1771 0 0 7 1650 3824 3496 0 0 2 4 this 3 3825  5 other 1 3825  
1772 0 0 6 1651 3529 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in radians.
 */ 2 4 this 3 3825  5 other 1 3825  
1773 0 0 6 1652 3529 0 0 127 /**
 * Returns the angle between the orientation represented by this quaternion
 * and the other one, expressed in degrees.
 */ 2 4 this 3 3825  5 other 1 3825  
1774 0 0 7 1653 3800 3282 0 0 2 4 this 3 3824  6 param0 0 3801  
1775 0 0 7 1653 3811 3380 0 0 2 4 this 3 3824  6 param0 0 3805  
1776 0 0 7 1653 3824 3496 0 0 2 4 this 3 3825  6 param0 0 3825  
1777 0 0 7 1653 3824 3496 0 0 2 4 this 3 3825  6 scalar 1 3529  
1778 0 0 7 1654 3824 3496 0 0 2 4 this 3 3825  6 scalar 1 3529  
1779 0 0 6 1655 3824 0 0 10 /**
 *
 */ 2 4 this 3 3824  6 param0 0 3825  
1780 0 0 7 1656 3824 3496 0 97 /**
 * Returns a new quaternion that represents this quaternion raised to the
 * given power.
 */ 2 4 this 3 3825  6 param0 0 3529  
1781 0 0 6 1657 3681 0 0 120 /**
 * Returns true if two quaternions are memberwise equal within a default
 * tolerance based on the numeric type.
 */ 2 4 this 3 3825  5 other 1 3825  
1782 0 0 6 1657 3681 0 0 96 /**
 * Returns true if two quaternions are memberwise equal within a specified
 * tolerance.
 */ 3 4 this 3 3825  5 other 1 3825  9 threshold 1 3529  
1783 0 0 6 1658 3681 0 0 127 /**
 * Returns true if two quaternions represent the same rotation within a
 * default tolerance based on the numeric type.
 */ 2 4 this 3 3825  5 other 1 3825  
1784 0 0 6 1659 3681 0 0 103 /**
 * Returns true if two quaternions represent the same rotation within a
 * specified tolerance.
 */ 3 4 this 3 3825  5 other 1 3825  9 threshold 1 3529  
1785 0 0 4 1660 3676 0 0 10 /**
 *
 */ 2 4 this 3 3825  6 param0 0 3684  
1786 0 0 4 1661 3676 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3825  1 m 1 3800  
1787 0 0 4 1661 3676 0 0 43 /**
 * Based on the quat lib from VRPN.
 */ 2 4 this 3 3825  1 m 1 3811  
1788 0 0 4 1662 3676 0 0 226 /**
 * Sets the quaternion according to the rotation represented by the matrix.
 * Originally we tried an algorithm presented by Do-While Jones, but that
 * turned out to be broken.  This is based on the quat lib from UNC.
 */ 2 4 this 3 3824  1 m 1 3801  
1789 0 0 4 1662 3676 0 0 10 /**
 *
 */ 2 4 this 3 3824  1 m 1 3805  
1790 0 0 4 1663 3676 0 0 132 /**
 * Sets the quaternion as the unit quaternion that is equivalent to these
 * Euler angles.  (from Real-time Rendering, p.49)
 */ 3 4 this 3 3824  3 hpr 1 3720  2 cs 1 3545  
1791 0 0 7 1664 3719 2396 0 73 /**
 * Extracts the equivalent Euler angles from the unit quaternion.
 */ 2 4 this 3 3825  2 cs 1 3545  
1792 0 0 7 1665 3728 2536 0 180 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the axis; it
 * is not normalized.
 */ 1 4 this 3 3825  
1793 0 0 7 1666 3728 2536 0 169 /**
 * This, along with get_angle(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the
 * normalized axis.
 */ 1 4 this 3 3825  
1794 0 0 6 1667 3529 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * radians counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3825  
1795 0 0 6 1668 3529 0 0 343 /**
 * This, along with get_axis(), returns the rotation represented by the
 * quaternion as an angle about an arbitrary axis.  This returns the angle, in
 * degrees counterclockwise about the axis.
 *
 * It is necessary to ensure the quaternion has been normalized (for instance,
 * with a call to normalize()) before calling this method.
 */ 1 4 this 3 3825  
1796 0 0 4 1669 3676 0 0 86 /**
 * angle_rad is the angle about the axis in radians.  axis must be normalized.
 */ 3 4 this 3 3824  9 angle_rad 1 3529  4 axis 1 3729  
1797 0 0 4 1670 3676 0 0 86 /**
 * angle_deg is the angle about the axis in degrees.  axis must be normalized.
 */ 3 4 this 3 3824  9 angle_deg 1 3529  4 axis 1 3729  
1798 0 0 7 1671 3728 2536 0 96 /**
 * Returns the orientation represented by this quaternion, expressed as an up
 * vector.
 */ 2 4 this 3 3825  2 cs 1 3545  
1799 0 0 7 1672 3728 2536 0 98 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * right vector.
 */ 2 4 this 3 3825  2 cs 1 3545  
1800 0 0 7 1673 3728 2536 0 100 /**
 * Returns the orientation represented by this quaternion, expressed as a
 * forward vector.
 */ 2 4 this 3 3825  2 cs 1 3545  
1801 0 0 6 1674 3529 0 0 10 /**
 *
 */ 1 4 this 3 3825  
1802 0 0 6 1675 3529 0 0 10 /**
 *
 */ 1 4 this 3 3825  
1803 0 0 6 1676 3529 0 0 10 /**
 *
 */ 1 4 this 3 3825  
1804 0 0 6 1677 3529 0 0 10 /**
 *
 */ 1 4 this 3 3825  
1805 0 0 4 1678 3676 0 0 10 /**
 *
 */ 2 4 this 3 3824  1 r 1 3529  
1806 0 0 4 1679 3676 0 0 10 /**
 *
 */ 2 4 this 3 3824  1 i 1 3529  
1807 0 0 4 1680 3676 0 0 10 /**
 *
 */ 2 4 this 3 3824  1 j 1 3529  
1808 0 0 4 1681 3676 0 0 10 /**
 *
 */ 2 4 this 3 3824  1 k 1 3529  
1809 0 0 6 1682 3681 0 0 10 /**
 *
 */ 1 4 this 3 3824  
1810 0 0 6 1683 3681 0 0 466 /**
 * Computes the conjugate of the other quat, and stores the result in this
 * quat.  This is a fully general operation and makes no assumptions about the
 * type of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to get a conjugate of a quat in place, see conjugate_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3824  5 other 1 3825  
1811 0 0 6 1684 3681 0 0 129 /**
 * Sets this to be the conjugate of the current quat.  Returns true if the
 * successful, false if the quat was singular.
 */ 1 4 this 3 3824  
1812 0 0 6 1685 3681 0 0 448 /**
 * Computes the inverse of the other quat, and stores the result in this quat.
 * This is a fully general operation and makes no assumptions about the type
 * of transform represented by the quat.
 *
 * The other quat must be a different object than this quat.  However, if you
 * need to invert a quat in place, see invert_in_place.
 *
 * The return value is true if the quat was successfully inverted, false if
 * there was a singularity.
 */ 2 4 this 3 3824  5 other 1 3825  
1813 0 0 6 1686 3681 0 0 115 /**
 * Inverts the current quat.  Returns true if the inverse is successful, false
 * if the quat was singular.
 */ 1 4 this 3 3824  
1814 0 0 6 1687 3681 0 0 98 /**
 * Returns true if this quaternion represents the identity transformation: no
 * rotation.
 */ 1 4 this 3 3825  
1815 0 0 6 1688 3681 0 0 110 /**
 * Returns true if this quaternion represents the identity transformation
 * within a given tolerance.
 */ 2 4 this 3 3825  9 tolerance 1 3529  
1816 0 0 6 1689 3825 0 0 42 /**
 * Returns an identity quaternion.
 */ 0 
1817 0 0 7 1690 3691 0 0 0 0 
1818 0 0 7 1693 3827 3501 0 10 /**
 *
 */ 0 
1819 0 0 7 1693 3827 3501 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3780  
1820 0 0 7 1693 3827 3501 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3784  
1821 0 0 7 1693 3827 3501 0 10 /**
 *
 */ 1 1 c 1 3822  
1822 0 0 7 1693 3827 3501 0 0 1 6 param0 0 3828  
1823 0 0 7 1693 3827 3501 0 10 /**
 *
 */ 1 4 copy 1 3744  
1824 0 0 7 1693 3827 3501 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3726  5 angle 1 3526  
1825 0 0 7 1693 3827 3501 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3526  1 p 1 3526  1 r 1 3526  
1826 0 0 7 1693 3827 3501 0 10 /**
 *
 */ 4 1 r 1 3526  1 i 1 3526  1 j 1 3526  1 k 1 3526  
1827 0 0 7 1694 3821 3447 0 0 2 4 this 3 3828  5 other 1 3822  
1828 0 0 7 1694 3827 3501 0 0 2 4 this 3 3828  5 other 1 3828  
1829 0 0 7 1694 3827 3501 0 0 2 4 this 3 3828  6 scalar 1 3526  
1830 0 0 7 1695 3827 3501 0 0 2 4 this 3 3828  6 scalar 1 3526  
1831 0 0 7 1696 3691 0 0 0 0 
1832 0 0 7 1699 3830 3506 0 10 /**
 *
 */ 0 
1833 0 0 7 1699 3830 3506 0 19 /**
 * lmatrix3
 */ 1 1 m 1 3801  
1834 0 0 7 1699 3830 3506 0 19 /**
 * lmatrix4
 */ 1 1 m 1 3805  
1835 0 0 7 1699 3830 3506 0 10 /**
 *
 */ 1 1 c 1 3825  
1836 0 0 7 1699 3830 3506 0 0 1 6 param0 0 3831  
1837 0 0 7 1699 3830 3506 0 10 /**
 *
 */ 1 4 copy 1 3750  
1838 0 0 7 1699 3830 3506 0 36 /**
 * axis + angle (in degrees)
 */ 2 4 axis 1 3729  5 angle 1 3529  
1839 0 0 7 1699 3830 3506 0 57 /**
 * Sets the rotation from the given Euler angles.
 */ 3 1 h 1 3529  1 p 1 3529  1 r 1 3529  
1840 0 0 7 1699 3830 3506 0 10 /**
 *
 */ 4 1 r 1 3529  1 i 1 3529  1 j 1 3529  1 k 1 3529  
1841 0 0 7 1700 3824 3496 0 0 2 4 this 3 3831  5 other 1 3825  
1842 0 0 7 1700 3830 3506 0 0 2 4 this 3 3831  5 other 1 3831  
1843 0 0 7 1700 3830 3506 0 0 2 4 this 3 3831  6 scalar 1 3529  
1844 0 0 7 1701 3830 3506 0 0 2 4 this 3 3831  6 scalar 1 3529  
1845 0 0 7 1702 3691 0 0 0 0 
1846 0 0 7 1705 3833 3510 0 10 /**
 *
 */ 0 
1847 0 0 7 1705 3833 3510 0 18 /**
 * matrix3
 */ 1 1 m 1 3780  
1848 0 0 7 1705 3833 3510 0 18 /**
 * matrix4
 */ 1 1 m 1 3784  
1849 0 0 7 1705 3833 3510 0 0 1 6 param0 0 3834  
1850 0 0 7 1705 3833 3510 0 10 /**
 *
 */ 1 1 c 1 3822  
1851 0 0 7 1705 3833 3510 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3726  5 twist 1 3526  
1852 0 0 7 1705 3833 3510 0 10 /**
 *
 */ 4 1 r 1 3526  1 i 1 3526  1 j 1 3526  1 k 1 3526  
1853 0 0 7 1706 3833 3510 0 0 2 4 this 3 3834  5 other 1 3822  
1854 0 0 7 1706 3833 3510 0 0 2 4 this 3 3834  5 other 1 3828  
1855 0 0 7 1707 3691 0 0 0 0 
1856 0 0 7 1710 3836 3514 0 10 /**
 *
 */ 0 
1857 0 0 7 1710 3836 3514 0 18 /**
 * matrix3
 */ 1 1 m 1 3801  
1858 0 0 7 1710 3836 3514 0 18 /**
 * matrix4
 */ 1 1 m 1 3805  
1859 0 0 7 1710 3836 3514 0 0 1 6 param0 0 3837  
1860 0 0 7 1710 3836 3514 0 10 /**
 *
 */ 1 1 c 1 3825  
1861 0 0 7 1710 3836 3514 0 25 /**
 * vector + twist
 */ 2 8 point_at 1 3729  5 twist 1 3529  
1862 0 0 7 1710 3836 3514 0 10 /**
 *
 */ 4 1 r 1 3529  1 i 1 3529  1 j 1 3529  1 k 1 3529  
1863 0 0 7 1711 3836 3514 0 0 2 4 this 3 3837  5 other 1 3825  
1864 0 0 7 1711 3836 3514 0 0 2 4 this 3 3837  5 other 1 3831  
1865 0 0 7 1712 3691 0 0 0 0 
1866 0 0 7 1786 3841 3522 0 0 1 6 param0 0 3839  
1867 0 0 7 1786 3841 3522 0 10 /**
 *
 */ 1 4 name 1 3680  
1868 0 0 7 1786 3841 3522 0 10 /**
 *
 */ 4 4 name 1 3680  13 default_value 1 3842  11 description 1 3680  5 flags 1 3532  
1869 0 0 7 1786 3841 3522 0 10 /**
 *
 */ 4 4 name 1 3680  13 default_value 1 3680  11 description 1 3680  5 flags 1 3532  
1870 0 0 6 1787 3841 0 0 0 2 4 this 3 3841  5 value 1 3842  
1871 0 0 6 1789 3844 0 0 0 2 4 this 3 3839  1 n 1 3532  
1872 0 0 4 1790 3676 0 0 48 /**
 * Reassigns the variable's local value.
 */ 2 4 this 3 3841  5 value 1 3842  
1873 0 0 6 1791 3842 0 0 40 /**
 * Returns the variable's value.
 */ 1 4 this 3 3839  
1874 0 0 7 1792 3845 0 0 48 /**
 * Returns the variable's default value.
 */ 1 4 this 3 3839  
1875 0 0 6 1788 3842 0 0 0 1 4 this 3 3839  
1876 0 0 6 4 3529 0 0 0 1 1 f 1 3529  
1877 0 0 6 4 3526 0 0 0 1 1 f 1 3526  
1878 0 0 6 5 3529 0 0 0 1 1 f 1 3529  
1879 0 0 6 5 3526 0 0 0 1 1 f 1 3526  
1880 0 0 6 547 3545 0 0 0 0 
1881 0 0 6 548 3545 0 0 0 1 3 str 1 3680  
1882 0 0 6 549 3680 0 0 0 1 2 cs 1 3545  
1883 0 0 6 550 3681 0 0 0 1 2 cs 1 3545  
1884 0 0 7 1246 3800 3282 0 0 1 1 a 1 3801  
1885 0 0 7 1246 3779 3084 0 0 1 1 a 1 3780  
1886 0 0 7 1246 3811 3380 0 0 1 1 a 1 3805  
1887 0 0 7 1246 3790 3184 0 0 1 1 a 1 3784  
1888 0 0 7 1247 3800 3282 0 0 1 1 a 1 3801  
1889 0 0 7 1247 3779 3084 0 0 1 1 a 1 3780  
1890 0 0 7 1247 3811 3380 0 0 1 1 a 1 3805  
1891 0 0 7 1247 3790 3184 0 0 1 1 a 1 3784  
1892 0 0 7 1247 3824 3496 0 0 1 1 a 1 3825  
1893 0 0 7 1247 3821 3447 0 0 1 1 a 1 3822  
1894 0 0 7 1584 3800 3282 0 0 2 1 m 1 3801  1 q 1 3825  
1895 0 0 7 1584 3779 3084 0 0 2 1 m 1 3780  1 q 1 3822  
1896 0 0 7 1584 3811 3380 0 0 2 1 m 1 3805  1 q 1 3825  
1897 0 0 7 1584 3790 3184 0 0 2 1 m 1 3784  1 q 1 3822  
1898 0 0 7 1584 3710 2236 0 0 2 1 v 1 3711  1 m 1 3801  
1899 0 0 7 1584 3707 2220 0 0 2 1 v 1 3708  1 m 1 3780  
1900 0 0 7 1584 3737 2608 0 0 2 1 v 1 3738  1 m 1 3801  
1901 0 0 7 1584 3737 2608 0 0 2 1 v 1 3738  1 m 1 3805  
1902 0 0 7 1584 3734 2585 0 0 2 1 v 1 3735  1 m 1 3780  
1903 0 0 7 1584 3734 2585 0 0 2 1 v 1 3735  1 m 1 3784  
1904 0 0 7 1584 3773 2978 0 0 2 1 v 1 3774  1 m 1 3805  
1905 0 0 7 1584 3770 2958 0 0 2 1 v 1 3771  1 m 1 3784  
1906 0 0 7 1584 3719 2396 0 0 2 1 v 1 3720  1 m 1 3801  
1907 0 0 7 1584 3716 2323 0 0 2 1 v 1 3717  1 m 1 3780  
1908 0 0 7 1584 3749 2788 0 0 2 1 v 1 3750  1 m 1 3805  
1909 0 0 7 1584 3743 2703 0 0 2 1 v 1 3744  1 m 1 3784  
1910 0 0 7 1584 3701 2190 0 0 2 1 v 1 3702  1 m 1 3801  
1911 0 0 7 1584 3698 2172 0 0 2 1 v 1 3699  1 m 1 3780  
1912 0 0 7 1584 3728 2536 0 0 2 1 v 1 3729  1 m 1 3801  
1913 0 0 7 1584 3728 2536 0 0 2 1 v 1 3729  1 m 1 3805  
1914 0 0 7 1584 3725 2502 0 0 2 1 v 1 3726  1 m 1 3780  
1915 0 0 7 1584 3725 2502 0 0 2 1 v 1 3726  1 m 1 3784  
1916 0 0 7 1584 3764 2920 0 0 2 1 v 1 3765  1 m 1 3805  
1917 0 0 7 1584 3761 2900 0 0 2 1 v 1 3762  1 m 1 3784  
1918 0 0 4 1585 3676 0 0 0 2 1 v 1 3710  1 m 1 3801  
1919 0 0 4 1585 3676 0 0 0 2 1 v 1 3707  1 m 1 3780  
1920 0 0 4 1585 3676 0 0 0 2 1 v 1 3737  1 m 1 3801  
1921 0 0 4 1585 3676 0 0 0 2 1 v 1 3737  1 m 1 3805  
1922 0 0 4 1585 3676 0 0 0 2 1 v 1 3734  1 m 1 3780  
1923 0 0 4 1585 3676 0 0 0 2 1 v 1 3734  1 m 1 3784  
1924 0 0 4 1585 3676 0 0 0 2 1 v 1 3719  1 m 1 3801  
1925 0 0 4 1585 3676 0 0 0 2 1 v 1 3716  1 m 1 3780  
1926 0 0 4 1585 3676 0 0 0 2 1 v 1 3749  1 m 1 3805  
1927 0 0 4 1585 3676 0 0 0 2 1 v 1 3743  1 m 1 3784  
1928 0 0 4 1585 3676 0 0 0 2 1 v 1 3701  1 m 1 3801  
1929 0 0 4 1585 3676 0 0 0 2 1 v 1 3698  1 m 1 3780  
1930 0 0 4 1585 3676 0 0 0 2 1 v 1 3728  1 m 1 3801  
1931 0 0 4 1585 3676 0 0 0 2 1 v 1 3728  1 m 1 3805  
1932 0 0 4 1585 3676 0 0 0 2 1 v 1 3725  1 m 1 3780  
1933 0 0 4 1585 3676 0 0 0 2 1 v 1 3725  1 m 1 3784  
1934 0 0 4 1586 3676 0 0 0 2 4 dest 1 3686  5 value 1 3801  
1935 0 0 4 1586 3676 0 0 0 2 4 dest 1 3686  5 value 1 3780  
1936 0 0 4 1586 3676 0 0 0 2 4 dest 1 3686  5 value 1 3805  
1937 0 0 4 1586 3676 0 0 0 2 4 dest 1 3686  5 value 1 3784  
1938 0 0 4 1587 3676 0 0 0 2 6 result 1 3800  6 source 1 3688  
1939 0 0 4 1587 3676 0 0 0 2 6 result 1 3779  6 source 1 3688  
1940 0 0 4 1587 3676 0 0 0 2 6 result 1 3811  6 source 1 3688  
1941 0 0 4 1587 3676 0 0 0 2 6 result 1 3790  6 source 1 3688  
1942 0 0 4 1588 3676 0 0 0 4 3 mat 1 3800  5 scale 1 3720  3 hpr 1 3720  2 cs 1 3545  
1943 0 0 4 1588 3676 0 0 0 5 3 mat 1 3800  5 scale 1 3720  5 shear 1 3720  3 hpr 1 3720  2 cs 1 3545  
1944 0 0 4 1588 3676 0 0 0 4 3 mat 1 3779  5 scale 1 3717  3 hpr 1 3717  2 cs 1 3545  
1945 0 0 4 1588 3676 0 0 0 5 3 mat 1 3779  5 scale 1 3717  5 shear 1 3717  3 hpr 1 3717  2 cs 1 3545  
1946 0 0 4 1588 3676 0 0 0 5 3 mat 1 3811  5 scale 1 3720  3 hpr 1 3720  9 translate 1 3720  2 cs 1 3545  
1947 0 0 4 1588 3676 0 0 0 6 3 mat 1 3811  5 scale 1 3720  5 shear 1 3720  3 hpr 1 3720  9 translate 1 3720  2 cs 1 3545  
1948 0 0 4 1588 3676 0 0 0 3 3 mat 1 3811  10 components 1 3846  2 cs 1 3545  
1949 0 0 4 1588 3676 0 0 0 5 3 mat 1 3790  5 scale 1 3717  3 hpr 1 3717  9 translate 1 3717  2 cs 1 3545  
1950 0 0 4 1588 3676 0 0 0 6 3 mat 1 3790  5 scale 1 3717  5 shear 1 3717  3 hpr 1 3717  9 translate 1 3717  2 cs 1 3545  
1951 0 0 4 1588 3676 0 0 0 3 3 mat 1 3790  10 components 1 3848  2 cs 1 3545  
1952 0 0 6 1589 3681 0 0 0 4 3 mat 1 3801  5 scale 1 3719  3 hpr 1 3719  2 cs 1 3545  
1953 0 0 6 1589 3681 0 0 0 5 3 mat 1 3801  5 scale 1 3719  5 shear 1 3719  3 hpr 1 3719  2 cs 1 3545  
1954 0 0 6 1589 3681 0 0 0 4 3 mat 1 3780  5 scale 1 3716  3 hpr 1 3716  2 cs 1 3545  
1955 0 0 6 1589 3681 0 0 0 5 3 mat 1 3780  5 scale 1 3716  5 shear 1 3716  3 hpr 1 3716  2 cs 1 3545  
1956 0 0 6 1589 3681 0 0 0 5 3 mat 1 3805  5 scale 1 3719  3 hpr 1 3719  9 translate 1 3719  2 cs 1 3545  
1957 0 0 6 1589 3681 0 0 0 6 3 mat 1 3805  5 scale 1 3719  5 shear 1 3719  3 hpr 1 3719  9 translate 1 3719  2 cs 1 3545  
1958 0 0 6 1589 3681 0 0 0 3 3 mat 1 3805  10 components 1 3850  2 CS 1 3545  
1959 0 0 6 1589 3681 0 0 0 5 3 mat 1 3784  5 scale 1 3716  3 hpr 1 3716  9 translate 1 3716  2 cs 1 3545  
1960 0 0 6 1589 3681 0 0 0 6 3 mat 1 3784  5 scale 1 3716  5 shear 1 3716  3 hpr 1 3716  9 translate 1 3716  2 cs 1 3545  
1961 0 0 6 1589 3681 0 0 0 3 3 mat 1 3784  10 components 1 3851  2 CS 1 3545  
1962 0 0 6 1590 3681 0 0 0 5 3 mat 1 3801  5 scale 1 3719  5 shear 1 3719  3 hpr 1 3719  2 cs 1 3545  
1963 0 0 6 1590 3681 0 0 0 5 3 mat 1 3780  5 scale 1 3716  5 shear 1 3716  3 hpr 1 3716  2 cs 1 3545  
1964 0 0 7 1591 3719 2396 0 0 1 7 old_hpr 1 3720  
1965 0 0 7 1591 3716 2323 0 0 1 7 old_hpr 1 3717  
329
3523 11 MathNumbers 0 141313 11 MathNumbers 11 MathNumbers 0 0 0 1 1966 1967 0 0 0 0 0 0 0 0

3524 10 LVecBase2f 0 141313 10 LVecBase2f 10 LVecBase2f 0 0 0 1 1970 2032 2 3852 3853 61 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 0 0 0 0 1 3525 75
/**
 * This is the base class for all two-component vectors and points.
 */

3525 0 0 794624 12 LVecBase2f:: 0 3524 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2f::num_components 0
2 6 is_int 18 LVecBase2f::is_int 0
0 0 0

3526 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

3527 10 LVecBase2d 0 141313 10 LVecBase2d 10 LVecBase2d 0 0 0 1 2033 2095 2 3854 3855 61 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 0 0 0 0 1 3528 75
/**
 * This is the base class for all two-component vectors and points.
 */

3528 0 0 794624 12 LVecBase2d:: 0 3527 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2d::num_components 0
2 6 is_int 18 LVecBase2d::is_int 0
0 0 0

3529 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

3530 10 LVecBase2i 0 141313 10 LVecBase2i 10 LVecBase2i 0 0 0 1 2096 2154 2 3856 3857 57 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 0 0 0 0 1 3531 75
/**
 * This is the base class for all two-component vectors and points.
 */

3531 0 0 794624 12 LVecBase2i:: 0 3530 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase2i::num_components 0
2 6 is_int 18 LVecBase2i::is_int 0
1 0 0

3532 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

3533 9 LVector2f 0 141313 9 LVector2f 9 LVector2f 0 0 0 1 2155 2172 0 16 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 0 0 1 0 3524 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3534 9 LVector2d 0 141313 9 LVector2d 9 LVector2d 0 0 0 1 2173 2190 0 16 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 0 0 1 0 3527 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3535 9 LVector2i 0 141313 9 LVector2i 9 LVector2i 0 0 0 1 2191 2204 0 12 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 0 0 1 0 3530 0 0 0 0 49
/**
 * This is a two-component vector offset.
 */

3536 8 LPoint2f 0 141313 8 LPoint2f 8 LPoint2f 0 0 0 1 2205 2220 0 14 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 0 0 1 0 3524 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3537 8 LPoint2d 0 141313 8 LPoint2d 8 LPoint2d 0 0 0 1 2221 2236 0 14 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 0 0 1 0 3527 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3538 8 LPoint2i 0 141313 8 LPoint2i 8 LPoint2i 0 0 0 1 2237 2250 0 12 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 0 0 1 0 3530 0 0 0 0 50
/**
 * This is a two-component point in space.
 */

3539 10 LVecBase3f 0 141313 10 LVecBase3f 10 LVecBase3f 0 0 0 1 2251 2323 6 3858 3859 3860 3861 3862 3863 71 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 0 0 0 0 1 3540 77
/**
 * This is the base class for all three-component vectors and points.
 */

3540 0 0 794624 12 LVecBase3f:: 0 3539 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3f::num_components 0
3 6 is_int 18 LVecBase3f::is_int 0
0 0 0

3541 10 LVecBase3d 0 141313 10 LVecBase3d 10 LVecBase3d 0 0 0 1 2324 2396 6 3864 3865 3866 3867 3868 3869 71 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 0 0 0 0 1 3542 77
/**
 * This is the base class for all three-component vectors and points.
 */

3542 0 0 794624 12 LVecBase3d:: 0 3541 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3d::num_components 0
3 6 is_int 18 LVecBase3d::is_int 0
0 0 0

3543 10 LVecBase3i 0 141313 10 LVecBase3i 10 LVecBase3i 0 0 0 1 2397 2464 6 3870 3871 3872 3873 3874 3875 66 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 0 0 0 0 1 3544 77
/**
 * This is the base class for all three-component vectors and points.
 */

3544 0 0 794624 12 LVecBase3i:: 0 3543 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase3i::num_components 0
3 6 is_int 18 LVecBase3i::is_int 0
1 0 0

3545 16 CoordinateSystem 0 532481 16 CoordinateSystem 16 CoordinateSystem 0 0 0 0 0 0 0 0 0 0 6 10 CS_default 10 CS_default 210
// The CS_default entry does not refer to a particular coordinate system,
// but rather to the value stored in default_coordinate_system, which in
// turn is loaded from the config variable "coordinate-system".
0 12 CS_zup_right 12 CS_zup_right 21
// Z-Up, Right-handed
1 12 CS_yup_right 12 CS_yup_right 21
// Y-Up, Right-handed
2 11 CS_zup_left 11 CS_zup_left 20
// Z-Up, Left-handed
3 11 CS_yup_left 11 CS_yup_left 20
// Y-Up, Left-handed
4 10 CS_invalid 10 CS_invalid 156
// CS_invalid is not a coordinate system at all.  It can be used in user-
// input processing code to indicate a contradictory coordinate system
// request.
5 0 0

3546 9 LVector3f 0 141313 9 LVector3f 9 LVector3f 0 0 0 1 2469 2502 3 3876 3877 3878 32 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 0 0 1 0 3539 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3547 9 LVector3d 0 141313 9 LVector3d 9 LVector3d 0 0 0 1 2503 2536 3 3879 3880 3881 32 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 0 0 1 0 3541 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3548 9 LVector3i 0 141313 9 LVector3i 9 LVector3i 0 0 0 1 2537 2562 3 3882 3883 3884 24 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 0 0 1 0 3543 0 0 0 0 338
/**
 * This is a three-component vector distance (as opposed to a three-component
 * point, which represents a particular point in space).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3549 8 LPoint3f 0 141313 8 LPoint3f 8 LPoint3f 0 0 0 1 2563 2585 3 3885 3886 3887 21 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 0 0 1 0 3539 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3550 8 LPoint3d 0 141313 8 LPoint3d 8 LPoint3d 0 0 0 1 2586 2608 3 3888 3889 3890 21 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 0 0 1 0 3541 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3551 8 LPoint3i 0 141313 8 LPoint3i 8 LPoint3i 0 0 0 1 2609 2629 3 3891 3892 3893 19 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 0 0 1 0 3543 0 0 0 0 337
/**
 * This is a three-component point in space (as opposed to a three-component
 * vector, which represents a direction and a distance).  Some of the methods
 * are slightly different between LPoint3 and LVector3; in particular,
 * subtraction of two points yields a vector, while addition of a vector and a
 * point yields a point.
 */

3552 10 LVecBase4f 0 141313 10 LVecBase4f 10 LVecBase4f 0 0 0 1 2630 2703 5 3894 3895 3896 3897 3898 72 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 0 0 0 0 1 3553 77
/**
 * This is the base class for all three-component vectors and points.
 */

3553 0 0 794624 12 LVecBase4f:: 0 3552 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4f::num_components 0
4 6 is_int 18 LVecBase4f::is_int 0
0 0 0

3554 19 UnalignedLVecBase4f 0 141313 19 UnalignedLVecBase4f 19 UnalignedLVecBase4f 0 0 0 1 2704 2714 0 9 2705 2706 2707 2708 2709 2710 2711 2712 2713 0 0 0 0 1 3555 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3555 0 0 794624 21 UnalignedLVecBase4f:: 0 3554 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4f::num_components 0
4 6 is_int 27 UnalignedLVecBase4f::is_int 0
0 0 0

3556 10 LVecBase4d 0 141313 10 LVecBase4d 10 LVecBase4d 0 0 0 1 2715 2788 5 3899 3900 3901 3902 3903 72 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 0 0 0 0 1 3557 77
/**
 * This is the base class for all three-component vectors and points.
 */

3557 0 0 794624 12 LVecBase4d:: 0 3556 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4d::num_components 0
4 6 is_int 18 LVecBase4d::is_int 0
0 0 0

3558 19 UnalignedLVecBase4d 0 141313 19 UnalignedLVecBase4d 19 UnalignedLVecBase4d 0 0 0 1 2789 2799 0 9 2790 2791 2792 2793 2794 2795 2796 2797 2798 0 0 0 0 1 3559 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3559 0 0 794624 21 UnalignedLVecBase4d:: 0 3558 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4d::num_components 0
4 6 is_int 27 UnalignedLVecBase4d::is_int 0
0 0 0

3560 10 LVecBase4i 0 141313 10 LVecBase4i 10 LVecBase4i 0 0 0 1 2800 2869 5 3904 3905 3906 3907 3908 68 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 0 0 0 0 1 3561 77
/**
 * This is the base class for all three-component vectors and points.
 */

3561 0 0 794624 12 LVecBase4i:: 0 3560 0 0 0 0 0 0 0 0 0 2 14 num_components 26 LVecBase4i::num_components 0
4 6 is_int 18 LVecBase4i::is_int 0
1 0 0

3562 19 UnalignedLVecBase4i 0 141313 19 UnalignedLVecBase4i 19 UnalignedLVecBase4i 0 0 0 1 2870 2880 0 9 2871 2872 2873 2874 2875 2876 2877 2878 2879 0 0 0 0 1 3563 391
/**
 * This is an "unaligned" LVecBase4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LVecBase4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LVecBase4 to get actual use from
 * it.
 */

3563 0 0 794624 21 UnalignedLVecBase4i:: 0 3562 0 0 0 0 0 0 0 0 0 2 14 num_components 35 UnalignedLVecBase4i::num_components 0
4 6 is_int 27 UnalignedLVecBase4i::is_int 0
1 0 0

3564 9 LVector4f 0 141313 9 LVector4f 9 LVector4f 0 0 0 1 2881 2900 2 3909 3910 18 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 0 0 1 0 3552 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3565 9 LVector4d 0 141313 9 LVector4d 9 LVector4d 0 0 0 1 2901 2920 2 3911 3912 18 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 0 0 1 0 3556 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3566 9 LVector4i 0 141313 9 LVector4i 9 LVector4i 0 0 0 1 2921 2938 2 3913 3914 16 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 0 0 1 0 3560 0 0 0 0 52
/**
 * This is a four-component vector distance.
 */

3567 8 LPoint4f 0 141313 8 LPoint4f 8 LPoint4f 0 0 0 1 2939 2958 2 3915 3916 18 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 0 0 1 0 3552 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3568 8 LPoint4d 0 141313 8 LPoint4d 8 LPoint4d 0 0 0 1 2959 2978 2 3917 3918 18 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 0 0 1 0 3556 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3569 8 LPoint4i 0 141313 8 LPoint4i 8 LPoint4i 0 0 0 1 2979 2996 2 3919 3920 16 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 0 0 1 0 3560 0 0 0 0 51
/**
 * This is a four-component point in space.
 */

3570 9 LMatrix3f 0 141313 9 LMatrix3f 9 LMatrix3f 0 0 0 1 3007 3084 2 3921 3922 74 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 4 3929 3930 3931 3932 0 0 0 3 3571 3572 3573 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3571 0 0 794624 11 LMatrix3f:: 0 3570 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3f::num_components 0
9 6 is_int 17 LMatrix3f::is_int 0
0 0 0

3572 3 Row 0 403457 14 LMatrix3f::Row 14 LMatrix3f::Row 3570 0 0 1 3000 3001 0 2 2997 2998 0 1 2999 0 0 0 66
// These helper classes are used to support two-level operator [].

3573 4 CRow 0 403457 15 LMatrix3f::CRow 15 LMatrix3f::CRow 3570 0 0 1 3005 3006 0 2 3002 3003 0 1 3004 0 0 0 0

3574 9 LMatrix4f 0 141313 9 LMatrix4f 9 LMatrix4f 0 0 0 1 3097 3184 2 3923 3924 84 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3 3933 3934 3935 0 0 0 3 3575 3576 3577 45
/**
 * This is a 4-by-4 transform matrix.
 */

3575 0 0 794624 11 LMatrix4f:: 0 3574 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4f::num_components 0
16 6 is_int 17 LMatrix4f::is_int 0
0 0 0

3576 3 Row 0 403457 14 LMatrix4f::Row 14 LMatrix4f::Row 3574 0 0 1 3090 3091 0 2 3087 3088 0 1 3089 0 0 0 66
// These helper classes are used to support two-level operator [].

3577 4 CRow 0 403457 15 LMatrix4f::CRow 15 LMatrix4f::CRow 3574 0 0 1 3095 3096 0 2 3092 3093 0 1 3094 0 0 0 0

3578 18 UnalignedLMatrix4f 0 141313 18 UnalignedLMatrix4f 18 UnalignedLMatrix4f 0 0 0 1 3185 3194 0 8 3186 3187 3188 3189 3190 3191 3192 3193 0 0 0 0 1 3579 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3579 0 0 794624 20 UnalignedLMatrix4f:: 0 3578 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4f::num_components 0
16 0 0

3580 9 LMatrix3d 0 141313 9 LMatrix3d 9 LMatrix3d 0 0 0 1 3205 3282 2 3925 3926 74 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 4 3936 3937 3938 3939 0 0 0 3 3581 3582 3583 231
/**
 * This is a 3-by-3 transform matrix.  It typically will represent either a
 * rotation-and-scale (no translation) matrix in 3-d, or a full affine matrix
 * (rotation, scale, translation) in 2-d, e.g.  for a texture matrix.
 */

3581 0 0 794624 11 LMatrix3d:: 0 3580 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix3d::num_components 0
9 6 is_int 17 LMatrix3d::is_int 0
0 0 0

3582 3 Row 0 403457 14 LMatrix3d::Row 14 LMatrix3d::Row 3580 0 0 1 3198 3199 0 2 3195 3196 0 1 3197 0 0 0 66
// These helper classes are used to support two-level operator [].

3583 4 CRow 0 403457 15 LMatrix3d::CRow 15 LMatrix3d::CRow 3580 0 0 1 3203 3204 0 2 3200 3201 0 1 3202 0 0 0 0

3584 9 LMatrix4d 0 141313 9 LMatrix4d 9 LMatrix4d 0 0 0 1 3293 3380 2 3927 3928 84 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3 3940 3941 3942 0 0 0 3 3585 3586 3587 45
/**
 * This is a 4-by-4 transform matrix.
 */

3585 0 0 794624 11 LMatrix4d:: 0 3584 0 0 0 0 0 0 0 0 0 2 14 num_components 25 LMatrix4d::num_components 0
16 6 is_int 17 LMatrix4d::is_int 0
0 0 0

3586 3 Row 0 403457 14 LMatrix4d::Row 14 LMatrix4d::Row 3584 0 0 1 3286 3287 0 2 3283 3284 0 1 3285 0 0 0 66
// These helper classes are used to support two-level operator [].

3587 4 CRow 0 403457 15 LMatrix4d::CRow 15 LMatrix4d::CRow 3584 0 0 1 3291 3292 0 2 3288 3289 0 1 3290 0 0 0 0

3588 18 UnalignedLMatrix4d 0 141313 18 UnalignedLMatrix4d 18 UnalignedLMatrix4d 0 0 0 1 3381 3390 0 8 3382 3383 3384 3385 3386 3387 3388 3389 0 0 0 0 1 3589 385
/**
 * This is an "unaligned" LMatrix4.  It has no functionality other than to
 * store numbers, and it will pack them in as tightly as possible, avoiding
 * any SSE2 alignment requirements shared by the primary LMatrix4 class.
 *
 * Use it only when you need to pack numbers tightly without respect to
 * alignment, and then copy it to a proper LMatrix4 to get actual use from it.
 */

3589 0 0 794624 20 UnalignedLMatrix4d:: 0 3588 0 0 0 0 0 0 0 0 0 1 14 num_components 34 UnalignedLMatrix4d::num_components 0
16 0 0

3590 12 LQuaternionf 0 141313 12 LQuaternionf 12 LQuaternionf 0 0 0 1 3399 3447 0 47 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 0 0 1 0 3552 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3591 12 LQuaterniond 0 141313 12 LQuaterniond 12 LQuaterniond 0 0 0 1 3448 3496 0 47 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 0 0 1 0 3556 0 0 0 0 44
/**
 * This is the base quaternion class
 */

3592 10 LRotationf 0 141313 10 LRotationf 10 LRotationf 0 0 0 1 3497 3501 0 3 3498 3499 3500 0 0 1 0 3590 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3593 10 LRotationd 0 141313 10 LRotationd 10 LRotationd 0 0 0 1 3502 3506 0 3 3503 3504 3505 0 0 1 0 3591 0 0 0 0 61
/**
 * This is a unit quaternion representing a rotation.
 */

3594 13 LOrientationf 0 141313 13 LOrientationf 13 LOrientationf 0 0 0 1 3507 3510 0 2 3508 3509 0 0 1 0 3590 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3595 13 LOrientationd 0 141313 13 LOrientationd 13 LOrientationd 0 0 0 1 3511 3514 0 2 3512 3513 0 0 1 0 3591 0 0 0 0 65
/**
 * This is a unit quaternion representing an orientation.
 */

3596 8 LVertexf 0 2105345 8 LVertexf 8 LVertexf 0 0 3549 0 0 0 0 0 0 0 0 0 0

3597 8 LNormalf 0 2105345 8 LNormalf 8 LNormalf 0 0 3546 0 0 0 0 0 0 0 0 0 0

3598 10 LTexCoordf 0 2105345 10 LTexCoordf 10 LTexCoordf 0 0 3536 0 0 0 0 0 0 0 0 0 0

3599 11 LTexCoord3f 0 2105345 11 LTexCoord3f 11 LTexCoord3f 0 0 3549 0 0 0 0 0 0 0 0 0 0

3600 7 LColorf 0 2105345 7 LColorf 7 LColorf 0 0 3552 0 0 0 0 0 0 0 0 0 0

3601 10 LRGBColorf 0 2105345 10 LRGBColorf 10 LRGBColorf 0 0 3539 0 0 0 0 0 0 0 0 0 0

3602 8 LVertexd 0 2105345 8 LVertexd 8 LVertexd 0 0 3550 0 0 0 0 0 0 0 0 0 0

3603 8 LNormald 0 2105345 8 LNormald 8 LNormald 0 0 3547 0 0 0 0 0 0 0 0 0 0

3604 10 LTexCoordd 0 2105345 10 LTexCoordd 10 LTexCoordd 0 0 3537 0 0 0 0 0 0 0 0 0 0

3605 11 LTexCoord3d 0 2105345 11 LTexCoord3d 11 LTexCoord3d 0 0 3550 0 0 0 0 0 0 0 0 0 0

3606 7 LColord 0 2105345 7 LColord 7 LColord 0 0 3556 0 0 0 0 0 0 0 0 0 0

3607 10 LRGBColord 0 2105345 10 LRGBColord 10 LRGBColord 0 0 3541 0 0 0 0 0 0 0 0 0 0

3608 5 Mat4F 0 2105345 5 Mat4F 5 Mat4F 0 0 3574 0 0 0 0 0 0 0 0 0 0

3609 5 Mat3F 0 2105345 5 Mat3F 5 Mat3F 0 0 3570 0 0 0 0 0 0 0 0 0 0

3610 7 VBase4F 0 2105345 7 VBase4F 7 VBase4F 0 0 3552 0 0 0 0 0 0 0 0 0 0

3611 5 Vec4F 0 2105345 5 Vec4F 5 Vec4F 0 0 3564 0 0 0 0 0 0 0 0 0 0

3612 7 Point4F 0 2105345 7 Point4F 7 Point4F 0 0 3567 0 0 0 0 0 0 0 0 0 0

3613 7 VBase3F 0 2105345 7 VBase3F 7 VBase3F 0 0 3539 0 0 0 0 0 0 0 0 0 0

3614 5 Vec3F 0 2105345 5 Vec3F 5 Vec3F 0 0 3546 0 0 0 0 0 0 0 0 0 0

3615 7 Point3F 0 2105345 7 Point3F 7 Point3F 0 0 3549 0 0 0 0 0 0 0 0 0 0

3616 7 VBase2F 0 2105345 7 VBase2F 7 VBase2F 0 0 3524 0 0 0 0 0 0 0 0 0 0

3617 5 Vec2F 0 2105345 5 Vec2F 5 Vec2F 0 0 3533 0 0 0 0 0 0 0 0 0 0

3618 7 Point2F 0 2105345 7 Point2F 7 Point2F 0 0 3536 0 0 0 0 0 0 0 0 0 0

3619 5 QuatF 0 2105345 5 QuatF 5 QuatF 0 0 3590 0 0 0 0 0 0 0 0 0 0

3620 5 Mat4D 0 2105345 5 Mat4D 5 Mat4D 0 0 3584 0 0 0 0 0 0 0 0 0 0

3621 5 Mat3D 0 2105345 5 Mat3D 5 Mat3D 0 0 3580 0 0 0 0 0 0 0 0 0 0

3622 7 VBase4D 0 2105345 7 VBase4D 7 VBase4D 0 0 3556 0 0 0 0 0 0 0 0 0 0

3623 5 Vec4D 0 2105345 5 Vec4D 5 Vec4D 0 0 3565 0 0 0 0 0 0 0 0 0 0

3624 7 Point4D 0 2105345 7 Point4D 7 Point4D 0 0 3568 0 0 0 0 0 0 0 0 0 0

3625 7 VBase3D 0 2105345 7 VBase3D 7 VBase3D 0 0 3541 0 0 0 0 0 0 0 0 0 0

3626 5 Vec3D 0 2105345 5 Vec3D 5 Vec3D 0 0 3547 0 0 0 0 0 0 0 0 0 0

3627 7 Point3D 0 2105345 7 Point3D 7 Point3D 0 0 3550 0 0 0 0 0 0 0 0 0 0

3628 7 VBase2D 0 2105345 7 VBase2D 7 VBase2D 0 0 3527 0 0 0 0 0 0 0 0 0 0

3629 5 Vec2D 0 2105345 5 Vec2D 5 Vec2D 0 0 3534 0 0 0 0 0 0 0 0 0 0

3630 7 Point2D 0 2105345 7 Point2D 7 Point2D 0 0 3537 0 0 0 0 0 0 0 0 0 0

3631 5 QuatD 0 2105345 5 QuatD 5 QuatD 0 0 3591 0 0 0 0 0 0 0 0 0 0

3632 9 LVecBase2 0 2105345 9 LVecBase2 9 LVecBase2 0 0 3524 0 0 0 0 0 0 0 0 0 0

3633 7 LPoint2 0 2105345 7 LPoint2 7 LPoint2 0 0 3536 0 0 0 0 0 0 0 0 0 0

3634 8 LVector2 0 2105345 8 LVector2 8 LVector2 0 0 3533 0 0 0 0 0 0 0 0 0 0

3635 9 LVecBase3 0 2105345 9 LVecBase3 9 LVecBase3 0 0 3539 0 0 0 0 0 0 0 0 0 0

3636 7 LPoint3 0 2105345 7 LPoint3 7 LPoint3 0 0 3549 0 0 0 0 0 0 0 0 0 0

3637 8 LVector3 0 2105345 8 LVector3 8 LVector3 0 0 3546 0 0 0 0 0 0 0 0 0 0

3638 9 LVecBase4 0 2105345 9 LVecBase4 9 LVecBase4 0 0 3552 0 0 0 0 0 0 0 0 0 0

3639 7 LPoint4 0 2105345 7 LPoint4 7 LPoint4 0 0 3567 0 0 0 0 0 0 0 0 0 0

3640 8 LVector4 0 2105345 8 LVector4 8 LVector4 0 0 3564 0 0 0 0 0 0 0 0 0 0

3641 11 LQuaternion 0 2105345 11 LQuaternion 11 LQuaternion 0 0 3590 0 0 0 0 0 0 0 0 0 0

3642 9 LRotation 0 2105345 9 LRotation 9 LRotation 0 0 3592 0 0 0 0 0 0 0 0 0 0

3643 12 LOrientation 0 2105345 12 LOrientation 12 LOrientation 0 0 3594 0 0 0 0 0 0 0 0 0 0

3644 8 LMatrix3 0 2105345 8 LMatrix3 8 LMatrix3 0 0 3570 0 0 0 0 0 0 0 0 0 0

3645 8 LMatrix4 0 2105345 8 LMatrix4 8 LMatrix4 0 0 3574 0 0 0 0 0 0 0 0 0 0

3646 7 LVertex 0 2105345 7 LVertex 7 LVertex 0 0 3596 0 0 0 0 0 0 0 0 0 0

3647 7 LNormal 0 2105345 7 LNormal 7 LNormal 0 0 3597 0 0 0 0 0 0 0 0 0 0

3648 9 LTexCoord 0 2105345 9 LTexCoord 9 LTexCoord 0 0 3598 0 0 0 0 0 0 0 0 0 0

3649 10 LTexCoord3 0 2105345 10 LTexCoord3 10 LTexCoord3 0 0 3599 0 0 0 0 0 0 0 0 0 0

3650 6 LColor 0 2105345 6 LColor 6 LColor 0 0 3600 0 0 0 0 0 0 0 0 0 0

3651 9 LRGBColor 0 2105345 9 LRGBColor 9 LRGBColor 0 0 3601 0 0 0 0 0 0 0 0 0 0

3652 18 UnalignedLVecBase4 0 2105345 18 UnalignedLVecBase4 18 UnalignedLVecBase4 0 0 3554 0 0 0 0 0 0 0 0 0 0

3653 17 UnalignedLMatrix4 0 2105345 17 UnalignedLMatrix4 17 UnalignedLMatrix4 0 0 3578 0 0 0 0 0 0 0 0 0 0

3654 4 Mat4 0 2105345 4 Mat4 4 Mat4 0 0 3574 0 0 0 0 0 0 0 0 0 0

3655 4 Mat3 0 2105345 4 Mat3 4 Mat3 0 0 3570 0 0 0 0 0 0 0 0 0 0

3656 6 VBase4 0 2105345 6 VBase4 6 VBase4 0 0 3552 0 0 0 0 0 0 0 0 0 0

3657 4 Vec4 0 2105345 4 Vec4 4 Vec4 0 0 3564 0 0 0 0 0 0 0 0 0 0

3658 6 Point4 0 2105345 6 Point4 6 Point4 0 0 3567 0 0 0 0 0 0 0 0 0 0

3659 6 VBase3 0 2105345 6 VBase3 6 VBase3 0 0 3539 0 0 0 0 0 0 0 0 0 0

3660 4 Vec3 0 2105345 4 Vec3 4 Vec3 0 0 3546 0 0 0 0 0 0 0 0 0 0

3661 6 Point3 0 2105345 6 Point3 6 Point3 0 0 3549 0 0 0 0 0 0 0 0 0 0

3662 6 VBase2 0 2105345 6 VBase2 6 VBase2 0 0 3524 0 0 0 0 0 0 0 0 0 0

3663 4 Vec2 0 2105345 4 Vec2 4 Vec2 0 0 3533 0 0 0 0 0 0 0 0 0 0

3664 6 Point2 0 2105345 6 Point2 6 Point2 0 0 3536 0 0 0 0 0 0 0 0 0 0

3665 4 Quat 0 2105345 4 Quat 4 Quat 0 0 3590 0 0 0 0 0 0 0 0 0 0

3666 19 ConfigVariableColor 0 141313 19 ConfigVariableColor 19 ConfigVariableColor 0 0 0 1 3515 3522 0 5 3516 3518 3519 3520 3521 0 1 3517 1 0 3667 0 0 0 0 538
/**
 * This is a convenience class to specialize ConfigVariable as a set of
 * floating-point types representing a color value.
 *
 * It interprets the color differently depending on how many words were
 * specified: if only one, it is interpreted as a shade of gray with alpha 1.
 * If two values were specified, a grayscale and alpha pair.  If three, a set
 * of R, G, B values with alpha 1, and if four, a complete RGBA color.
 *
 * This isn't defined in dtool because it relies on the LColor class, which is
 * defined in linmath.
 */

3667 14 ConfigVariable 0 2048 14 ConfigVariable 14 ConfigVariable 0 0 0 0 0 0 0 0 0 0 0 0 415
/**
 * This is a generic, untyped ConfigVariable.  It is also the base class for
 * the typed ConfigVariables, and contains all of the code common to
 * ConfigVariables of all types (except ConfigVariableList, which is a bit of
 * a special case).
 *
 * Mostly, this class serves as a thin wrapper around ConfigVariableCore
 * and/or ConfigDeclaration, more or less duplicating the interface presented
 * there.
 */

3668 13 MathNumbers * 0 8576 13 MathNumbers * 13 MathNumbers * 0 0 3523 0 0 0 0 0 0 0 0 0 0

3669 19 MathNumbers const * 0 8576 19 MathNumbers const * 19 MathNumbers const * 0 0 3670 0 0 0 0 0 0 0 0 0 0

3670 17 MathNumbers const 0 8832 17 MathNumbers const 17 MathNumbers const 0 0 3523 0 0 0 0 0 0 0 0 0 0

3671 12 LVecBase2f * 0 8576 12 LVecBase2f * 12 LVecBase2f * 0 0 3524 0 0 0 0 0 0 0 0 0 0

3672 18 LVecBase2f const * 0 8576 18 LVecBase2f const * 18 LVecBase2f const * 0 0 3673 0 0 0 0 0 0 0 0 0 0

3673 16 LVecBase2f const 0 8832 16 LVecBase2f const 16 LVecBase2f const 0 0 3524 0 0 0 0 0 0 0 0 0 0

3674 6 size_t 0 2105344 11 std::size_t 11 std::size_t 0 0 3675 0 0 0 0 0 0 0 0 0 0

3675 22 unsigned long long int 0 8230 22 unsigned long long int 22 unsigned long long int 0 8 0 0 0 0 0 0 0 0 0 0 0

3676 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

3677 10 PyObject * 0 8576 10 PyObject * 10 PyObject * 0 0 3678 0 0 0 0 0 0 0 0 0 0

3678 8 PyObject 0 2105344 8 PyObject 8 PyObject 0 0 3679 0 0 0 0 0 0 0 0 0 0

3679 7 _object 0 1024 7 _object 7 _object 0 0 0 0 0 0 0 0 0 0 0 0 0

3680 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

3681 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

3682 23 ChecksumHashGenerator * 0 8576 23 ChecksumHashGenerator * 23 ChecksumHashGenerator * 0 0 3683 0 0 0 0 0 0 0 0 0 0

3683 21 ChecksumHashGenerator 0 2048 21 ChecksumHashGenerator 21 ChecksumHashGenerator 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * This is a specific kind of HashGenerator that simply adds up all of the
 * ints.  Nothing fancy, and pretty quick.
 */

3684 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 3685 0 0 0 0 0 0 0 0 0 0

3685 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

3686 10 Datagram * 0 8576 10 Datagram * 10 Datagram * 0 0 3687 0 0 0 0 0 0 0 0 0 0

3687 8 Datagram 0 2048 8 Datagram 8 Datagram 0 0 0 0 0 0 0 0 0 0 0 0 565
/**
 * An ordered list of data elements, formatted in memory for transmission over
 * a socket or writing to a data file.
 *
 * Data elements should be added one at a time, in order, to the Datagram.
 * The nature and contents of the data elements are totally up to the user.
 * When a Datagram has been transmitted and received, its data elements may be
 * extracted using a DatagramIterator; it is up to the caller to know the
 * correct type of each data element in order.
 *
 * A Datagram is itself headerless; it is simply a collection of data
 * elements.
 */

3688 18 DatagramIterator * 0 8576 18 DatagramIterator * 18 DatagramIterator * 0 0 3689 0 0 0 0 0 0 0 0 0 0

3689 16 DatagramIterator 0 2048 16 DatagramIterator 16 DatagramIterator 0 0 0 0 0 0 0 0 0 0 0 0 215
/**
 * A class to retrieve the individual data elements previously stored in a
 * Datagram.  Elements may be retrieved one at a time; it is up to the caller
 * to know the correct type and order of each element.
 */

3690 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

3691 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 3690 0 0 0 0 0 0 0 0 0 0

3692 12 LVecBase2d * 0 8576 12 LVecBase2d * 12 LVecBase2d * 0 0 3527 0 0 0 0 0 0 0 0 0 0

3693 18 LVecBase2d const * 0 8576 18 LVecBase2d const * 18 LVecBase2d const * 0 0 3694 0 0 0 0 0 0 0 0 0 0

3694 16 LVecBase2d const 0 8832 16 LVecBase2d const 16 LVecBase2d const 0 0 3527 0 0 0 0 0 0 0 0 0 0

3695 12 LVecBase2i * 0 8576 12 LVecBase2i * 12 LVecBase2i * 0 0 3530 0 0 0 0 0 0 0 0 0 0

3696 18 LVecBase2i const * 0 8576 18 LVecBase2i const * 18 LVecBase2i const * 0 0 3697 0 0 0 0 0 0 0 0 0 0

3697 16 LVecBase2i const 0 8832 16 LVecBase2i const 16 LVecBase2i const 0 0 3530 0 0 0 0 0 0 0 0 0 0

3698 11 LVector2f * 0 8576 11 LVector2f * 11 LVector2f * 0 0 3533 0 0 0 0 0 0 0 0 0 0

3699 17 LVector2f const * 0 8576 17 LVector2f const * 17 LVector2f const * 0 0 3700 0 0 0 0 0 0 0 0 0 0

3700 15 LVector2f const 0 8832 15 LVector2f const 15 LVector2f const 0 0 3533 0 0 0 0 0 0 0 0 0 0

3701 11 LVector2d * 0 8576 11 LVector2d * 11 LVector2d * 0 0 3534 0 0 0 0 0 0 0 0 0 0

3702 17 LVector2d const * 0 8576 17 LVector2d const * 17 LVector2d const * 0 0 3703 0 0 0 0 0 0 0 0 0 0

3703 15 LVector2d const 0 8832 15 LVector2d const 15 LVector2d const 0 0 3534 0 0 0 0 0 0 0 0 0 0

3704 11 LVector2i * 0 8576 11 LVector2i * 11 LVector2i * 0 0 3535 0 0 0 0 0 0 0 0 0 0

3705 17 LVector2i const * 0 8576 17 LVector2i const * 17 LVector2i const * 0 0 3706 0 0 0 0 0 0 0 0 0 0

3706 15 LVector2i const 0 8832 15 LVector2i const 15 LVector2i const 0 0 3535 0 0 0 0 0 0 0 0 0 0

3707 10 LPoint2f * 0 8576 10 LPoint2f * 10 LPoint2f * 0 0 3536 0 0 0 0 0 0 0 0 0 0

3708 16 LPoint2f const * 0 8576 16 LPoint2f const * 16 LPoint2f const * 0 0 3709 0 0 0 0 0 0 0 0 0 0

3709 14 LPoint2f const 0 8832 14 LPoint2f const 14 LPoint2f const 0 0 3536 0 0 0 0 0 0 0 0 0 0

3710 10 LPoint2d * 0 8576 10 LPoint2d * 10 LPoint2d * 0 0 3537 0 0 0 0 0 0 0 0 0 0

3711 16 LPoint2d const * 0 8576 16 LPoint2d const * 16 LPoint2d const * 0 0 3712 0 0 0 0 0 0 0 0 0 0

3712 14 LPoint2d const 0 8832 14 LPoint2d const 14 LPoint2d const 0 0 3537 0 0 0 0 0 0 0 0 0 0

3713 10 LPoint2i * 0 8576 10 LPoint2i * 10 LPoint2i * 0 0 3538 0 0 0 0 0 0 0 0 0 0

3714 16 LPoint2i const * 0 8576 16 LPoint2i const * 16 LPoint2i const * 0 0 3715 0 0 0 0 0 0 0 0 0 0

3715 14 LPoint2i const 0 8832 14 LPoint2i const 14 LPoint2i const 0 0 3538 0 0 0 0 0 0 0 0 0 0

3716 12 LVecBase3f * 0 8576 12 LVecBase3f * 12 LVecBase3f * 0 0 3539 0 0 0 0 0 0 0 0 0 0

3717 18 LVecBase3f const * 0 8576 18 LVecBase3f const * 18 LVecBase3f const * 0 0 3718 0 0 0 0 0 0 0 0 0 0

3718 16 LVecBase3f const 0 8832 16 LVecBase3f const 16 LVecBase3f const 0 0 3539 0 0 0 0 0 0 0 0 0 0

3719 12 LVecBase3d * 0 8576 12 LVecBase3d * 12 LVecBase3d * 0 0 3541 0 0 0 0 0 0 0 0 0 0

3720 18 LVecBase3d const * 0 8576 18 LVecBase3d const * 18 LVecBase3d const * 0 0 3721 0 0 0 0 0 0 0 0 0 0

3721 16 LVecBase3d const 0 8832 16 LVecBase3d const 16 LVecBase3d const 0 0 3541 0 0 0 0 0 0 0 0 0 0

3722 12 LVecBase3i * 0 8576 12 LVecBase3i * 12 LVecBase3i * 0 0 3543 0 0 0 0 0 0 0 0 0 0

3723 18 LVecBase3i const * 0 8576 18 LVecBase3i const * 18 LVecBase3i const * 0 0 3724 0 0 0 0 0 0 0 0 0 0

3724 16 LVecBase3i const 0 8832 16 LVecBase3i const 16 LVecBase3i const 0 0 3543 0 0 0 0 0 0 0 0 0 0

3725 11 LVector3f * 0 8576 11 LVector3f * 11 LVector3f * 0 0 3546 0 0 0 0 0 0 0 0 0 0

3726 17 LVector3f const * 0 8576 17 LVector3f const * 17 LVector3f const * 0 0 3727 0 0 0 0 0 0 0 0 0 0

3727 15 LVector3f const 0 8832 15 LVector3f const 15 LVector3f const 0 0 3546 0 0 0 0 0 0 0 0 0 0

3728 11 LVector3d * 0 8576 11 LVector3d * 11 LVector3d * 0 0 3547 0 0 0 0 0 0 0 0 0 0

3729 17 LVector3d const * 0 8576 17 LVector3d const * 17 LVector3d const * 0 0 3730 0 0 0 0 0 0 0 0 0 0

3730 15 LVector3d const 0 8832 15 LVector3d const 15 LVector3d const 0 0 3547 0 0 0 0 0 0 0 0 0 0

3731 11 LVector3i * 0 8576 11 LVector3i * 11 LVector3i * 0 0 3548 0 0 0 0 0 0 0 0 0 0

3732 17 LVector3i const * 0 8576 17 LVector3i const * 17 LVector3i const * 0 0 3733 0 0 0 0 0 0 0 0 0 0

3733 15 LVector3i const 0 8832 15 LVector3i const 15 LVector3i const 0 0 3548 0 0 0 0 0 0 0 0 0 0

3734 10 LPoint3f * 0 8576 10 LPoint3f * 10 LPoint3f * 0 0 3549 0 0 0 0 0 0 0 0 0 0

3735 16 LPoint3f const * 0 8576 16 LPoint3f const * 16 LPoint3f const * 0 0 3736 0 0 0 0 0 0 0 0 0 0

3736 14 LPoint3f const 0 8832 14 LPoint3f const 14 LPoint3f const 0 0 3549 0 0 0 0 0 0 0 0 0 0

3737 10 LPoint3d * 0 8576 10 LPoint3d * 10 LPoint3d * 0 0 3550 0 0 0 0 0 0 0 0 0 0

3738 16 LPoint3d const * 0 8576 16 LPoint3d const * 16 LPoint3d const * 0 0 3739 0 0 0 0 0 0 0 0 0 0

3739 14 LPoint3d const 0 8832 14 LPoint3d const 14 LPoint3d const 0 0 3550 0 0 0 0 0 0 0 0 0 0

3740 10 LPoint3i * 0 8576 10 LPoint3i * 10 LPoint3i * 0 0 3551 0 0 0 0 0 0 0 0 0 0

3741 16 LPoint3i const * 0 8576 16 LPoint3i const * 16 LPoint3i const * 0 0 3742 0 0 0 0 0 0 0 0 0 0

3742 14 LPoint3i const 0 8832 14 LPoint3i const 14 LPoint3i const 0 0 3551 0 0 0 0 0 0 0 0 0 0

3743 12 LVecBase4f * 0 8576 12 LVecBase4f * 12 LVecBase4f * 0 0 3552 0 0 0 0 0 0 0 0 0 0

3744 18 LVecBase4f const * 0 8576 18 LVecBase4f const * 18 LVecBase4f const * 0 0 3745 0 0 0 0 0 0 0 0 0 0

3745 16 LVecBase4f const 0 8832 16 LVecBase4f const 16 LVecBase4f const 0 0 3552 0 0 0 0 0 0 0 0 0 0

3746 27 UnalignedLVecBase4f const * 0 8576 27 UnalignedLVecBase4f const * 27 UnalignedLVecBase4f const * 0 0 3747 0 0 0 0 0 0 0 0 0 0

3747 25 UnalignedLVecBase4f const 0 8832 25 UnalignedLVecBase4f const 25 UnalignedLVecBase4f const 0 0 3554 0 0 0 0 0 0 0 0 0 0

3748 21 UnalignedLVecBase4f * 0 8576 21 UnalignedLVecBase4f * 21 UnalignedLVecBase4f * 0 0 3554 0 0 0 0 0 0 0 0 0 0

3749 12 LVecBase4d * 0 8576 12 LVecBase4d * 12 LVecBase4d * 0 0 3556 0 0 0 0 0 0 0 0 0 0

3750 18 LVecBase4d const * 0 8576 18 LVecBase4d const * 18 LVecBase4d const * 0 0 3751 0 0 0 0 0 0 0 0 0 0

3751 16 LVecBase4d const 0 8832 16 LVecBase4d const 16 LVecBase4d const 0 0 3556 0 0 0 0 0 0 0 0 0 0

3752 27 UnalignedLVecBase4d const * 0 8576 27 UnalignedLVecBase4d const * 27 UnalignedLVecBase4d const * 0 0 3753 0 0 0 0 0 0 0 0 0 0

3753 25 UnalignedLVecBase4d const 0 8832 25 UnalignedLVecBase4d const 25 UnalignedLVecBase4d const 0 0 3558 0 0 0 0 0 0 0 0 0 0

3754 21 UnalignedLVecBase4d * 0 8576 21 UnalignedLVecBase4d * 21 UnalignedLVecBase4d * 0 0 3558 0 0 0 0 0 0 0 0 0 0

3755 12 LVecBase4i * 0 8576 12 LVecBase4i * 12 LVecBase4i * 0 0 3560 0 0 0 0 0 0 0 0 0 0

3756 18 LVecBase4i const * 0 8576 18 LVecBase4i const * 18 LVecBase4i const * 0 0 3757 0 0 0 0 0 0 0 0 0 0

3757 16 LVecBase4i const 0 8832 16 LVecBase4i const 16 LVecBase4i const 0 0 3560 0 0 0 0 0 0 0 0 0 0

3758 27 UnalignedLVecBase4i const * 0 8576 27 UnalignedLVecBase4i const * 27 UnalignedLVecBase4i const * 0 0 3759 0 0 0 0 0 0 0 0 0 0

3759 25 UnalignedLVecBase4i const 0 8832 25 UnalignedLVecBase4i const 25 UnalignedLVecBase4i const 0 0 3562 0 0 0 0 0 0 0 0 0 0

3760 21 UnalignedLVecBase4i * 0 8576 21 UnalignedLVecBase4i * 21 UnalignedLVecBase4i * 0 0 3562 0 0 0 0 0 0 0 0 0 0

3761 11 LVector4f * 0 8576 11 LVector4f * 11 LVector4f * 0 0 3564 0 0 0 0 0 0 0 0 0 0

3762 17 LVector4f const * 0 8576 17 LVector4f const * 17 LVector4f const * 0 0 3763 0 0 0 0 0 0 0 0 0 0

3763 15 LVector4f const 0 8832 15 LVector4f const 15 LVector4f const 0 0 3564 0 0 0 0 0 0 0 0 0 0

3764 11 LVector4d * 0 8576 11 LVector4d * 11 LVector4d * 0 0 3565 0 0 0 0 0 0 0 0 0 0

3765 17 LVector4d const * 0 8576 17 LVector4d const * 17 LVector4d const * 0 0 3766 0 0 0 0 0 0 0 0 0 0

3766 15 LVector4d const 0 8832 15 LVector4d const 15 LVector4d const 0 0 3565 0 0 0 0 0 0 0 0 0 0

3767 11 LVector4i * 0 8576 11 LVector4i * 11 LVector4i * 0 0 3566 0 0 0 0 0 0 0 0 0 0

3768 17 LVector4i const * 0 8576 17 LVector4i const * 17 LVector4i const * 0 0 3769 0 0 0 0 0 0 0 0 0 0

3769 15 LVector4i const 0 8832 15 LVector4i const 15 LVector4i const 0 0 3566 0 0 0 0 0 0 0 0 0 0

3770 10 LPoint4f * 0 8576 10 LPoint4f * 10 LPoint4f * 0 0 3567 0 0 0 0 0 0 0 0 0 0

3771 16 LPoint4f const * 0 8576 16 LPoint4f const * 16 LPoint4f const * 0 0 3772 0 0 0 0 0 0 0 0 0 0

3772 14 LPoint4f const 0 8832 14 LPoint4f const 14 LPoint4f const 0 0 3567 0 0 0 0 0 0 0 0 0 0

3773 10 LPoint4d * 0 8576 10 LPoint4d * 10 LPoint4d * 0 0 3568 0 0 0 0 0 0 0 0 0 0

3774 16 LPoint4d const * 0 8576 16 LPoint4d const * 16 LPoint4d const * 0 0 3775 0 0 0 0 0 0 0 0 0 0

3775 14 LPoint4d const 0 8832 14 LPoint4d const 14 LPoint4d const 0 0 3568 0 0 0 0 0 0 0 0 0 0

3776 10 LPoint4i * 0 8576 10 LPoint4i * 10 LPoint4i * 0 0 3569 0 0 0 0 0 0 0 0 0 0

3777 16 LPoint4i const * 0 8576 16 LPoint4i const * 16 LPoint4i const * 0 0 3778 0 0 0 0 0 0 0 0 0 0

3778 14 LPoint4i const 0 8832 14 LPoint4i const 14 LPoint4i const 0 0 3569 0 0 0 0 0 0 0 0 0 0

3779 11 LMatrix3f * 0 8576 11 LMatrix3f * 11 LMatrix3f * 0 0 3570 0 0 0 0 0 0 0 0 0 0

3780 17 LMatrix3f const * 0 8576 17 LMatrix3f const * 17 LMatrix3f const * 0 0 3781 0 0 0 0 0 0 0 0 0 0

3781 15 LMatrix3f const 0 8832 15 LMatrix3f const 15 LMatrix3f const 0 0 3570 0 0 0 0 0 0 0 0 0 0

3782 5 Row * 0 8576 16 LMatrix3f::Row * 16 LMatrix3f::Row * 0 0 3572 0 0 0 0 0 0 0 0 0 0

3783 6 CRow * 0 8576 17 LMatrix3f::CRow * 17 LMatrix3f::CRow * 0 0 3573 0 0 0 0 0 0 0 0 0 0

3784 17 LMatrix4f const * 0 8576 17 LMatrix4f const * 17 LMatrix4f const * 0 0 3785 0 0 0 0 0 0 0 0 0 0

3785 15 LMatrix4f const 0 8832 15 LMatrix4f const 15 LMatrix4f const 0 0 3574 0 0 0 0 0 0 0 0 0 0

3786 11 Row const * 0 8576 22 LMatrix3f::Row const * 22 LMatrix3f::Row const * 0 0 3787 0 0 0 0 0 0 0 0 0 0

3787 9 Row const 0 8832 20 LMatrix3f::Row const 20 LMatrix3f::Row const 0 0 3572 0 0 0 0 0 0 0 0 0 0

3788 12 CRow const * 0 8576 23 LMatrix3f::CRow const * 23 LMatrix3f::CRow const * 0 0 3789 0 0 0 0 0 0 0 0 0 0

3789 10 CRow const 0 8832 21 LMatrix3f::CRow const 21 LMatrix3f::CRow const 0 0 3573 0 0 0 0 0 0 0 0 0 0

3790 11 LMatrix4f * 0 8576 11 LMatrix4f * 11 LMatrix4f * 0 0 3574 0 0 0 0 0 0 0 0 0 0

3791 26 UnalignedLMatrix4f const * 0 8576 26 UnalignedLMatrix4f const * 26 UnalignedLMatrix4f const * 0 0 3792 0 0 0 0 0 0 0 0 0 0

3792 24 UnalignedLMatrix4f const 0 8832 24 UnalignedLMatrix4f const 24 UnalignedLMatrix4f const 0 0 3578 0 0 0 0 0 0 0 0 0 0

3793 5 Row * 0 8576 16 LMatrix4f::Row * 16 LMatrix4f::Row * 0 0 3576 0 0 0 0 0 0 0 0 0 0

3794 6 CRow * 0 8576 17 LMatrix4f::CRow * 17 LMatrix4f::CRow * 0 0 3577 0 0 0 0 0 0 0 0 0 0

3795 11 Row const * 0 8576 22 LMatrix4f::Row const * 22 LMatrix4f::Row const * 0 0 3796 0 0 0 0 0 0 0 0 0 0

3796 9 Row const 0 8832 20 LMatrix4f::Row const 20 LMatrix4f::Row const 0 0 3576 0 0 0 0 0 0 0 0 0 0

3797 12 CRow const * 0 8576 23 LMatrix4f::CRow const * 23 LMatrix4f::CRow const * 0 0 3798 0 0 0 0 0 0 0 0 0 0

3798 10 CRow const 0 8832 21 LMatrix4f::CRow const 21 LMatrix4f::CRow const 0 0 3577 0 0 0 0 0 0 0 0 0 0

3799 20 UnalignedLMatrix4f * 0 8576 20 UnalignedLMatrix4f * 20 UnalignedLMatrix4f * 0 0 3578 0 0 0 0 0 0 0 0 0 0

3800 11 LMatrix3d * 0 8576 11 LMatrix3d * 11 LMatrix3d * 0 0 3580 0 0 0 0 0 0 0 0 0 0

3801 17 LMatrix3d const * 0 8576 17 LMatrix3d const * 17 LMatrix3d const * 0 0 3802 0 0 0 0 0 0 0 0 0 0

3802 15 LMatrix3d const 0 8832 15 LMatrix3d const 15 LMatrix3d const 0 0 3580 0 0 0 0 0 0 0 0 0 0

3803 5 Row * 0 8576 16 LMatrix3d::Row * 16 LMatrix3d::Row * 0 0 3582 0 0 0 0 0 0 0 0 0 0

3804 6 CRow * 0 8576 17 LMatrix3d::CRow * 17 LMatrix3d::CRow * 0 0 3583 0 0 0 0 0 0 0 0 0 0

3805 17 LMatrix4d const * 0 8576 17 LMatrix4d const * 17 LMatrix4d const * 0 0 3806 0 0 0 0 0 0 0 0 0 0

3806 15 LMatrix4d const 0 8832 15 LMatrix4d const 15 LMatrix4d const 0 0 3584 0 0 0 0 0 0 0 0 0 0

3807 11 Row const * 0 8576 22 LMatrix3d::Row const * 22 LMatrix3d::Row const * 0 0 3808 0 0 0 0 0 0 0 0 0 0

3808 9 Row const 0 8832 20 LMatrix3d::Row const 20 LMatrix3d::Row const 0 0 3582 0 0 0 0 0 0 0 0 0 0

3809 12 CRow const * 0 8576 23 LMatrix3d::CRow const * 23 LMatrix3d::CRow const * 0 0 3810 0 0 0 0 0 0 0 0 0 0

3810 10 CRow const 0 8832 21 LMatrix3d::CRow const 21 LMatrix3d::CRow const 0 0 3583 0 0 0 0 0 0 0 0 0 0

3811 11 LMatrix4d * 0 8576 11 LMatrix4d * 11 LMatrix4d * 0 0 3584 0 0 0 0 0 0 0 0 0 0

3812 26 UnalignedLMatrix4d const * 0 8576 26 UnalignedLMatrix4d const * 26 UnalignedLMatrix4d const * 0 0 3813 0 0 0 0 0 0 0 0 0 0

3813 24 UnalignedLMatrix4d const 0 8832 24 UnalignedLMatrix4d const 24 UnalignedLMatrix4d const 0 0 3588 0 0 0 0 0 0 0 0 0 0

3814 5 Row * 0 8576 16 LMatrix4d::Row * 16 LMatrix4d::Row * 0 0 3586 0 0 0 0 0 0 0 0 0 0

3815 6 CRow * 0 8576 17 LMatrix4d::CRow * 17 LMatrix4d::CRow * 0 0 3587 0 0 0 0 0 0 0 0 0 0

3816 11 Row const * 0 8576 22 LMatrix4d::Row const * 22 LMatrix4d::Row const * 0 0 3817 0 0 0 0 0 0 0 0 0 0

3817 9 Row const 0 8832 20 LMatrix4d::Row const 20 LMatrix4d::Row const 0 0 3586 0 0 0 0 0 0 0 0 0 0

3818 12 CRow const * 0 8576 23 LMatrix4d::CRow const * 23 LMatrix4d::CRow const * 0 0 3819 0 0 0 0 0 0 0 0 0 0

3819 10 CRow const 0 8832 21 LMatrix4d::CRow const 21 LMatrix4d::CRow const 0 0 3587 0 0 0 0 0 0 0 0 0 0

3820 20 UnalignedLMatrix4d * 0 8576 20 UnalignedLMatrix4d * 20 UnalignedLMatrix4d * 0 0 3588 0 0 0 0 0 0 0 0 0 0

3821 14 LQuaternionf * 0 8576 14 LQuaternionf * 14 LQuaternionf * 0 0 3590 0 0 0 0 0 0 0 0 0 0

3822 20 LQuaternionf const * 0 8576 20 LQuaternionf const * 20 LQuaternionf const * 0 0 3823 0 0 0 0 0 0 0 0 0 0

3823 18 LQuaternionf const 0 8832 18 LQuaternionf const 18 LQuaternionf const 0 0 3590 0 0 0 0 0 0 0 0 0 0

3824 14 LQuaterniond * 0 8576 14 LQuaterniond * 14 LQuaterniond * 0 0 3591 0 0 0 0 0 0 0 0 0 0

3825 20 LQuaterniond const * 0 8576 20 LQuaterniond const * 20 LQuaterniond const * 0 0 3826 0 0 0 0 0 0 0 0 0 0

3826 18 LQuaterniond const 0 8832 18 LQuaterniond const 18 LQuaterniond const 0 0 3591 0 0 0 0 0 0 0 0 0 0

3827 12 LRotationf * 0 8576 12 LRotationf * 12 LRotationf * 0 0 3592 0 0 0 0 0 0 0 0 0 0

3828 18 LRotationf const * 0 8576 18 LRotationf const * 18 LRotationf const * 0 0 3829 0 0 0 0 0 0 0 0 0 0

3829 16 LRotationf const 0 8832 16 LRotationf const 16 LRotationf const 0 0 3592 0 0 0 0 0 0 0 0 0 0

3830 12 LRotationd * 0 8576 12 LRotationd * 12 LRotationd * 0 0 3593 0 0 0 0 0 0 0 0 0 0

3831 18 LRotationd const * 0 8576 18 LRotationd const * 18 LRotationd const * 0 0 3832 0 0 0 0 0 0 0 0 0 0

3832 16 LRotationd const 0 8832 16 LRotationd const 16 LRotationd const 0 0 3593 0 0 0 0 0 0 0 0 0 0

3833 15 LOrientationf * 0 8576 15 LOrientationf * 15 LOrientationf * 0 0 3594 0 0 0 0 0 0 0 0 0 0

3834 21 LOrientationf const * 0 8576 21 LOrientationf const * 21 LOrientationf const * 0 0 3835 0 0 0 0 0 0 0 0 0 0

3835 19 LOrientationf const 0 8832 19 LOrientationf const 19 LOrientationf const 0 0 3594 0 0 0 0 0 0 0 0 0 0

3836 15 LOrientationd * 0 8576 15 LOrientationd * 15 LOrientationd * 0 0 3595 0 0 0 0 0 0 0 0 0 0

3837 21 LOrientationd const * 0 8576 21 LOrientationd const * 21 LOrientationd const * 0 0 3838 0 0 0 0 0 0 0 0 0 0

3838 19 LOrientationd const 0 8832 19 LOrientationd const 19 LOrientationd const 0 0 3595 0 0 0 0 0 0 0 0 0 0

3839 27 ConfigVariableColor const * 0 8576 27 ConfigVariableColor const * 27 ConfigVariableColor const * 0 0 3840 0 0 0 0 0 0 0 0 0 0

3840 25 ConfigVariableColor const 0 8832 25 ConfigVariableColor const 25 ConfigVariableColor const 0 0 3666 0 0 0 0 0 0 0 0 0 0

3841 21 ConfigVariableColor * 0 8576 21 ConfigVariableColor * 21 ConfigVariableColor * 0 0 3666 0 0 0 0 0 0 0 0 0 0

3842 14 LColor const * 0 8576 14 LColor const * 14 LColor const * 0 0 3843 0 0 0 0 0 0 0 0 0 0

3843 12 LColor const 0 8832 12 LColor const 12 LColor const 0 0 3650 0 0 0 0 0 0 0 0 0 0

3844 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 3526 0 0 0 0 0 0 0 0 0 0

3845 8 LColor * 0 8576 8 LColor * 8 LColor * 0 0 3650 0 0 0 0 0 0 0 0 0 0

3846 38 double const [::num_matrix_components] 0 4202496 38 double const [::num_matrix_components] 38 double const [::num_matrix_components] 0 0 3847 12 0 0 0 0 0 0 0 0 0 0

3847 12 double const 0 8832 12 double const 12 double const 0 0 3529 0 0 0 0 0 0 0 0 0 0

3848 37 float const [::num_matrix_components] 0 4202496 37 float const [::num_matrix_components] 37 float const [::num_matrix_components] 0 0 3849 12 0 0 0 0 0 0 0 0 0 0

3849 11 float const 0 8832 11 float const 11 float const 0 0 3526 0 0 0 0 0 0 0 0 0 0

3850 32 double [::num_matrix_components] 0 4202496 32 double [::num_matrix_components] 32 double [::num_matrix_components] 0 0 3529 12 0 0 0 0 0 0 0 0 0 0

3851 31 float [::num_matrix_components] 0 4202496 31 float [::num_matrix_components] 31 float [::num_matrix_components] 0 0 3526 12 0 0 0 0 0 0 0 0 0 0

0
77
3852 1 x 0 6 3526 1986 1988 0 0 0 0 0 0 13 LVecBase2f::x 0

3853 1 y 0 6 3526 1987 1989 0 0 0 0 0 0 13 LVecBase2f::y 0

3854 1 x 0 6 3529 2049 2051 0 0 0 0 0 0 13 LVecBase2d::x 0

3855 1 y 0 6 3529 2050 2052 0 0 0 0 0 0 13 LVecBase2d::y 0

3856 1 x 0 6 3532 2112 2114 0 0 0 0 0 0 13 LVecBase2i::x 0

3857 1 y 0 6 3532 2113 2115 0 0 0 0 0 0 13 LVecBase2i::y 0

3858 1 x 0 6 3526 2267 2271 0 0 0 0 0 0 13 LVecBase3f::x 0

3859 1 y 0 6 3526 2268 2272 0 0 0 0 0 0 13 LVecBase3f::y 0

3860 1 z 0 6 3526 2269 2273 0 0 0 0 0 0 13 LVecBase3f::z 0

3861 2 xy 0 2 3524 2274 0 0 0 0 0 0 0 14 LVecBase3f::xy 0

3862 2 xz 0 2 3524 2275 0 0 0 0 0 0 0 14 LVecBase3f::xz 0

3863 2 yz 0 2 3524 2276 0 0 0 0 0 0 0 14 LVecBase3f::yz 0

3864 1 x 0 6 3529 2340 2344 0 0 0 0 0 0 13 LVecBase3d::x 0

3865 1 y 0 6 3529 2341 2345 0 0 0 0 0 0 13 LVecBase3d::y 0

3866 1 z 0 6 3529 2342 2346 0 0 0 0 0 0 13 LVecBase3d::z 0

3867 2 xy 0 2 3527 2347 0 0 0 0 0 0 0 14 LVecBase3d::xy 0

3868 2 xz 0 2 3527 2348 0 0 0 0 0 0 0 14 LVecBase3d::xz 0

3869 2 yz 0 2 3527 2349 0 0 0 0 0 0 0 14 LVecBase3d::yz 0

3870 1 x 0 6 3532 2413 2417 0 0 0 0 0 0 13 LVecBase3i::x 0

3871 1 y 0 6 3532 2414 2418 0 0 0 0 0 0 13 LVecBase3i::y 0

3872 1 z 0 6 3532 2415 2419 0 0 0 0 0 0 13 LVecBase3i::z 0

3873 2 xy 0 2 3530 2420 0 0 0 0 0 0 0 14 LVecBase3i::xy 0

3874 2 xz 0 2 3530 2421 0 0 0 0 0 0 0 14 LVecBase3i::xz 0

3875 2 yz 0 2 3530 2422 0 0 0 0 0 0 0 14 LVecBase3i::yz 0

3876 2 xy 0 2 3533 2476 0 0 0 0 0 0 0 13 LVector3f::xy 0

3877 2 xz 0 2 3533 2477 0 0 0 0 0 0 0 13 LVector3f::xz 0

3878 2 yz 0 2 3533 2478 0 0 0 0 0 0 0 13 LVector3f::yz 0

3879 2 xy 0 2 3534 2510 0 0 0 0 0 0 0 13 LVector3d::xy 0

3880 2 xz 0 2 3534 2511 0 0 0 0 0 0 0 13 LVector3d::xz 0

3881 2 yz 0 2 3534 2512 0 0 0 0 0 0 0 13 LVector3d::yz 0

3882 2 xy 0 2 3535 2544 0 0 0 0 0 0 0 13 LVector3i::xy 0

3883 2 xz 0 2 3535 2545 0 0 0 0 0 0 0 13 LVector3i::xz 0

3884 2 yz 0 2 3535 2546 0 0 0 0 0 0 0 13 LVector3i::yz 0

3885 2 xy 0 2 3536 2570 0 0 0 0 0 0 0 12 LPoint3f::xy 0

3886 2 xz 0 2 3536 2571 0 0 0 0 0 0 0 12 LPoint3f::xz 0

3887 2 yz 0 2 3536 2572 0 0 0 0 0 0 0 12 LPoint3f::yz 0

3888 2 xy 0 2 3537 2593 0 0 0 0 0 0 0 12 LPoint3d::xy 0

3889 2 xz 0 2 3537 2594 0 0 0 0 0 0 0 12 LPoint3d::xz 0

3890 2 yz 0 2 3537 2595 0 0 0 0 0 0 0 12 LPoint3d::yz 0

3891 2 xy 0 2 3538 2616 0 0 0 0 0 0 0 12 LPoint3i::xy 0

3892 2 xz 0 2 3538 2617 0 0 0 0 0 0 0 12 LPoint3i::xz 0

3893 2 yz 0 2 3538 2618 0 0 0 0 0 0 0 12 LPoint3i::yz 0

3894 1 x 0 6 3526 2648 2654 0 0 0 0 0 0 13 LVecBase4f::x 0

3895 1 y 0 6 3526 2649 2655 0 0 0 0 0 0 13 LVecBase4f::y 0

3896 1 z 0 6 3526 2650 2656 0 0 0 0 0 0 13 LVecBase4f::z 0

3897 3 xyz 0 2 3539 2652 0 0 0 0 0 0 0 15 LVecBase4f::xyz 0

3898 2 xy 0 2 3524 2653 0 0 0 0 0 0 0 14 LVecBase4f::xy 0

3899 1 x 0 6 3529 2733 2739 0 0 0 0 0 0 13 LVecBase4d::x 0

3900 1 y 0 6 3529 2734 2740 0 0 0 0 0 0 13 LVecBase4d::y 0

3901 1 z 0 6 3529 2735 2741 0 0 0 0 0 0 13 LVecBase4d::z 0

3902 3 xyz 0 2 3541 2737 0 0 0 0 0 0 0 15 LVecBase4d::xyz 0

3903 2 xy 0 2 3527 2738 0 0 0 0 0 0 0 14 LVecBase4d::xy 0

3904 1 x 0 6 3532 2818 2824 0 0 0 0 0 0 13 LVecBase4i::x 0

3905 1 y 0 6 3532 2819 2825 0 0 0 0 0 0 13 LVecBase4i::y 0

3906 1 z 0 6 3532 2820 2826 0 0 0 0 0 0 13 LVecBase4i::z 0

3907 3 xyz 0 2 3543 2822 0 0 0 0 0 0 0 15 LVecBase4i::xyz 0

3908 2 xy 0 2 3530 2823 0 0 0 0 0 0 0 14 LVecBase4i::xy 0

3909 3 xyz 0 2 3546 2889 0 0 0 0 0 0 0 14 LVector4f::xyz 0

3910 2 xy 0 2 3533 2890 0 0 0 0 0 0 0 13 LVector4f::xy 0

3911 3 xyz 0 2 3547 2909 0 0 0 0 0 0 0 14 LVector4d::xyz 0

3912 2 xy 0 2 3534 2910 0 0 0 0 0 0 0 13 LVector4d::xy 0

3913 3 xyz 0 2 3548 2929 0 0 0 0 0 0 0 14 LVector4i::xyz 0

3914 2 xy 0 2 3535 2930 0 0 0 0 0 0 0 13 LVector4i::xy 0

3915 3 xyz 0 2 3549 2947 0 0 0 0 0 0 0 13 LPoint4f::xyz 0

3916 2 xy 0 2 3536 2948 0 0 0 0 0 0 0 12 LPoint4f::xy 0

3917 3 xyz 0 2 3550 2967 0 0 0 0 0 0 0 13 LPoint4d::xyz 0

3918 2 xy 0 2 3537 2968 0 0 0 0 0 0 0 12 LPoint4d::xy 0

3919 3 xyz 0 2 3551 2987 0 0 0 0 0 0 0 13 LPoint4i::xyz 0

3920 2 xy 0 2 3538 2988 0 0 0 0 0 0 0 12 LPoint4i::xy 0

3921 4 rows 0 66 3539 3021 0 0 0 0 3016 0 0 15 LMatrix3f::rows 0

3922 4 cols 0 66 3539 3022 0 0 0 0 3016 0 0 15 LMatrix3f::cols 0

3923 4 rows 0 66 3552 3114 0 0 0 0 3108 0 0 15 LMatrix4f::rows 0

3924 4 cols 0 66 3552 3115 0 0 0 0 3108 0 0 15 LMatrix4f::cols 0

3925 4 rows 0 66 3541 3219 0 0 0 0 3214 0 0 15 LMatrix3d::rows 0

3926 4 cols 0 66 3541 3220 0 0 0 0 3214 0 0 15 LMatrix3d::cols 0

3927 4 rows 0 66 3556 3310 0 0 0 0 3304 0 0 15 LMatrix4d::rows 0

3928 4 cols 0 66 3556 3311 0 0 0 0 3304 0 0 15 LMatrix4d::cols 0

14
3929 8 get_rows 0 3016 3019 19 LMatrix3f::get_rows 0

3930 8 get_cols 0 3016 3020 19 LMatrix3f::get_cols 0

3931 9 get_col2s 0 3016 3024 20 LMatrix3f::get_col2s 0

3932 9 get_row2s 0 3016 3023 20 LMatrix3f::get_row2s 0

3933 8 get_rows 0 3108 3111 19 LMatrix4f::get_rows 0

3934 8 get_cols 0 3108 3112 19 LMatrix4f::get_cols 0

3935 9 get_row3s 0 3108 3113 20 LMatrix4f::get_row3s 0

3936 8 get_rows 0 3214 3217 19 LMatrix3d::get_rows 0

3937 8 get_cols 0 3214 3218 19 LMatrix3d::get_cols 0

3938 9 get_col2s 0 3214 3222 20 LMatrix3d::get_col2s 0

3939 9 get_row2s 0 3214 3221 20 LMatrix3d::get_row2s 0

3940 8 get_rows 0 3304 3307 19 LMatrix4d::get_rows 0

3941 8 get_cols 0 3304 3308 19 LMatrix4d::get_cols 0

3942 9 get_row3s 0 3304 3309 20 LMatrix4d::get_row3s 0

