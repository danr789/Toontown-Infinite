1565844200
3 3
9 libp3chan 4 8NZB 12 panda3d.core 
226
210 37 upcast_to_TypedWritableReferenceCount 0 12 436 48 AnimGroup::upcast_to_TypedWritableReferenceCount 0 1 11 52
upcast from AnimGroup to TypedWritableReferenceCount
84
TypedWritableReferenceCount *AnimGroup::upcast_to_TypedWritableReferenceCount(void);

211 21 downcast_to_AnimGroup 0 12 437 50 TypedWritableReferenceCount::downcast_to_AnimGroup 0 0 54
downcast from TypedWritableReferenceCount to AnimGroup
68
AnimGroup *TypedWritableReferenceCount::downcast_to_AnimGroup(void);

212 17 upcast_to_Namable 0 12 436 28 AnimGroup::upcast_to_Namable 0 1 12 32
upcast from AnimGroup to Namable
44
Namable *AnimGroup::upcast_to_Namable(void);

213 21 downcast_to_AnimGroup 0 12 438 30 Namable::downcast_to_AnimGroup 0 0 34
downcast from Namable to AnimGroup
48
AnimGroup *Namable::downcast_to_AnimGroup(void);

214 9 AnimGroup 0 4 436 20 AnimGroup::AnimGroup 0 2 1 2 607
// This is the normal AnimGroup constructor.

/**
 * The default constructor is protected: don't try to create an AnimGroup
 * without a parent.  To create an AnimChannel hierarchy, you must first
 * create an AnimBundle, and use that to create any subsequent children.
 */

/**
 * Creates a new AnimGroup, just like this one, without copying any children.
 * The new copy is added to the indicated parent.  Intended to be called by
 * make_copy() only.
 */

/**
 * Creates the AnimGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */
132
explicit AnimGroup::AnimGroup(AnimGroup *parent, std::string const &name);
inline AnimGroup::AnimGroup(AnimGroup const &) = default;

215 10 ~AnimGroup 0 6 436 21 AnimGroup::~AnimGroup 0 0 10
/**
 *
 */
36
virtual AnimGroup::~AnimGroup(void);

216 16 get_num_children 0 4 436 27 AnimGroup::get_num_children 0 1 3 58
/**
 * Returns the number of child nodes of the group.
 */
44
int AnimGroup::get_num_children(void) const;

217 9 get_child 0 4 436 20 AnimGroup::get_child 0 1 4 46
/**
 * Returns the nth child of the group.
 */
45
AnimGroup *AnimGroup::get_child(int n) const;

218 15 get_child_named 0 4 436 26 AnimGroup::get_child_named 0 1 5 250
/**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * AnimGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */
69
AnimGroup *AnimGroup::get_child_named(std::string const &name) const;

219 10 find_child 0 4 436 21 AnimGroup::find_child 0 1 6 210
/**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this AnimGroup; see also get_child_named().
 */
64
AnimGroup *AnimGroup::find_child(std::string const &name) const;

220 16 sort_descendants 0 4 436 27 AnimGroup::sort_descendants 0 1 7 262
/**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */
39
void AnimGroup::sort_descendants(void);

221 0 0 0 0 0 0 0 0
0

222 6 output 0 6 436 17 AnimGroup::output 0 1 8 54
/**
 * Writes a one-line description of the group.
 */
56
virtual void AnimGroup::output(std::ostream &out) const;

223 5 write 0 6 436 16 AnimGroup::write 0 1 9 78
/**
 * Writes a brief description of the group and all of its descendants.
 */
73
virtual void AnimGroup::write(std::ostream &out, int indent_level) const;

224 14 get_class_type 0 4 436 25 AnimGroup::get_class_type 0 1 10 0
50
static TypeHandle AnimGroup::get_class_type(void);

225 10 AnimBundle 0 4 440 22 AnimBundle::AnimBundle 0 2 13 14 207
/**
 *
 */

/**
 *
 */

/**
 * Creates a new AnimBundle, just like this one, without copying any children.
 * The new copy is added to the indicated parent.  Intended to be called by
 * make_copy() only.
 */
158
inline explicit AnimBundle::AnimBundle(std::string const &name, PN_stdfloat fps, int num_frames);
inline AnimBundle::AnimBundle(AnimBundle const &) = default;

226 11 copy_bundle 0 4 440 23 AnimBundle::copy_bundle 0 1 15 236
/**
 * Returns a full copy of the bundle and its entire tree of nested AnimGroups.
 * However, the actual data stored in the leaves--that is, animation tables,
 * such as those stored in an AnimChannelMatrixXfmTable--will be shared.
 */
60
PointerTo< AnimBundle > AnimBundle::copy_bundle(void) const;

227 19 get_base_frame_rate 0 4 440 31 AnimBundle::get_base_frame_rate 0 1 16 307
/**
 * Returns the ideal number of frames per second of the animation, when it is
 * running at normal speed.  This may not be the same as the actual playing
 * frame rate, as it might have been adjusted through set_play_rate() on the
 * AnimControl object.  See AnimControl::get_effective_frame_rate().
 */
58
inline double AnimBundle::get_base_frame_rate(void) const;

228 14 get_num_frames 0 4 440 26 AnimBundle::get_num_frames 0 1 17 109
/**
 * Returns the number of frames of animation, or 0 if the animation has no
 * fixed number of frames.
 */
50
inline int AnimBundle::get_num_frames(void) const;

229 14 get_class_type 0 4 440 26 AnimBundle::get_class_type 0 1 18 0
51
static TypeHandle AnimBundle::get_class_type(void);

230 11 ~AnimBundle 0 4 440 23 AnimBundle::~AnimBundle 0 0 0
30
AnimBundle::~AnimBundle(void);

231 14 AnimBundleNode 0 4 443 30 AnimBundleNode::AnimBundleNode 0 1 19 330
/**
 * The AnimBundle and its node should be constructed together.  Generally, the
 * derived classes of AnimBundleNode will automatically create a AnimBundle of
 * the appropriate type, and pass it up to this constructor.
 */

/**
 * For internal use only.
 */

/**
 * Use make_copy() or copy_subgraph() to copy one of these.
 */
92
inline explicit AnimBundleNode::AnimBundleNode(std::string const &name, AnimBundle *bundle);

232 10 get_bundle 0 4 443 26 AnimBundleNode::get_bundle 0 1 20 10
/**
 *
 */
58
inline AnimBundle *AnimBundleNode::get_bundle(void) const;

233 16 find_anim_bundle 0 4 443 32 AnimBundleNode::find_anim_bundle 0 1 21 205
/**
 * Recursively walks the scene graph beginning at the indicated node (which
 * need not be an AnimBundleNode), and returns the first AnimBundle found.
 * Returns NULL if no AnimBundle can be found.
 */
69
static AnimBundle *AnimBundleNode::find_anim_bundle(PandaNode *root);

234 14 get_class_type 0 4 443 30 AnimBundleNode::get_class_type 0 1 22 0
55
static TypeHandle AnimBundleNode::get_class_type(void);

235 15 ~AnimBundleNode 0 4 443 31 AnimBundleNode::~AnimBundleNode 0 0 0
38
AnimBundleNode::~AnimBundleNode(void);

236 37 upcast_to_TypedWritableReferenceCount 0 12 446 48 PartGroup::upcast_to_TypedWritableReferenceCount 0 1 41 52
upcast from PartGroup to TypedWritableReferenceCount
84
TypedWritableReferenceCount *PartGroup::upcast_to_TypedWritableReferenceCount(void);

237 21 downcast_to_PartGroup 0 12 437 50 TypedWritableReferenceCount::downcast_to_PartGroup 0 0 54
downcast from TypedWritableReferenceCount to PartGroup
68
PartGroup *TypedWritableReferenceCount::downcast_to_PartGroup(void);

238 17 upcast_to_Namable 0 12 446 28 PartGroup::upcast_to_Namable 0 1 42 32
upcast from PartGroup to Namable
44
Namable *PartGroup::upcast_to_Namable(void);

239 21 downcast_to_PartGroup 0 12 438 30 Namable::downcast_to_PartGroup 0 0 34
downcast from Namable to PartGroup
48
PartGroup *Namable::downcast_to_PartGroup(void);

240 9 PartGroup 0 4 446 20 PartGroup::PartGroup 0 1 23 501
// This is the normal PartGroup constructor.

/**
 * This constructor is only intended for interal use and for derived classes.
 * You should normally use the non-default constructor, below.
 */

/**
 * This constructor is only intended for interal use and for derived classes.
 * You should normally use the make_copy() interface to make copies..
 */

/**
 * Creates the PartGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */
74
explicit PartGroup::PartGroup(PartGroup *parent, std::string const &name);

241 10 ~PartGroup 0 6 446 21 PartGroup::~PartGroup 0 0 10
/**
 *
 */
36
virtual PartGroup::~PartGroup(void);

242 18 is_character_joint 0 6 446 29 PartGroup::is_character_joint 0 1 24 156
/**
 * Returns true if this part is a CharacterJoint, false otherwise.  This is a
 * tiny optimization over is_of_type(CharacterType::get_class_type()).
 */
55
virtual bool PartGroup::is_character_joint(void) const;

243 9 make_copy 0 6 446 20 PartGroup::make_copy 0 1 25 110
/**
 * Allocates and returns a new copy of the node.  Children are not copied, but
 * see copy_subgraph().
 */
52
virtual PartGroup *PartGroup::make_copy(void) const;

244 13 copy_subgraph 0 4 446 24 PartGroup::copy_subgraph 0 1 26 84
/**
 * Allocates and returns a new copy of this node and of all of its children.
 */
48
PartGroup *PartGroup::copy_subgraph(void) const;

245 16 get_num_children 0 4 446 27 PartGroup::get_num_children 0 1 27 58
/**
 * Returns the number of child nodes of the group.
 */
44
int PartGroup::get_num_children(void) const;

246 9 get_child 0 4 446 20 PartGroup::get_child 0 1 28 46
/**
 * Returns the nth child of the group.
 */
45
PartGroup *PartGroup::get_child(int n) const;

247 15 get_child_named 0 4 446 26 PartGroup::get_child_named 0 1 29 250
/**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * PartGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */
69
PartGroup *PartGroup::get_child_named(std::string const &name) const;

248 10 find_child 0 4 446 21 PartGroup::find_child 0 1 30 210
/**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this PartGroup; see also get_child_named().
 */
64
PartGroup *PartGroup::find_child(std::string const &name) const;

249 16 sort_descendants 0 4 446 27 PartGroup::sort_descendants 0 1 31 262
/**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */
39
void PartGroup::sort_descendants(void);

250 0 0 0 0 0 0 0 0
0

251 12 apply_freeze 0 4 446 23 PartGroup::apply_freeze 0 1 32 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
62
bool PartGroup::apply_freeze(TransformState const *transform);

252 19 apply_freeze_matrix 0 6 446 30 PartGroup::apply_freeze_matrix 0 1 33 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
112
virtual bool PartGroup::apply_freeze_matrix(LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale);

253 19 apply_freeze_scalar 0 6 446 30 PartGroup::apply_freeze_scalar 0 1 34 287
/**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */
63
virtual bool PartGroup::apply_freeze_scalar(PN_stdfloat value);

254 13 apply_control 0 6 446 24 PartGroup::apply_control 0 1 35 311
/**
 * Specifies a node to influence this particular joint so that it will always
 * hold the node's transform.  Returns true if this is a joint that can be so
 * controlled, false otherwise.
 *
 * This is normally only called internally by PartBundle::control_joint(), but
 * you may also call it directly.
 */
55
virtual bool PartGroup::apply_control(PandaNode *node);

255 20 clear_forced_channel 0 6 446 31 PartGroup::clear_forced_channel 0 1 36 261
/**
 * Undoes the effect of a previous call to apply_freeze() or apply_control().
 * Returns true if the joint was modified, false otherwise.
 *
 * This is normally only called internally by PartBundle::release_joint(), but
 * you may also call it directly.
 */
51
virtual bool PartGroup::clear_forced_channel(void);

256 18 get_forced_channel 0 6 446 29 PartGroup::get_forced_channel 0 1 37 181
/**
 * Returns the AnimChannelBase that has been forced to this joint by a
 * previous call to apply_freeze() or apply_control(), or NULL if no such
 * channel has been applied.
 */
67
virtual AnimChannelBase *PartGroup::get_forced_channel(void) const;

257 5 write 0 6 446 16 PartGroup::write 0 1 38 78
/**
 * Writes a brief description of the group and all of its descendants.
 */
73
virtual void PartGroup::write(std::ostream &out, int indent_level) const;

258 16 write_with_value 0 6 446 27 PartGroup::write_with_value 0 1 39 117
/**
 * Writes a brief description of the group, showing its current value, and
 * that of all of its descendants.
 */
84
virtual void PartGroup::write_with_value(std::ostream &out, int indent_level) const;

259 14 get_class_type 0 4 446 25 PartGroup::get_class_type 0 1 40 0
50
static TypeHandle PartGroup::get_class_type(void);

260 29 upcast_to_TypedReferenceCount 0 12 449 42 AnimControl::upcast_to_TypedReferenceCount 0 1 56 46
upcast from AnimControl to TypedReferenceCount
70
TypedReferenceCount *AnimControl::upcast_to_TypedReferenceCount(void);

261 23 downcast_to_AnimControl 0 12 450 44 TypedReferenceCount::downcast_to_AnimControl 0 0 48
downcast from TypedReferenceCount to AnimControl
64
AnimControl *TypedReferenceCount::downcast_to_AnimControl(void);

262 23 upcast_to_AnimInterface 0 12 449 36 AnimControl::upcast_to_AnimInterface 0 1 57 40
upcast from AnimControl to AnimInterface
58
AnimInterface *AnimControl::upcast_to_AnimInterface(void);

263 23 downcast_to_AnimControl 0 12 451 38 AnimInterface::downcast_to_AnimControl 0 0 42
downcast from AnimInterface to AnimControl
58
AnimControl *AnimInterface::downcast_to_AnimControl(void);

264 17 upcast_to_Namable 0 12 449 30 AnimControl::upcast_to_Namable 0 1 58 34
upcast from AnimControl to Namable
46
Namable *AnimControl::upcast_to_Namable(void);

265 23 downcast_to_AnimControl 0 12 438 32 Namable::downcast_to_AnimControl 0 0 36
downcast from Namable to AnimControl
52
AnimControl *Namable::downcast_to_AnimControl(void);

266 12 ~AnimControl 0 6 449 25 AnimControl::~AnimControl 0 0 10
/**
 *
 */
40
virtual AnimControl::~AnimControl(void);

267 10 is_pending 0 4 449 23 AnimControl::is_pending 0 1 43 286
/**
 * Returns true if the AnimControl is being bound asynchronously, and has not
 * yet finished.  If this is true, the AnimControl's interface is still
 * available and will be perfectly useful (though get_anim() might return
 * NULL), but nothing visible will happen immediately.
 */
48
inline bool AnimControl::is_pending(void) const;

268 12 wait_pending 0 4 449 25 AnimControl::wait_pending 0 1 44 102
/**
 * Blocks the current thread until the AnimControl has finished loading and is
 * fully bound.
 */
37
void AnimControl::wait_pending(void);

269 8 has_anim 0 4 449 21 AnimControl::has_anim 0 1 45 154
/**
 * Returns true if the AnimControl was successfully loaded, or false if there
 * was a problem.  This may return false while is_pending() is true.
 */
46
inline bool AnimControl::has_anim(void) const;

270 22 set_pending_done_event 0 4 449 35 AnimControl::set_pending_done_event 0 1 46 205
/**
 * Specifies an event name that will be thrown when the AnimControl is
 * finished binding asynchronously.  If the AnimControl has already finished
 * binding, the event will be thrown immediately.
 */
72
void AnimControl::set_pending_done_event(std::string const &done_event);

271 22 get_pending_done_event 0 4 449 35 AnimControl::get_pending_done_event 0 1 47 113
/**
 * Returns the event name that will be thrown when the AnimControl is finished
 * binding asynchronously.
 */
60
std::string AnimControl::get_pending_done_event(void) const;

272 8 get_part 0 4 449 21 AnimControl::get_part 0 1 48 65
/**
 * Returns the PartBundle bound in with this AnimControl.
 */
46
PartBundle *AnimControl::get_part(void) const;

273 8 get_anim 0 4 449 21 AnimControl::get_anim 0 1 49 65
/**
 * Returns the AnimBundle bound in with this AnimControl.
 */
53
inline AnimBundle *AnimControl::get_anim(void) const;

274 17 get_channel_index 0 4 449 30 AnimControl::get_channel_index 0 1 50 358
/**
 * Returns the particular channel index associated with this AnimControl.
 * This channel index is the slot on which each AnimGroup is bound to its
 * associated PartGroup, for each joint in the animation.
 *
 * It will be true that
 * get_part()->find_child("n")->get_bound(get_channel_index()) ==
 * get_anim()->find_child("n"), for each joint "n".
 */
54
inline int AnimControl::get_channel_index(void) const;

275 16 get_bound_joints 0 4 449 29 AnimControl::get_bound_joints 0 1 51 369
/**
 * Returns the subset of joints controlled by this AnimControl.  Most of the
 * time, this will be BitArray::all_on(), for a normal full-body animation.
 * For a subset animation, however, this will be just a subset of those bits,
 * corresponding to the set of joints and sliders actually bound (as
 * enumerated by bind_hierarchy() in depth-first LIFO order).
 */
65
inline BitArray const &AnimControl::get_bound_joints(void) const;

276 14 set_anim_model 0 4 449 27 AnimControl::set_anim_model 0 1 52 515
/**
 * Associates the indicated PandaNode with the AnimControl.  By convention,
 * this node represents the root node of the model file that corresponds to
 * this AnimControl's animation file, though nothing in this code makes this
 * assumption or indeed does anything with this node.
 *
 * The purpose of this is simply to allow the AnimControl to keep a reference
 * count on the ModelRoot node that generated it, so that the model will not
 * disappear from the model pool until it is no longer referenced.
 */
58
inline void AnimControl::set_anim_model(PandaNode *model);

277 14 get_anim_model 0 4 449 27 AnimControl::get_anim_model 0 1 53 81
/**
 * Retrieves the pointer set via set_anim_model().  See set_anim_model().
 */
58
inline PandaNode *AnimControl::get_anim_model(void) const;

278 6 output 0 6 449 19 AnimControl::output 0 1 54 10
/**
 *
 */
58
virtual void AnimControl::output(std::ostream &out) const;

279 14 get_class_type 0 4 449 27 AnimControl::get_class_type 0 1 55 0
52
static TypeHandle AnimControl::get_class_type(void);

280 8 get_type 0 6 452 25 AnimChannelBase::get_type 0 1 59 0
57
virtual TypeHandle AnimChannelBase::get_type(void) const;

281 14 get_class_type 0 4 452 31 AnimChannelBase::get_class_type 0 1 60 0
56
static TypeHandle AnimChannelBase::get_class_type(void);

282 16 ~AnimChannelBase 0 4 452 33 AnimChannelBase::~AnimChannelBase 0 0 0
40
AnimChannelBase::~AnimChannelBase(void);

283 9 get_value 0 6 453 44 AnimChannel< ACMatrixSwitchType >::get_value 0 1 61 0
90
virtual void AnimChannel< ACMatrixSwitchType >::get_value(int frame, LMatrix4 &value) = 0;

284 24 get_value_no_scale_shear 0 6 453 59 AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear 0 1 62 72
// These transform-component methods only have meaning for matrix types.
101
virtual void AnimChannel< ACMatrixSwitchType >::get_value_no_scale_shear(int frame, LMatrix4 &value);

285 9 get_scale 0 6 453 44 AnimChannel< ACMatrixSwitchType >::get_scale 0 1 63 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_scale(int frame, LVecBase3 &scale);

286 7 get_hpr 0 6 453 42 AnimChannel< ACMatrixSwitchType >::get_hpr 0 1 64 0
83
virtual void AnimChannel< ACMatrixSwitchType >::get_hpr(int frame, LVecBase3 &hpr);

287 8 get_quat 0 6 453 43 AnimChannel< ACMatrixSwitchType >::get_quat 0 1 65 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_quat(int frame, LQuaternion &quat);

288 7 get_pos 0 6 453 42 AnimChannel< ACMatrixSwitchType >::get_pos 0 1 66 0
83
virtual void AnimChannel< ACMatrixSwitchType >::get_pos(int frame, LVecBase3 &pos);

289 9 get_shear 0 6 453 44 AnimChannel< ACMatrixSwitchType >::get_shear 0 1 67 0
87
virtual void AnimChannel< ACMatrixSwitchType >::get_shear(int frame, LVecBase3 &shear);

290 14 get_value_type 0 6 453 49 AnimChannel< ACMatrixSwitchType >::get_value_type 0 1 68 0
81
virtual TypeHandle AnimChannel< ACMatrixSwitchType >::get_value_type(void) const;

291 14 get_class_type 0 4 453 49 AnimChannel< ACMatrixSwitchType >::get_class_type 0 1 69 0
74
static TypeHandle AnimChannel< ACMatrixSwitchType >::get_class_type(void);

292 9 get_value 0 6 457 44 AnimChannel< ACScalarSwitchType >::get_value 0 0 0
93
virtual void AnimChannel< ACScalarSwitchType >::get_value(int frame, PN_stdfloat &value) = 0;

293 24 get_value_no_scale_shear 0 6 457 59 AnimChannel< ACScalarSwitchType >::get_value_no_scale_shear 0 0 72
// These transform-component methods only have meaning for matrix types.
104
virtual void AnimChannel< ACScalarSwitchType >::get_value_no_scale_shear(int frame, PN_stdfloat &value);

294 9 get_scale 0 6 457 44 AnimChannel< ACScalarSwitchType >::get_scale 0 1 70 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_scale(int frame, LVecBase3 &scale);

295 7 get_hpr 0 6 457 42 AnimChannel< ACScalarSwitchType >::get_hpr 0 1 71 0
83
virtual void AnimChannel< ACScalarSwitchType >::get_hpr(int frame, LVecBase3 &hpr);

296 8 get_quat 0 6 457 43 AnimChannel< ACScalarSwitchType >::get_quat 0 1 72 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_quat(int frame, LQuaternion &quat);

297 7 get_pos 0 6 457 42 AnimChannel< ACScalarSwitchType >::get_pos 0 1 73 0
83
virtual void AnimChannel< ACScalarSwitchType >::get_pos(int frame, LVecBase3 &pos);

298 9 get_shear 0 6 457 44 AnimChannel< ACScalarSwitchType >::get_shear 0 1 74 0
87
virtual void AnimChannel< ACScalarSwitchType >::get_shear(int frame, LVecBase3 &shear);

299 14 get_value_type 0 6 457 49 AnimChannel< ACScalarSwitchType >::get_value_type 0 1 75 0
81
virtual TypeHandle AnimChannel< ACScalarSwitchType >::get_value_type(void) const;

300 14 get_class_type 0 4 457 49 AnimChannel< ACScalarSwitchType >::get_class_type 0 1 76 0
74
static TypeHandle AnimChannel< ACScalarSwitchType >::get_class_type(void);

301 9 set_value 0 4 459 35 AnimChannelMatrixDynamic::set_value 0 2 77 78 153
/**
 * Explicitly sets the matrix value.
 */

/**
 * Explicitly sets the matrix value, using the indicated TransformState object
 * as a convenience.
 */
135
void AnimChannelMatrixDynamic::set_value(LMatrix4 const &value);
void AnimChannelMatrixDynamic::set_value(TransformState const *value);

302 14 set_value_node 0 4 459 40 AnimChannelMatrixDynamic::set_value_node 0 1 79 124
/**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */
63
void AnimChannelMatrixDynamic::set_value_node(PandaNode *node);

303 19 get_value_transform 0 4 459 45 AnimChannelMatrixDynamic::get_value_transform 0 1 80 93
/**
 * Returns the explicit TransformState value that was set via set_value(), if
 * any.
 */
87
inline TransformState const *AnimChannelMatrixDynamic::get_value_transform(void) const;

304 14 get_value_node 0 4 459 40 AnimChannelMatrixDynamic::get_value_node 0 1 81 70
/**
 * Returns the node that was set via set_value_node(), if any.
 */
71
inline PandaNode *AnimChannelMatrixDynamic::get_value_node(void) const;

305 14 get_class_type 0 4 459 40 AnimChannelMatrixDynamic::get_class_type 0 1 82 0
65
static TypeHandle AnimChannelMatrixDynamic::get_class_type(void);

306 25 ~AnimChannelMatrixDynamic 0 4 459 51 AnimChannelMatrixDynamic::~AnimChannelMatrixDynamic 0 0 0
58
AnimChannelMatrixDynamic::~AnimChannelMatrixDynamic(void);

307 25 AnimChannelMatrixXfmTable 0 4 461 52 AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable 0 1 83 248
/**
 * Used only for bam loader.
 */

/**
 * Creates a new AnimChannelMatrixXfmTable, just like this one, without
 * copying any children.  The new copy is added to the indicated parent.
 * Intended to be called by make_copy() only.
 */

/**
 *
 */
106
explicit AnimChannelMatrixXfmTable::AnimChannelMatrixXfmTable(AnimGroup *parent, std::string const &name);

308 11 is_valid_id 0 4 461 38 AnimChannelMatrixXfmTable::is_valid_id 0 1 84 80
/**
 * Returns true if the given letter is one of the nine valid table id's.
 */
73
static inline bool AnimChannelMatrixXfmTable::is_valid_id(char table_id);

309 9 set_table 0 4 461 36 AnimChannelMatrixXfmTable::set_table 0 1 85 255
/**
 * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,
 * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',
 * for translation.  The new table must have either zero, one, or
 * get_num_frames() frames.
 */
85
void AnimChannelMatrixXfmTable::set_table(char table_id, CPTA_stdfloat const &table);

310 9 get_table 0 4 461 36 AnimChannelMatrixXfmTable::get_table 0 1 86 103
/**
 * Returns a pointer to the indicated subtable's data, if it exists, or NULL
 * if it does not.
 */
79
inline CPTA_stdfloat AnimChannelMatrixXfmTable::get_table(char table_id) const;

311 16 clear_all_tables 0 4 461 43 AnimChannelMatrixXfmTable::clear_all_tables 0 1 87 90
/**
 * Removes all the tables from the channel, and resets it to its initial
 * state.
 */
55
void AnimChannelMatrixXfmTable::clear_all_tables(void);

312 9 has_table 0 4 461 36 AnimChannelMatrixXfmTable::has_table 0 1 88 68
/**
 * Returns true if the indicated subtable has been assigned.
 */
70
inline bool AnimChannelMatrixXfmTable::has_table(char table_id) const;

313 11 clear_table 0 4 461 38 AnimChannelMatrixXfmTable::clear_table 0 1 89 59
/**
 * Removes the indicated table from the definition.
 */
66
inline void AnimChannelMatrixXfmTable::clear_table(char table_id);

314 0 0 0 0 0 0 0 0
0

315 14 get_class_type 0 4 461 41 AnimChannelMatrixXfmTable::get_class_type 0 1 90 0
66
static TypeHandle AnimChannelMatrixXfmTable::get_class_type(void);

316 9 set_value 0 4 465 35 AnimChannelScalarDynamic::set_value 0 1 91 98
/**
 * Explicitly sets the value.  This will remove any node assigned via
 * set_value_node().
 */
60
void AnimChannelScalarDynamic::set_value(PN_stdfloat value);

317 14 set_value_node 0 4 465 40 AnimChannelScalarDynamic::set_value_node 0 1 92 178
/**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.  This will override the values set by
 * set_value().
 */
63
void AnimChannelScalarDynamic::set_value_node(PandaNode *node);

318 9 get_value 0 4 465 35 AnimChannelScalarDynamic::get_value 0 0 235
/**
 * Gets the value of the channel.  This will return the value explicitly
 * specified by set_value() unless a value node was specified using
 * set_value_node().
 */

/**
 * Gets the value of the channel at the indicated frame.
 */
67
inline PN_stdfloat AnimChannelScalarDynamic::get_value(void) const;

319 14 get_value_node 0 4 465 40 AnimChannelScalarDynamic::get_value_node 0 0 70
/**
 * Returns the node that was set via set_value_node(), if any.
 */
71
inline PandaNode *AnimChannelScalarDynamic::get_value_node(void) const;

320 14 get_class_type 0 4 465 40 AnimChannelScalarDynamic::get_class_type 0 1 93 0
65
static TypeHandle AnimChannelScalarDynamic::get_class_type(void);

321 25 ~AnimChannelScalarDynamic 0 4 465 51 AnimChannelScalarDynamic::~AnimChannelScalarDynamic 0 0 0
58
AnimChannelScalarDynamic::~AnimChannelScalarDynamic(void);

322 9 set_table 0 4 468 33 AnimChannelScalarTable::set_table 0 1 94 34
/**
 * Assigns the data table.
 */
67
void AnimChannelScalarTable::set_table(CPTA_stdfloat const &table);

323 9 get_table 0 4 468 33 AnimChannelScalarTable::get_table 0 1 95 90
/**
 * Returns a pointer to the table's data, if it exists, or NULL if it does
 * not.
 */
67
inline CPTA_stdfloat AnimChannelScalarTable::get_table(void) const;

324 9 has_table 0 4 468 33 AnimChannelScalarTable::has_table 0 1 96 60
/**
 * Returns true if the data table has been assigned.
 */
58
inline bool AnimChannelScalarTable::has_table(void) const;

325 11 clear_table 0 4 468 35 AnimChannelScalarTable::clear_table 0 1 97 34
/**
 * Empties the data table.
 */
54
inline void AnimChannelScalarTable::clear_table(void);

326 14 get_class_type 0 4 468 38 AnimChannelScalarTable::get_class_type 0 1 98 0
63
static TypeHandle AnimChannelScalarTable::get_class_type(void);

327 23 ~AnimChannelScalarTable 0 4 468 47 AnimChannelScalarTable::~AnimChannelScalarTable 0 0 0
54
AnimChannelScalarTable::~AnimChannelScalarTable(void);

328 21 AnimControlCollection 0 4 469 44 AnimControlCollection::AnimControlCollection 0 2 99 100 117
/**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */
145
AnimControlCollection::AnimControlCollection(void);
inline AnimControlCollection::AnimControlCollection(AnimControlCollection const &) = default;

329 22 ~AnimControlCollection 0 4 469 45 AnimControlCollection::~AnimControlCollection 0 0 10
/**
 *
 */
52
AnimControlCollection::~AnimControlCollection(void);

330 10 store_anim 0 4 469 33 AnimControlCollection::store_anim 0 1 101 247
/**
 * Associates the given AnimControl with this collection under the given name.
 * The AnimControl will remain associated until a new AnimControl is
 * associated with the same name later, or until unbind_anim() is called with
 * this name.
 */
86
void AnimControlCollection::store_anim(AnimControl *control, std::string const &name);

331 9 find_anim 0 4 469 32 AnimControlCollection::find_anim 0 1 102 117
/**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */
77
AnimControl *AnimControlCollection::find_anim(std::string const &name) const;

332 11 unbind_anim 0 4 469 34 AnimControlCollection::unbind_anim 0 1 103 184
/**
 * Removes the AnimControl associated with the given name, if any.  Returns
 * true if an AnimControl was removed, false if there was no AnimControl with
 * the indicated name.
 */
65
bool AnimControlCollection::unbind_anim(std::string const &name);

333 13 get_num_anims 0 4 469 36 AnimControlCollection::get_num_anims 0 1 104 78
/**
 * Returns the number of AnimControls associated with this collection.
 */
53
int AnimControlCollection::get_num_anims(void) const;

334 8 get_anim 0 4 469 31 AnimControlCollection::get_anim 0 1 105 71
/**
 * Returns the nth AnimControl associated with this collection.
 */
58
AnimControl *AnimControlCollection::get_anim(int n) const;

335 13 get_anim_name 0 4 469 36 AnimControlCollection::get_anim_name 0 1 106 83
/**
 * Returns the name of the nth AnimControl associated with this collection.
 */
62
std::string AnimControlCollection::get_anim_name(int n) const;

336 11 clear_anims 0 4 469 34 AnimControlCollection::clear_anims 0 1 107 56
/**
 * Disassociates all anims from this collection.
 */
46
void AnimControlCollection::clear_anims(void);

337 4 play 0 4 469 27 AnimControlCollection::play 0 2 108 109 94
/**
 * Starts the named animation playing.
 */

/**
 * Starts the named animation playing.
 */
165
inline bool AnimControlCollection::play(std::string const &anim_name);
inline bool AnimControlCollection::play(std::string const &anim_name, double from, double to);

338 4 loop 0 4 469 27 AnimControlCollection::loop 0 2 110 111 94
/**
 * Starts the named animation looping.
 */

/**
 * Starts the named animation looping.
 */
193
inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart);
inline bool AnimControlCollection::loop(std::string const &anim_name, bool restart, double from, double to);

339 4 stop 0 4 469 27 AnimControlCollection::stop 0 1 112 37
/**
 * Stops the named animation.
 */
70
inline bool AnimControlCollection::stop(std::string const &anim_name);

340 4 pose 0 4 469 27 AnimControlCollection::pose 0 1 113 61
/**
 * Sets to a particular frame in the named animation.
 */
84
inline bool AnimControlCollection::pose(std::string const &anim_name, double frame);

341 8 play_all 0 4 469 31 AnimControlCollection::play_all 0 2 114 115 134
// These functions operate on all anims at once.

/**
 * Starts all animations playing.
 */

/**
 * Starts all animations playing.
 */
105
void AnimControlCollection::play_all(void);
void AnimControlCollection::play_all(double from, double to);

342 8 loop_all 0 4 469 31 AnimControlCollection::loop_all 0 2 116 117 84
/**
 * Starts all animations looping.
 */

/**
 * Starts all animations looping.
 */
127
void AnimControlCollection::loop_all(bool restart);
void AnimControlCollection::loop_all(bool restart, double from, double to);

343 8 stop_all 0 4 469 31 AnimControlCollection::stop_all 0 1 118 127
/**
 * Stops all currently playing animations.  Returns true if any animations
 * were stopped, false if none were playing.
 */
43
bool AnimControlCollection::stop_all(void);

344 8 pose_all 0 4 469 31 AnimControlCollection::pose_all 0 1 119 54
/**
 * Sets all animations to the indicated frame.
 */
51
void AnimControlCollection::pose_all(double frame);

345 9 get_frame 0 4 469 32 AnimControlCollection::get_frame 0 2 120 121 168
/**
 * Returns the current frame in the named animation, or 0 if the animation is
 * not found.
 */

/**
 * Returns the current frame in the last-started animation.
 */
137
inline int AnimControlCollection::get_frame(std::string const &anim_name) const;
inline int AnimControlCollection::get_frame(void) const;

346 14 get_num_frames 0 4 469 37 AnimControlCollection::get_num_frames 0 2 122 123 186
/**
 * Returns the total number of frames in the named animation, or 0 if the
 * animation is not found.
 */

/**
 * Returns the total number of frames in the last-started animation.
 */
147
inline int AnimControlCollection::get_num_frames(std::string const &anim_name) const;
inline int AnimControlCollection::get_num_frames(void) const;

347 10 is_playing 0 4 469 33 AnimControlCollection::is_playing 0 2 124 125 182
/**
 * Returns true if the named animation is currently playing, false otherwise.
 */

/**
 * Returns true if the last-started animation is currently playing, false
 * otherwise.
 */
141
inline bool AnimControlCollection::is_playing(std::string const &anim_name) const;
inline bool AnimControlCollection::is_playing(void) const;

348 18 which_anim_playing 0 4 469 41 AnimControlCollection::which_anim_playing 0 1 126 183
/**
 * Returns the name of the bound AnimControl currently playing, if any.  If
 * more than one AnimControl is currently playing, returns all of the names
 * separated by spaces.
 */
66
std::string AnimControlCollection::which_anim_playing(void) const;

349 6 output 0 4 469 29 AnimControlCollection::output 0 1 127 10
/**
 *
 */
60
void AnimControlCollection::output(std::ostream &out) const;

350 5 write 0 4 469 28 AnimControlCollection::write 0 1 128 10
/**
 *
 */
59
void AnimControlCollection::write(std::ostream &out) const;

351 16 AnimPreloadTable 0 4 470 34 AnimPreloadTable::AnimPreloadTable 0 1 129 10
/**
 *
 */
41
AnimPreloadTable::AnimPreloadTable(void);

352 13 get_num_anims 0 4 470 31 AnimPreloadTable::get_num_anims 0 1 130 64
/**
 * Returns the number of animation records in the table.
 */
48
int AnimPreloadTable::get_num_anims(void) const;

353 9 find_anim 0 4 470 27 AnimPreloadTable::find_anim 0 1 131 321
/**
 * Returns the index number in the table of the animation record with the
 * indicated name, or -1 if the name is not present.  By convention, the
 * basename is the filename of the egg or bam file, without the directory part
 * and without the extension.  That is, it is
 * Filename::get_basename_wo_extension().
 */
67
int AnimPreloadTable::find_anim(std::string const &basename) const;

354 12 get_basename 0 4 470 30 AnimPreloadTable::get_basename 0 1 132 86
/**
 * Returns the basename stored for the nth animation record.  See find_anim().
 */
63
inline std::string AnimPreloadTable::get_basename(int n) const;

355 19 get_base_frame_rate 0 4 470 37 AnimPreloadTable::get_base_frame_rate 0 1 133 70
/**
 * Returns the frame rate stored for the nth animation record.
 */
70
inline PN_stdfloat AnimPreloadTable::get_base_frame_rate(int n) const;

356 14 get_num_frames 0 4 470 32 AnimPreloadTable::get_num_frames 0 1 134 76
/**
 * Returns the number of frames stored for the nth animation record.
 */
57
inline int AnimPreloadTable::get_num_frames(int n) const;

357 11 clear_anims 0 4 470 29 AnimPreloadTable::clear_anims 0 1 135 56
/**
 * Removes all animation records from the table.
 */
41
void AnimPreloadTable::clear_anims(void);

358 11 remove_anim 0 4 470 29 AnimPreloadTable::remove_anim 0 1 136 113
/**
 * Removes the nth animation records from the table.  This renumbers indexes
 * for following animations.
 */
42
void AnimPreloadTable::remove_anim(int n);

359 8 add_anim 0 4 470 26 AnimPreloadTable::add_anim 0 1 137 227
/**
 * Adds a new animation record to the table.  If there is already a record of
 * this name, no operation is performed (the original record is unchanged).
 * See find_anim().  This will invalidate existing index numbers.
 */
106
void AnimPreloadTable::add_anim(std::string const &basename, PN_stdfloat base_frame_rate, int num_frames);

360 14 add_anims_from 0 4 470 32 AnimPreloadTable::add_anims_from 0 1 138 160
/**
 * Copies the animation records from the other table into this one.  If a
 * given record name exists in both tables, the record in this one supercedes.
 */
69
void AnimPreloadTable::add_anims_from(AnimPreloadTable const *other);

361 6 output 0 6 470 24 AnimPreloadTable::output 0 1 139 10
/**
 *
 */
63
virtual void AnimPreloadTable::output(std::ostream &out) const;

362 5 write 0 6 470 23 AnimPreloadTable::write 0 1 140 10
/**
 *
 */
80
virtual void AnimPreloadTable::write(std::ostream &out, int indent_level) const;

363 14 get_class_type 0 4 470 32 AnimPreloadTable::get_class_type 0 1 141 0
57
static TypeHandle AnimPreloadTable::get_class_type(void);

364 9 auto_bind 0 1 0 9 auto_bind 0 1 209 0
101
void auto_bind(PandaNode *root_node, AnimControlCollection &controls, int hierarchy_match_flags = 0);

365 10 PartSubset 0 4 472 22 PartSubset::PartSubset 0 2 142 143 22
/**
 *
 */

/**
 *
 */
77
PartSubset::PartSubset(void);
PartSubset::PartSubset(PartSubset const &copy);

366 10 operator = 0 4 472 22 PartSubset::operator = 0 1 144 0
52
void PartSubset::operator =(PartSubset const &copy);

367 17 add_include_joint 0 4 472 29 PartSubset::add_include_joint 0 1 145 342
/**
 * Adds the named joint to the list of joints that will be explicitly included
 * in the subset.  Any joint at or below a named node will be included in the
 * subset (unless a lower node is also listed in the exclude list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */
60
void PartSubset::add_include_joint(GlobPattern const &name);

368 17 add_exclude_joint 0 4 472 29 PartSubset::add_exclude_joint 0 1 146 352
/**
 * Adds the named joint to the list of joints that will be explicitly
 * exlcluded from the subset.  Any joint at or below a named node will not be
 * included in the subset (unless a lower node is also listed in the include
 * list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */
60
void PartSubset::add_exclude_joint(GlobPattern const &name);

369 6 append 0 4 472 18 PartSubset::append 0 1 147 98
/**
 * Appends the include and exclude list from the other object onto this
 * object's lists.
 */
49
void PartSubset::append(PartSubset const &other);

370 6 output 0 4 472 18 PartSubset::output 0 1 148 10
/**
 *
 */
49
void PartSubset::output(std::ostream &out) const;

371 16 is_include_empty 0 4 472 28 PartSubset::is_include_empty 0 1 149 147
/**
 * Returns true if the include list is completely empty, false otherwise.  If
 * it is empty, it is the same thing as including all joints.
 */
46
bool PartSubset::is_include_empty(void) const;

372 15 matches_include 0 4 472 27 PartSubset::matches_include 0 1 150 101
/**
 * Returns true if the indicated name matches a name on the include list,
 * false otherwise.
 */
70
bool PartSubset::matches_include(std::string const &joint_name) const;

373 15 matches_exclude 0 4 472 27 PartSubset::matches_exclude 0 1 151 101
/**
 * Returns true if the indicated name matches a name on the exclude list,
 * false otherwise.
 */
70
bool PartSubset::matches_exclude(std::string const &joint_name) const;

374 11 ~PartSubset 0 4 472 23 PartSubset::~PartSubset 0 0 0
30
PartSubset::~PartSubset(void);

375 15 BindAnimRequest 0 4 473 32 BindAnimRequest::BindAnimRequest 0 2 152 153 10
/**
 *
 */
290
explicit BindAnimRequest::BindAnimRequest(std::string const &name, Filename const &filename, LoaderOptions const &options, Loader *loader, AnimControl *control, int hierarchy_match_flags, PartSubset const &subset);
inline BindAnimRequest::BindAnimRequest(BindAnimRequest const &) = default;

376 14 get_class_type 0 4 473 31 BindAnimRequest::get_class_type 0 1 154 0
56
static TypeHandle BindAnimRequest::get_class_type(void);

377 16 ~BindAnimRequest 0 4 473 33 BindAnimRequest::~BindAnimRequest 0 0 0
40
BindAnimRequest::~BindAnimRequest(void);

378 10 PartBundle 0 4 475 22 PartBundle::PartBundle 0 1 155 220
/**
 * Normally, you'd use make_copy() or copy_subgraph() to make a copy of this.
 */

/**
 * Normally, a PartBundle constructor should not be called directly--it will
 * get created when a PartBundleNode is created.
 */
62
explicit PartBundle::PartBundle(std::string const &name = "");

379 16 get_anim_preload 0 4 475 28 PartBundle::get_anim_preload 0 1 156 181
/**
 * Returns the AnimPreloadTable associated with the PartBundle.  This table,
 * if present, can be used for the benefit of load_bind_anim() to allow
 * asynchronous binding.
 */
83
inline ConstPointerTo< AnimPreloadTable > PartBundle::get_anim_preload(void) const;

380 19 modify_anim_preload 0 4 475 31 PartBundle::modify_anim_preload 0 1 157 106
/**
 * Returns a modifiable pointer to the AnimPreloadTable associated with the
 * PartBundle, if any.
 */
75
inline PointerTo< AnimPreloadTable > PartBundle::modify_anim_preload(void);

381 16 set_anim_preload 0 4 475 28 PartBundle::set_anim_preload 0 1 158 72
/**
 * Replaces the AnimPreloadTable associated with the PartBundle.
 */
66
inline void PartBundle::set_anim_preload(AnimPreloadTable *table);

382 18 clear_anim_preload 0 4 475 30 PartBundle::clear_anim_preload 0 1 159 71
/**
 * Removes any AnimPreloadTable associated with the PartBundle.
 */
49
inline void PartBundle::clear_anim_preload(void);

383 19 merge_anim_preloads 0 4 475 31 PartBundle::merge_anim_preloads 0 1 160 85
/**
 * Copies the contents of the other PartBundle's preload table into this one.
 */
62
void PartBundle::merge_anim_preloads(PartBundle const *other);

384 14 set_blend_type 0 4 475 26 PartBundle::set_blend_type 0 1 161 270
/**
 * Defines the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 *
 * See partBundle.h for a description of the meaning of each of the BlendType
 * values.
 */
65
inline void PartBundle::set_blend_type(PartBundle::BlendType bt);

385 14 get_blend_type 0 4 475 26 PartBundle::get_blend_type 0 1 162 178
/**
 * Returns the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 */
68
inline PartBundle::BlendType PartBundle::get_blend_type(void) const;

386 19 set_anim_blend_flag 0 4 475 31 PartBundle::set_anim_blend_flag 0 1 163 581
/**
 * Defines the way the character responds to multiple calls to
 * set_control_effect()).  By default, this flag is set false, which disallows
 * multiple animations.  When this flag is false, it is not necessary to
 * explicitly set the control_effect when starting an animation; starting the
 * animation will implicitly remove the control_effect from the previous
 * animation and set it on the current one.
 *
 * However, if this flag is set true, the control_effect must be explicitly
 * set via set_control_effect() whenever an animation is to affect the
 * character.
 */
59
void PartBundle::set_anim_blend_flag(bool anim_blend_flag);

387 19 get_anim_blend_flag 0 4 475 31 PartBundle::get_anim_blend_flag 0 1 164 136
/**
 * Returns whether the character allows multiple different animations to be
 * bound simultaneously.  See set_anim_blend_flag().
 */
56
inline bool PartBundle::get_anim_blend_flag(void) const;

388 20 set_frame_blend_flag 0 4 475 32 PartBundle::set_frame_blend_flag 0 1 165 775
/**
 * Specifies whether the character interpolates (blends) between two
 * sequential frames of an active animation, showing a smooth intra-frame
 * motion, or whether it holds each frame until the next frame is ready,
 * showing precisely the specified animation.
 *
 * When this value is false, the character holds each frame until the next is
 * ready.  When this is true, the character will interpolate between two
 * consecutive frames of animation for each frame the animation is onscreen,
 * according to the amount of time elapsed between the frames.
 *
 * The default value of this flag is determined by the interpolate-frames
 * Config.prc variable.
 *
 * Use set_blend_type() to change the algorithm that the character uses to
 * interpolate matrix positions.
 */
68
inline void PartBundle::set_frame_blend_flag(bool frame_blend_flag);

389 20 get_frame_blend_flag 0 4 475 32 PartBundle::get_frame_blend_flag 0 1 166 205
/**
 * Returns whether the character interpolates (blends) between two sequential
 * animation frames, or whether it holds the current frame until the next one
 * is ready.  See set_frame_blend_flag().
 */
57
inline bool PartBundle::get_frame_blend_flag(void) const;

390 14 set_root_xform 0 4 475 26 PartBundle::set_root_xform 0 1 167 111
/**
 * Specifies the transform matrix which is implicitly applied at the root of
 * the animated hierarchy.
 */
67
inline void PartBundle::set_root_xform(LMatrix4 const &root_xform);

391 5 xform 0 4 475 17 PartBundle::xform 0 1 168 81
/**
 * Applies the indicated transform to the root of the animated hierarchy.
 */
51
inline void PartBundle::xform(LMatrix4 const &mat);

392 14 get_root_xform 0 4 475 26 PartBundle::get_root_xform 0 1 169 109
/**
 * Returns the transform matrix which is implicitly applied at the root of the
 * animated hierarchy.
 */
62
inline LMatrix4 const &PartBundle::get_root_xform(void) const;

393 15 apply_transform 0 4 475 27 PartBundle::apply_transform 0 1 170 226
/**
 * Returns a PartBundle that is a duplicate of this one, but with the
 * indicated transform applied.  If this is called multiple times with the
 * same TransformState pointer, it returns the same PartBundle each time.
 */
85
PointerTo< PartBundle > PartBundle::apply_transform(TransformState const *transform);

394 13 get_num_nodes 0 4 475 25 PartBundle::get_num_nodes 0 1 171 94
/**
 * Returns the number of PartBundleNodes that contain a pointer to this
 * PartBundle.
 */
49
inline int PartBundle::get_num_nodes(void) const;

395 8 get_node 0 4 475 20 PartBundle::get_node 0 1 172 74
/**
 * Returns the nth PartBundleNode associated with this PartBundle.
 */
57
inline PartBundleNode *PartBundle::get_node(int n) const;

396 14 PartBundleNode 0 4 480 30 PartBundleNode::PartBundleNode 0 1 188 388
/**
 * The PartBundle and its node should be constructed together.  Generally, the
 * derived classes of PartBundleNode will automatically create a PartBundle of
 * the appropriate type, and pass it up to this constructor.
 */

/**
 * For internal use only.
 */

/**
 * Use make_copy() or copy_subgraph() to copy one of these.
 *
 * This constructor does not copy the bundle pointers.
 */
92
inline explicit PartBundleNode::PartBundleNode(std::string const &name, PartBundle *bundle);

397 15 get_num_bundles 0 4 480 31 PartBundleNode::get_num_bundles 0 1 189 10
/**
 *
 */
55
inline int PartBundleNode::get_num_bundles(void) const;

398 10 get_bundle 0 4 480 26 PartBundleNode::get_bundle 0 1 190 10
/**
 *
 */
59
inline PartBundle *PartBundleNode::get_bundle(int n) const;

399 17 get_bundle_handle 0 4 480 33 PartBundleNode::get_bundle_handle 0 1 191 204
/**
 * Returns the PartBundleHandle that wraps around the actual nth PartBundle.
 * While the PartBundle pointer might later change due to a future flatten
 * operation, the PartBundleHandle will not.
 */
72
inline PartBundleHandle *PartBundleNode::get_bundle_handle(int n) const;

400 0 0 0 0 0 0 0 0
0

401 16 PartBundleHandle 0 4 483 34 PartBundleHandle::PartBundleHandle 0 2 193 194 10
/**
 *
 */
141
inline PartBundleHandle::PartBundleHandle(PartBundle *bundle);
inline PartBundleHandle::PartBundleHandle(PartBundleHandle const &) = default;

402 10 get_bundle 0 4 483 28 PartBundleHandle::get_bundle 0 1 195 68
/**
 * Returns the actual PartBundle embedded within the handle.
 */
54
inline PartBundle *PartBundleHandle::get_bundle(void);

403 10 set_bundle 0 4 483 28 PartBundleHandle::set_bundle 0 1 196 68
/**
 * Changes the actual PartBundle embedded within the handle.
 */
61
inline void PartBundleHandle::set_bundle(PartBundle *bundle);

404 0 0 0 0 0 0 0 0
0

405 14 get_class_type 0 4 480 30 PartBundleNode::get_class_type 0 1 192 0
55
static TypeHandle PartBundleNode::get_class_type(void);

406 0 0 0 0 0 0 0 0
0

407 21 clear_control_effects 0 4 475 33 PartBundle::clear_control_effects 0 1 173 518
/**
 * Sets the control effect of all AnimControls to zero (but does not "stop"
 * the AnimControls).  The character will no longer be affected by any
 * animation, and will return to its default pose (unless restore-initial-pose
 * is false).
 *
 * The AnimControls which are no longer associated will not be using any CPU
 * cycles, but they may still be in the "playing" state; if they are later
 * reassociated with the PartBundle they will resume at their current frame as
 * if they'd been running all along.
 */
45
void PartBundle::clear_control_effects(void);

408 18 set_control_effect 0 4 475 30 PartBundle::set_control_effect 0 1 174 530
/**
 * Sets the amount by which the character is affected by the indicated
 * AnimControl (and its associated animation).  Normally, this will only be
 * zero or one.  Zero indicates the animation does not affect the character,
 * and one means it does.
 *
 * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
 * possible to have multiple AnimControls in effect simultaneously.  In this
 * case, the effect is a weight that indicates the relative importance of each
 * AnimControl to the final animation.
 */
85
inline void PartBundle::set_control_effect(AnimControl *control, PN_stdfloat effect);

409 18 get_control_effect 0 4 475 30 PartBundle::get_control_effect 0 1 175 153
/**
 * Returns the amount by which the character is affected by the indicated
 * AnimControl and its associated animation.  See set_control_effect().
 */
78
inline PN_stdfloat PartBundle::get_control_effect(AnimControl *control) const;

410 6 output 0 6 475 18 PartBundle::output 0 1 176 55
/**
 * Writes a one-line description of the bundle.
 */
57
virtual void PartBundle::output(std::ostream &out) const;

411 9 bind_anim 0 4 475 21 PartBundle::bind_anim 0 1 177 790
/**
 * Binds the animation to the bundle, if possible, and returns a new
 * AnimControl that can be used to start and stop the animation.  If the anim
 * hierarchy does not match the part hierarchy, returns NULL.
 *
 * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
 * it may contain a union of PartGroup::HierarchyMatchFlags values indicating
 * conditions that will be tolerated (but warnings will still be issued).
 *
 * If subset is specified, it restricts the binding only to the named subtree
 * of joints.
 *
 * The AnimControl is not stored within the PartBundle; it is the user's
 * responsibility to maintain the pointer.  The animation will automatically
 * unbind itself when the AnimControl destructs (i.e.  its reference count
 * goes to zero).
 */
137
PointerTo< AnimControl > PartBundle::bind_anim(AnimBundle *anim, int hierarchy_match_flags = 0, PartSubset const &subset = PartSubset());

412 14 load_bind_anim 0 4 475 26 PartBundle::load_bind_anim 0 1 178 1088
/**
 * Binds an animation to the bundle.  The animation is loaded from the disk
 * via the indicated Loader object.  In other respects, this behaves similarly
 * to bind_anim(), with the addition of asynchronous support.
 *
 * If allow_aysnc is true, the load will be asynchronous if possible.  This
 * requires that the animation basename can be found in the PartBundle's
 * preload table (see get_anim_preload()).
 *
 * In an asynchronous load, the animation file will be loaded and bound in a
 * sub-thread.  This means that the animation will not necessarily be
 * available at the time this method returns.  You may still use the returned
 * AnimControl immediately, though, but no visible effect will occur until the
 * animation eventually becomes available.
 *
 * You can test AnimControl::is_pending() to see if the animation has been
 * loaded yet, or wait for it to finish with AnimControl::wait_pending() or
 * even PartBundle::wait_pending().  You can also set an event to be triggered
 * when the animation finishes loading with
 * AnimControl::set_pending_done_event().
 */
165
PointerTo< AnimControl > PartBundle::load_bind_anim(Loader *loader, Filename const &filename, int hierarchy_match_flags, PartSubset const &subset, bool allow_async);

413 12 wait_pending 0 4 475 24 PartBundle::wait_pending 0 1 179 153
/**
 * Blocks the current thread until all currently-pending AnimControls, with a
 * nonzero control effect, have been loaded and are properly bound.
 */
36
void PartBundle::wait_pending(void);

414 12 freeze_joint 0 4 475 24 PartBundle::freeze_joint 0 3 180 181 182 1123
/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */

/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */

/**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */
305
bool PartBundle::freeze_joint(std::string const &joint_name, TransformState const *transform);
bool PartBundle::freeze_joint(std::string const &joint_name, LVecBase3 const &pos, LVecBase3 const &hpr, LVecBase3 const &scale);
bool PartBundle::freeze_joint(std::string const &joint_name, PN_stdfloat value);

415 13 control_joint 0 4 475 25 PartBundle::control_joint 0 1 183 396
/**
 * Specifies that the joint with the indicated name should be animated with
 * the transform on the indicated node.  It will henceforth always follow the
 * node's transform, regardless of any animations that may subsequently be
 * bound to the joint.
 *
 * Returns true if the joint is successfully controlled, or false if the named
 * child is not a joint (or slider) or does not exist.
 */
79
bool PartBundle::control_joint(std::string const &joint_name, PandaNode *node);

416 13 release_joint 0 4 475 25 PartBundle::release_joint 0 1 184 342
/**
 * Releases the named joint from the effects of a previous call to
 * freeze_joint() or control_joint(). It will henceforth once again follow
 * whatever transforms are dictated by the animation.
 *
 * Returns true if the joint is released, or false if the named child was not
 * previously controlled or frozen, or it does not exist.
 */
62
bool PartBundle::release_joint(std::string const &joint_name);

417 6 update 0 4 475 18 PartBundle::update 0 1 185 216
/**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame (as set in each of the AnimControls).
 *
 * Returns true if any part has changed as a result of this, or false
 * otherwise.
 */
30
bool PartBundle::update(void);

418 12 force_update 0 4 475 24 PartBundle::force_update 0 1 186 131
/**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame, whether we believe it needs it or not.
 */
36
bool PartBundle::force_update(void);

419 14 get_class_type 0 4 475 26 PartBundle::get_class_type 0 1 187 0
51
static TypeHandle PartBundle::get_class_type(void);

420 11 ~PartBundle 0 4 475 23 PartBundle::~PartBundle 0 0 0
30
PartBundle::~PartBundle(void);

421 13 get_max_bound 0 4 485 29 MovingPartBase::get_max_bound 0 1 197 310
/**
 * Returns the number of channels that might be bound to this PartGroup.  This
 * might not be the actual number of channels, since there might be holes in
 * the list; it is one more than the index number of the highest bound
 * channel.  Thus, it is called get_max_bound() instead of get_num_bound().
 */
53
inline int MovingPartBase::get_max_bound(void) const;

422 9 get_bound 0 4 485 25 MovingPartBase::get_bound 0 1 198 371
/**
 * Returns the nth bound channel on this PartGroup.  n can be determined by
 * iterating from 0 to one less than get_max_bound(); or n might be
 * AnimControl::get_channel_index().
 *
 * This will return NULL if there is no channel bound on the indicated index.
 * It is an error to call this if n is less than zero or greater than or equal
 * to get_max_bound().
 */
63
inline AnimChannelBase *MovingPartBase::get_bound(int n) const;

423 12 output_value 0 6 485 28 MovingPartBase::output_value 0 1 199 0
71
virtual void MovingPartBase::output_value(std::ostream &out) const = 0;

424 14 get_class_type 0 4 485 30 MovingPartBase::get_class_type 0 1 200 0
55
static TypeHandle MovingPartBase::get_class_type(void);

425 15 ~MovingPartBase 0 4 485 31 MovingPartBase::~MovingPartBase 0 0 0
38
MovingPartBase::~MovingPartBase(void);

426 14 get_class_type 0 4 487 48 MovingPart< ACMatrixSwitchType >::get_class_type 0 1 202 0
73
static TypeHandle MovingPart< ACMatrixSwitchType >::get_class_type(void);

427 9 get_value 0 4 487 43 MovingPart< ACMatrixSwitchType >::get_value 0 1 203 0
72
inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_value(void) const;

428 17 get_default_value 0 4 487 51 MovingPart< ACMatrixSwitchType >::get_default_value 0 1 204 0
80
inline LMatrix4 MovingPart< ACMatrixSwitchType >::get_default_value(void) const;

429 11 ~MovingPart 0 4 487 45 MovingPart< ACMatrixSwitchType >::~MovingPart 0 0 0
52
MovingPart< ACMatrixSwitchType >::~MovingPart(void);

430 14 get_class_type 0 4 486 32 MovingPartMatrix::get_class_type 0 1 201 0
57
static TypeHandle MovingPartMatrix::get_class_type(void);

431 14 get_class_type 0 4 489 48 MovingPart< ACScalarSwitchType >::get_class_type 0 1 206 0
73
static TypeHandle MovingPart< ACScalarSwitchType >::get_class_type(void);

432 9 get_value 0 4 489 43 MovingPart< ACScalarSwitchType >::get_value 0 1 207 0
75
inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_value(void) const;

433 17 get_default_value 0 4 489 51 MovingPart< ACScalarSwitchType >::get_default_value 0 1 208 0
83
inline PN_stdfloat MovingPart< ACScalarSwitchType >::get_default_value(void) const;

434 11 ~MovingPart 0 4 489 45 MovingPart< ACScalarSwitchType >::~MovingPart 0 0 0
52
MovingPart< ACScalarSwitchType >::~MovingPart(void);

435 14 get_class_type 0 4 488 32 MovingPartScalar::get_class_type 0 1 205 0
57
static TypeHandle MovingPartScalar::get_class_type(void);

209
1 0 0 7 8 439 215 0 148 /**
 * Creates the AnimGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */ 2 6 parent 1 439  4 name 1 490  
2 0 0 7 8 439 215 0 0 1 6 param0 0 491  
3 0 0 6 10 442 0 0 58 /**
 * Returns the number of child nodes of the group.
 */ 1 4 this 3 491  
4 0 0 7 11 439 215 0 46 /**
 * Returns the nth child of the group.
 */ 2 4 this 3 491  1 n 1 442  
5 0 0 7 13 439 215 0 250 /**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * AnimGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */ 2 4 this 3 491  4 name 1 490  
6 0 0 7 14 439 215 0 210 /**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this AnimGroup; see also get_child_named().
 */ 2 4 this 3 491  4 name 1 490  
7 0 0 4 15 493 0 0 262 /**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */ 1 4 this 3 439  
8 0 0 4 19 493 0 0 54 /**
 * Writes a one-line description of the group.
 */ 2 4 this 3 491  3 out 1 494  
9 0 0 4 20 493 0 0 78 /**
 * Writes a brief description of the group and all of its descendants.
 */ 3 4 this 3 491  3 out 1 494  12 indent_level 1 442  
10 0 0 7 21 497 0 0 0 0 
11 0 0 7 3 498 0 0 0 1 4 this 3 439  
12 0 0 6 6 499 0 0 0 1 4 this 3 439  
13 0 0 7 23 445 230 0 0 1 6 param0 0 500  
14 0 0 7 23 445 230 0 10 /**
 *
 */ 3 4 name 1 490  3 fps 1 466  10 num_frames 1 442  
15 0 0 7 24 445 230 0 236 /**
 * Returns a full copy of the bundle and its entire tree of nested AnimGroups.
 * However, the actual data stored in the leaves--that is, animation tables,
 * such as those stored in an AnimChannelMatrixXfmTable--will be shared.
 */ 1 4 this 3 500  
16 0 0 6 25 441 0 0 307 /**
 * Returns the ideal number of frames per second of the animation, when it is
 * running at normal speed.  This may not be the same as the actual playing
 * frame rate, as it might have been adjusted through set_play_rate() on the
 * AnimControl object.  See AnimControl::get_effective_frame_rate().
 */ 1 4 this 3 500  
17 0 0 6 26 442 0 0 109 /**
 * Returns the number of frames of animation, or 0 if the animation has no
 * fixed number of frames.
 */ 1 4 this 3 500  
18 0 0 7 31 497 0 0 0 0 
19 0 0 7 35 502 235 0 226 /**
 * The AnimBundle and its node should be constructed together.  Generally, the
 * derived classes of AnimBundleNode will automatically create a AnimBundle of
 * the appropriate type, and pass it up to this constructor.
 */ 2 4 name 1 490  6 bundle 1 445  
20 0 0 7 36 445 230 0 10 /**
 *
 */ 1 4 this 3 503  
21 0 0 7 39 445 230 0 205 /**
 * Recursively walks the scene graph beginning at the indicated node (which
 * need not be an AnimBundleNode), and returns the first AnimBundle found.
 * Returns NULL if no AnimBundle can be found.
 */ 1 4 root 1 460  
22 0 0 7 40 497 0 0 0 0 
23 0 0 7 48 448 241 0 148 /**
 * Creates the PartGroup, and adds it to the indicated parent.  The only way
 * to delete it subsequently is to delete the entire hierarchy.
 */ 2 6 parent 1 448  4 name 1 490  
24 0 0 6 50 477 0 0 156 /**
 * Returns true if this part is a CharacterJoint, false otherwise.  This is a
 * tiny optimization over is_of_type(CharacterType::get_class_type()).
 */ 1 4 this 3 505  
25 0 0 7 51 448 241 0 110 /**
 * Allocates and returns a new copy of the node.  Children are not copied, but
 * see copy_subgraph().
 */ 1 4 this 3 505  
26 0 0 7 52 448 241 0 84 /**
 * Allocates and returns a new copy of this node and of all of its children.
 */ 1 4 this 3 505  
27 0 0 6 53 442 0 0 58 /**
 * Returns the number of child nodes of the group.
 */ 1 4 this 3 505  
28 0 0 7 54 448 241 0 46 /**
 * Returns the nth child of the group.
 */ 2 4 this 3 505  1 n 1 442  
29 0 0 7 56 448 241 0 250 /**
 * Returns the first child found with the indicated name, or NULL if no such
 * child exists.  This method searches only the children of this particular
 * PartGroup; it does not recursively search the entire graph.  See also
 * find_child().
 */ 2 4 this 3 505  4 name 1 490  
30 0 0 7 57 448 241 0 210 /**
 * Returns the first descendant found with the indicated name, or NULL if no
 * such descendant exists.  This method searches the entire graph beginning at
 * this PartGroup; see also get_child_named().
 */ 2 4 this 3 505  4 name 1 490  
31 0 0 4 58 493 0 0 262 /**
 * Sorts the children nodes at each level of the hierarchy into alphabetical
 * order.  This should be done after creating the hierarchy, to guarantee that
 * the correct names will match up together when the AnimBundle is later bound
 * to a PlayerRoot.
 */ 1 4 this 3 448  
32 0 0 6 62 477 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 448  9 transform 1 507  
33 0 0 6 63 477 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 4 4 this 3 448  3 pos 1 510  3 hpr 1 510  5 scale 1 510  
34 0 0 6 64 477 0 0 287 /**
 * Freezes this particular joint so that it will always hold the specified
 * transform.  Returns true if this is a joint that can be so frozen, false
 * otherwise.
 *
 * This is normally only called internally by PartBundle::freeze_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 448  5 value 1 466  
35 0 0 6 65 477 0 0 311 /**
 * Specifies a node to influence this particular joint so that it will always
 * hold the node's transform.  Returns true if this is a joint that can be so
 * controlled, false otherwise.
 *
 * This is normally only called internally by PartBundle::control_joint(), but
 * you may also call it directly.
 */ 2 4 this 3 448  4 node 1 460  
36 0 0 6 66 477 0 0 261 /**
 * Undoes the effect of a previous call to apply_freeze() or apply_control().
 * Returns true if the joint was modified, false otherwise.
 *
 * This is normally only called internally by PartBundle::release_joint(), but
 * you may also call it directly.
 */ 1 4 this 3 448  
37 0 0 7 67 514 282 0 181 /**
 * Returns the AnimChannelBase that has been forced to this joint by a
 * previous call to apply_freeze() or apply_control(), or NULL if no such
 * channel has been applied.
 */ 1 4 this 3 505  
38 0 0 4 68 493 0 0 78 /**
 * Writes a brief description of the group and all of its descendants.
 */ 3 4 this 3 505  3 out 1 494  12 indent_level 1 442  
39 0 0 4 69 493 0 0 117 /**
 * Writes a brief description of the group, showing its current value, and
 * that of all of its descendants.
 */ 3 4 this 3 505  3 out 1 494  12 indent_level 1 442  
40 0 0 7 70 497 0 0 0 0 
41 0 0 7 43 498 0 0 0 1 4 this 3 448  
42 0 0 6 45 499 0 0 0 1 4 this 3 448  
43 0 0 6 81 477 0 0 286 /**
 * Returns true if the AnimControl is being bound asynchronously, and has not
 * yet finished.  If this is true, the AnimControl's interface is still
 * available and will be perfectly useful (though get_anim() might return
 * NULL), but nothing visible will happen immediately.
 */ 1 4 this 3 515  
44 0 0 4 82 493 0 0 102 /**
 * Blocks the current thread until the AnimControl has finished loading and is
 * fully bound.
 */ 1 4 this 3 517  
45 0 0 6 83 477 0 0 154 /**
 * Returns true if the AnimControl was successfully loaded, or false if there
 * was a problem.  This may return false while is_pending() is true.
 */ 1 4 this 3 515  
46 0 0 4 84 493 0 0 205 /**
 * Specifies an event name that will be thrown when the AnimControl is
 * finished binding asynchronously.  If the AnimControl has already finished
 * binding, the event will be thrown immediately.
 */ 2 4 this 3 517  10 done_event 1 490  
47 0 0 6 85 490 0 0 113 /**
 * Returns the event name that will be thrown when the AnimControl is finished
 * binding asynchronously.
 */ 1 4 this 3 515  
48 0 0 7 86 481 420 0 65 /**
 * Returns the PartBundle bound in with this AnimControl.
 */ 1 4 this 3 515  
49 0 0 7 87 445 230 0 65 /**
 * Returns the AnimBundle bound in with this AnimControl.
 */ 1 4 this 3 515  
50 0 0 6 88 442 0 0 358 /**
 * Returns the particular channel index associated with this AnimControl.
 * This channel index is the slot on which each AnimGroup is bound to its
 * associated PartGroup, for each joint in the animation.
 *
 * It will be true that
 * get_part()->find_child("n")->get_bound(get_channel_index()) ==
 * get_anim()->find_child("n"), for each joint "n".
 */ 1 4 this 3 515  
51 0 0 6 89 518 0 0 369 /**
 * Returns the subset of joints controlled by this AnimControl.  Most of the
 * time, this will be BitArray::all_on(), for a normal full-body animation.
 * For a subset animation, however, this will be just a subset of those bits,
 * corresponding to the set of joints and sliders actually bound (as
 * enumerated by bind_hierarchy() in depth-first LIFO order).
 */ 1 4 this 3 515  
52 0 0 4 90 493 0 0 515 /**
 * Associates the indicated PandaNode with the AnimControl.  By convention,
 * this node represents the root node of the model file that corresponds to
 * this AnimControl's animation file, though nothing in this code makes this
 * assumption or indeed does anything with this node.
 *
 * The purpose of this is simply to allow the AnimControl to keep a reference
 * count on the ModelRoot node that generated it, so that the model will not
 * disappear from the model pool until it is no longer referenced.
 */ 2 4 this 3 517  5 model 1 460  
53 0 0 7 91 460 0 0 81 /**
 * Retrieves the pointer set via set_anim_model().  See set_anim_model().
 */ 1 4 this 3 515  
54 0 0 4 92 493 0 0 10 /**
 *
 */ 2 4 this 3 515  3 out 1 494  
55 0 0 7 93 497 0 0 0 0 
56 0 0 7 73 521 0 0 0 1 4 this 3 517  
57 0 0 6 76 522 0 0 0 1 4 this 3 517  
58 0 0 6 78 499 0 0 0 1 4 this 3 517  
59 0 0 7 95 497 0 0 0 1 4 this 3 523  
60 0 0 7 96 497 0 0 0 0 
61 0 0 4 101 493 0 0 0 3 4 this 3 525  5 frame 1 442  5 value 1 526  
62 0 0 4 102 493 0 0 72 // These transform-component methods only have meaning for matrix types. 3 4 this 3 525  5 frame 1 442  5 value 1 526  
63 0 0 4 103 493 0 0 0 3 4 this 3 525  5 frame 1 442  5 scale 1 527  
64 0 0 4 104 493 0 0 0 3 4 this 3 525  5 frame 1 442  3 hpr 1 527  
65 0 0 4 105 493 0 0 0 3 4 this 3 525  5 frame 1 442  4 quat 1 528  
66 0 0 4 106 493 0 0 0 3 4 this 3 525  5 frame 1 442  3 pos 1 527  
67 0 0 4 107 493 0 0 0 3 4 this 3 525  5 frame 1 442  5 shear 1 527  
68 0 0 7 108 497 0 0 0 1 4 this 3 531  
69 0 0 7 109 497 0 0 0 0 
70 0 0 4 114 493 0 0 0 3 4 this 3 533  5 frame 1 442  5 scale 1 527  
71 0 0 4 115 493 0 0 0 3 4 this 3 533  5 frame 1 442  3 hpr 1 527  
72 0 0 4 116 493 0 0 0 3 4 this 3 533  5 frame 1 442  4 quat 1 528  
73 0 0 4 117 493 0 0 0 3 4 this 3 533  5 frame 1 442  3 pos 1 527  
74 0 0 4 118 493 0 0 0 3 4 this 3 533  5 frame 1 442  5 shear 1 527  
75 0 0 7 119 497 0 0 0 1 4 this 3 534  
76 0 0 7 120 497 0 0 0 0 
77 0 0 4 123 493 0 0 44 /**
 * Explicitly sets the matrix value.
 */ 2 4 this 3 536  5 value 1 537  
78 0 0 4 123 493 0 0 107 /**
 * Explicitly sets the matrix value, using the indicated TransformState object
 * as a convenience.
 */ 2 4 this 3 536  5 value 1 507  
79 0 0 4 124 493 0 0 124 /**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.
 */ 2 4 this 3 536  4 node 1 460  
80 0 0 7 125 507 0 0 93 /**
 * Returns the explicit TransformState value that was set via set_value(), if
 * any.
 */ 1 4 this 3 538  
81 0 0 7 126 460 0 0 70 /**
 * Returns the node that was set via set_value_node(), if any.
 */ 1 4 this 3 538  
82 0 0 7 129 497 0 0 0 0 
83 0 0 7 132 540 282 0 10 /**
 *
 */ 2 6 parent 1 439  4 name 1 490  
84 0 0 6 133 477 0 0 80 /**
 * Returns true if the given letter is one of the nine valid table id's.
 */ 1 8 table_id 1 541  
85 0 0 4 134 493 0 0 255 /**
 * Assigns the indicated table.  table_id is one of 'i', 'j', 'k', for scale,
 * 'a', 'b', 'c' for shear, 'h', 'p', 'r', for rotation, and 'x', 'y', 'z',
 * for translation.  The new table must have either zero, one, or
 * get_num_frames() frames.
 */ 3 4 this 3 540  8 table_id 1 541  5 table 1 542  
86 0 0 7 135 546 0 0 103 /**
 * Returns a pointer to the indicated subtable's data, if it exists, or NULL
 * if it does not.
 */ 2 4 this 3 544  8 table_id 1 541  
87 0 0 4 136 493 0 0 90 /**
 * Removes all the tables from the channel, and resets it to its initial
 * state.
 */ 1 4 this 3 540  
88 0 0 6 137 477 0 0 68 /**
 * Returns true if the indicated subtable has been assigned.
 */ 2 4 this 3 544  8 table_id 1 541  
89 0 0 4 138 493 0 0 59 /**
 * Removes the indicated table from the definition.
 */ 2 4 this 3 540  8 table_id 1 541  
90 0 0 7 144 497 0 0 0 0 
91 0 0 4 146 493 0 0 98 /**
 * Explicitly sets the value.  This will remove any node assigned via
 * set_value_node().
 */ 2 4 this 3 547  5 value 1 466  
92 0 0 4 147 493 0 0 178 /**
 * Specifies a node whose transform will be queried each frame to implicitly
 * specify the transform of this joint.  This will override the values set by
 * set_value().
 */ 2 4 this 3 547  4 node 1 460  
93 0 0 7 154 497 0 0 0 0 
94 0 0 4 157 493 0 0 34 /**
 * Assigns the data table.
 */ 2 4 this 3 548  5 table 1 542  
95 0 0 7 158 546 0 0 90 /**
 * Returns a pointer to the table's data, if it exists, or NULL if it does
 * not.
 */ 1 4 this 3 549  
96 0 0 6 159 477 0 0 60 /**
 * Returns true if the data table has been assigned.
 */ 1 4 this 3 549  
97 0 0 4 160 493 0 0 34 /**
 * Empties the data table.
 */ 1 4 this 3 548  
98 0 0 7 162 497 0 0 0 0 
99 0 0 7 165 551 329 0 117 /**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */ 0 
100 0 0 7 165 551 329 0 0 1 6 param0 0 552  
101 0 0 4 167 493 0 0 247 /**
 * Associates the given AnimControl with this collection under the given name.
 * The AnimControl will remain associated until a new AnimControl is
 * associated with the same name later, or until unbind_anim() is called with
 * this name.
 */ 3 4 this 3 551  7 control 1 517  4 name 1 490  
102 0 0 7 168 517 266 0 117 /**
 * Returns the AnimControl associated with the given name, or NULL if no such
 * control has been associated.
 */ 2 4 this 3 552  4 name 1 490  
103 0 0 6 169 477 0 0 184 /**
 * Removes the AnimControl associated with the given name, if any.  Returns
 * true if an AnimControl was removed, false if there was no AnimControl with
 * the indicated name.
 */ 2 4 this 3 551  4 name 1 490  
104 0 0 6 170 442 0 0 78 /**
 * Returns the number of AnimControls associated with this collection.
 */ 1 4 this 3 552  
105 0 0 7 171 517 266 0 71 /**
 * Returns the nth AnimControl associated with this collection.
 */ 2 4 this 3 552  1 n 1 442  
106 0 0 6 172 490 0 0 83 /**
 * Returns the name of the nth AnimControl associated with this collection.
 */ 2 4 this 3 552  1 n 1 442  
107 0 0 4 175 493 0 0 56 /**
 * Disassociates all anims from this collection.
 */ 1 4 this 3 551  
108 0 0 6 176 477 0 0 46 /**
 * Starts the named animation playing.
 */ 2 4 this 3 551  9 anim_name 1 490  
109 0 0 6 176 477 0 0 46 /**
 * Starts the named animation playing.
 */ 4 4 this 3 551  9 anim_name 1 490  4 from 1 441  2 to 1 441  
110 0 0 6 177 477 0 0 46 /**
 * Starts the named animation looping.
 */ 3 4 this 3 551  9 anim_name 1 490  7 restart 1 477  
111 0 0 6 177 477 0 0 46 /**
 * Starts the named animation looping.
 */ 5 4 this 3 551  9 anim_name 1 490  7 restart 1 477  4 from 1 441  2 to 1 441  
112 0 0 6 178 477 0 0 37 /**
 * Stops the named animation.
 */ 2 4 this 3 551  9 anim_name 1 490  
113 0 0 6 179 477 0 0 61 /**
 * Sets to a particular frame in the named animation.
 */ 3 4 this 3 551  9 anim_name 1 490  5 frame 1 441  
114 0 0 4 180 493 0 0 48 // These functions operate on all anims at once. 1 4 this 3 551  
115 0 0 4 180 493 0 0 41 /**
 * Starts all animations playing.
 */ 3 4 this 3 551  4 from 1 441  2 to 1 441  
116 0 0 4 181 493 0 0 41 /**
 * Starts all animations looping.
 */ 2 4 this 3 551  7 restart 1 477  
117 0 0 4 181 493 0 0 41 /**
 * Starts all animations looping.
 */ 4 4 this 3 551  7 restart 1 477  4 from 1 441  2 to 1 441  
118 0 0 6 182 477 0 0 127 /**
 * Stops all currently playing animations.  Returns true if any animations
 * were stopped, false if none were playing.
 */ 1 4 this 3 551  
119 0 0 4 183 493 0 0 54 /**
 * Sets all animations to the indicated frame.
 */ 2 4 this 3 551  5 frame 1 441  
120 0 0 6 184 442 0 0 67 /**
 * Returns the current frame in the last-started animation.
 */ 1 4 this 3 552  
121 0 0 6 184 442 0 0 99 /**
 * Returns the current frame in the named animation, or 0 if the animation is
 * not found.
 */ 2 4 this 3 552  9 anim_name 1 490  
122 0 0 6 185 442 0 0 76 /**
 * Returns the total number of frames in the last-started animation.
 */ 1 4 this 3 552  
123 0 0 6 185 442 0 0 108 /**
 * Returns the total number of frames in the named animation, or 0 if the
 * animation is not found.
 */ 2 4 this 3 552  9 anim_name 1 490  
124 0 0 6 186 477 0 0 95 /**
 * Returns true if the last-started animation is currently playing, false
 * otherwise.
 */ 1 4 this 3 552  
125 0 0 6 186 477 0 0 85 /**
 * Returns true if the named animation is currently playing, false otherwise.
 */ 2 4 this 3 552  9 anim_name 1 490  
126 0 0 6 187 490 0 0 183 /**
 * Returns the name of the bound AnimControl currently playing, if any.  If
 * more than one AnimControl is currently playing, returns all of the names
 * separated by spaces.
 */ 1 4 this 3 552  
127 0 0 4 188 493 0 0 10 /**
 *
 */ 2 4 this 3 552  3 out 1 494  
128 0 0 4 189 493 0 0 10 /**
 *
 */ 2 4 this 3 552  3 out 1 494  
129 0 0 7 192 554 0 0 10 /**
 *
 */ 0 
130 0 0 6 193 442 0 0 64 /**
 * Returns the number of animation records in the table.
 */ 1 4 this 3 555  
131 0 0 6 194 442 0 0 321 /**
 * Returns the index number in the table of the animation record with the
 * indicated name, or -1 if the name is not present.  By convention, the
 * basename is the filename of the egg or bam file, without the directory part
 * and without the extension.  That is, it is
 * Filename::get_basename_wo_extension().
 */ 2 4 this 3 555  8 basename 1 490  
132 0 0 6 195 490 0 0 86 /**
 * Returns the basename stored for the nth animation record.  See find_anim().
 */ 2 4 this 3 555  1 n 1 442  
133 0 0 6 196 466 0 0 70 /**
 * Returns the frame rate stored for the nth animation record.
 */ 2 4 this 3 555  1 n 1 442  
134 0 0 6 197 442 0 0 76 /**
 * Returns the number of frames stored for the nth animation record.
 */ 2 4 this 3 555  1 n 1 442  
135 0 0 4 198 493 0 0 56 /**
 * Removes all animation records from the table.
 */ 1 4 this 3 554  
136 0 0 4 199 493 0 0 113 /**
 * Removes the nth animation records from the table.  This renumbers indexes
 * for following animations.
 */ 2 4 this 3 554  1 n 1 442  
137 0 0 4 200 493 0 0 227 /**
 * Adds a new animation record to the table.  If there is already a record of
 * this name, no operation is performed (the original record is unchanged).
 * See find_anim().  This will invalidate existing index numbers.
 */ 4 4 this 3 554  8 basename 1 490  15 base_frame_rate 1 466  10 num_frames 1 442  
138 0 0 4 201 493 0 0 160 /**
 * Copies the animation records from the other table into this one.  If a
 * given record name exists in both tables, the record in this one supercedes.
 */ 2 4 this 3 554  5 other 1 555  
139 0 0 4 202 493 0 0 10 /**
 *
 */ 2 4 this 3 555  3 out 1 494  
140 0 0 4 203 493 0 0 10 /**
 *
 */ 3 4 this 3 555  3 out 1 494  12 indent_level 1 442  
141 0 0 7 204 497 0 0 0 0 
142 0 0 7 207 557 374 0 10 /**
 *
 */ 0 
143 0 0 7 207 557 374 0 10 /**
 *
 */ 1 4 copy 1 558  
144 0 0 6 208 557 0 0 0 2 4 this 3 557  4 copy 1 558  
145 0 0 4 209 493 0 0 342 /**
 * Adds the named joint to the list of joints that will be explicitly included
 * in the subset.  Any joint at or below a named node will be included in the
 * subset (unless a lower node is also listed in the exclude list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */ 2 4 this 3 557  4 name 1 560  
146 0 0 4 210 493 0 0 352 /**
 * Adds the named joint to the list of joints that will be explicitly
 * exlcluded from the subset.  Any joint at or below a named node will not be
 * included in the subset (unless a lower node is also listed in the include
 * list).
 *
 * Since the name is a GlobPattern, it may of course include filename globbing
 * characters like * and ?.
 */ 2 4 this 3 557  4 name 1 560  
147 0 0 4 211 493 0 0 98 /**
 * Appends the include and exclude list from the other object onto this
 * object's lists.
 */ 2 4 this 3 557  5 other 1 558  
148 0 0 4 212 493 0 0 10 /**
 *
 */ 2 4 this 3 558  3 out 1 494  
149 0 0 6 213 477 0 0 147 /**
 * Returns true if the include list is completely empty, false otherwise.  If
 * it is empty, it is the same thing as including all joints.
 */ 1 4 this 3 558  
150 0 0 6 214 477 0 0 101 /**
 * Returns true if the indicated name matches a name on the include list,
 * false otherwise.
 */ 2 4 this 3 558  10 joint_name 1 490  
151 0 0 6 215 477 0 0 101 /**
 * Returns true if the indicated name matches a name on the exclude list,
 * false otherwise.
 */ 2 4 this 3 558  10 joint_name 1 490  
152 0 0 7 219 565 377 0 0 1 6 param0 0 563  
153 0 0 7 219 565 377 0 10 /**
 *
 */ 7 4 name 1 490  8 filename 1 566  7 options 1 569  6 loader 1 572  7 control 1 517  21 hierarchy_match_flags 1 442  6 subset 1 558  
154 0 0 7 220 497 0 0 0 0 
155 0 0 7 223 481 420 0 133 /**
 * Normally, a PartBundle constructor should not be called directly--it will
 * get created when a PartBundleNode is created.
 */ 1 4 name 1 490  
156 0 0 7 224 555 0 0 181 /**
 * Returns the AnimPreloadTable associated with the PartBundle.  This table,
 * if present, can be used for the benefit of load_bind_anim() to allow
 * asynchronous binding.
 */ 1 4 this 3 574  
157 0 0 7 225 554 0 0 106 /**
 * Returns a modifiable pointer to the AnimPreloadTable associated with the
 * PartBundle, if any.
 */ 1 4 this 3 481  
158 0 0 4 226 493 0 0 72 /**
 * Replaces the AnimPreloadTable associated with the PartBundle.
 */ 2 4 this 3 481  5 table 1 554  
159 0 0 4 227 493 0 0 71 /**
 * Removes any AnimPreloadTable associated with the PartBundle.
 */ 1 4 this 3 481  
160 0 0 4 228 493 0 0 85 /**
 * Copies the contents of the other PartBundle's preload table into this one.
 */ 2 4 this 3 481  5 other 1 574  
161 0 0 4 230 493 0 0 270 /**
 * Defines the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 *
 * See partBundle.h for a description of the meaning of each of the BlendType
 * values.
 */ 2 4 this 3 481  2 bt 1 476  
162 0 0 6 231 476 0 0 178 /**
 * Returns the algorithm that is used when blending multiple frames or
 * multiple animations together, when either anim_blend_flag or
 * frame_blend_flag is set to true.
 */ 1 4 this 3 574  
163 0 0 4 232 493 0 0 581 /**
 * Defines the way the character responds to multiple calls to
 * set_control_effect()).  By default, this flag is set false, which disallows
 * multiple animations.  When this flag is false, it is not necessary to
 * explicitly set the control_effect when starting an animation; starting the
 * animation will implicitly remove the control_effect from the previous
 * animation and set it on the current one.
 *
 * However, if this flag is set true, the control_effect must be explicitly
 * set via set_control_effect() whenever an animation is to affect the
 * character.
 */ 2 4 this 3 481  15 anim_blend_flag 1 477  
164 0 0 6 233 477 0 0 136 /**
 * Returns whether the character allows multiple different animations to be
 * bound simultaneously.  See set_anim_blend_flag().
 */ 1 4 this 3 574  
165 0 0 4 234 493 0 0 775 /**
 * Specifies whether the character interpolates (blends) between two
 * sequential frames of an active animation, showing a smooth intra-frame
 * motion, or whether it holds each frame until the next frame is ready,
 * showing precisely the specified animation.
 *
 * When this value is false, the character holds each frame until the next is
 * ready.  When this is true, the character will interpolate between two
 * consecutive frames of animation for each frame the animation is onscreen,
 * according to the amount of time elapsed between the frames.
 *
 * The default value of this flag is determined by the interpolate-frames
 * Config.prc variable.
 *
 * Use set_blend_type() to change the algorithm that the character uses to
 * interpolate matrix positions.
 */ 2 4 this 3 481  16 frame_blend_flag 1 477  
166 0 0 6 235 477 0 0 205 /**
 * Returns whether the character interpolates (blends) between two sequential
 * animation frames, or whether it holds the current frame until the next one
 * is ready.  See set_frame_blend_flag().
 */ 1 4 this 3 574  
167 0 0 4 236 493 0 0 111 /**
 * Specifies the transform matrix which is implicitly applied at the root of
 * the animated hierarchy.
 */ 2 4 this 3 481  10 root_xform 1 537  
168 0 0 4 237 493 0 0 81 /**
 * Applies the indicated transform to the root of the animated hierarchy.
 */ 2 4 this 3 481  3 mat 1 537  
169 0 0 6 238 537 0 0 109 /**
 * Returns the transform matrix which is implicitly applied at the root of the
 * animated hierarchy.
 */ 1 4 this 3 574  
170 0 0 7 239 481 420 0 226 /**
 * Returns a PartBundle that is a duplicate of this one, but with the
 * indicated transform applied.  If this is called multiple times with the
 * same TransformState pointer, it returns the same PartBundle each time.
 */ 2 4 this 3 481  9 transform 1 507  
171 0 0 6 240 442 0 0 94 /**
 * Returns the number of PartBundleNodes that contain a pointer to this
 * PartBundle.
 */ 1 4 this 3 574  
172 0 0 7 241 479 0 0 74 /**
 * Returns the nth PartBundleNode associated with this PartBundle.
 */ 2 4 this 3 574  1 n 1 442  
173 0 0 4 272 493 0 0 518 /**
 * Sets the control effect of all AnimControls to zero (but does not "stop"
 * the AnimControls).  The character will no longer be affected by any
 * animation, and will return to its default pose (unless restore-initial-pose
 * is false).
 *
 * The AnimControls which are no longer associated will not be using any CPU
 * cycles, but they may still be in the "playing" state; if they are later
 * reassociated with the PartBundle they will resume at their current frame as
 * if they'd been running all along.
 */ 1 4 this 3 481  
174 0 0 4 273 493 0 0 530 /**
 * Sets the amount by which the character is affected by the indicated
 * AnimControl (and its associated animation).  Normally, this will only be
 * zero or one.  Zero indicates the animation does not affect the character,
 * and one means it does.
 *
 * If the _anim_blend_flag is not false (see set_anim_blend_flag()), it is
 * possible to have multiple AnimControls in effect simultaneously.  In this
 * case, the effect is a weight that indicates the relative importance of each
 * AnimControl to the final animation.
 */ 3 4 this 3 481  7 control 1 517  6 effect 1 466  
175 0 0 6 274 466 0 0 153 /**
 * Returns the amount by which the character is affected by the indicated
 * AnimControl and its associated animation.  See set_control_effect().
 */ 2 4 this 3 574  7 control 1 517  
176 0 0 4 275 493 0 0 55 /**
 * Writes a one-line description of the bundle.
 */ 2 4 this 3 574  3 out 1 494  
177 0 0 7 276 517 266 0 790 /**
 * Binds the animation to the bundle, if possible, and returns a new
 * AnimControl that can be used to start and stop the animation.  If the anim
 * hierarchy does not match the part hierarchy, returns NULL.
 *
 * If hierarchy_match_flags is 0, only an exact match is accepted; otherwise,
 * it may contain a union of PartGroup::HierarchyMatchFlags values indicating
 * conditions that will be tolerated (but warnings will still be issued).
 *
 * If subset is specified, it restricts the binding only to the named subtree
 * of joints.
 *
 * The AnimControl is not stored within the PartBundle; it is the user's
 * responsibility to maintain the pointer.  The animation will automatically
 * unbind itself when the AnimControl destructs (i.e.  its reference count
 * goes to zero).
 */ 4 4 this 3 481  4 anim 1 445  21 hierarchy_match_flags 1 442  6 subset 1 558  
178 0 0 7 277 517 266 0 1088 /**
 * Binds an animation to the bundle.  The animation is loaded from the disk
 * via the indicated Loader object.  In other respects, this behaves similarly
 * to bind_anim(), with the addition of asynchronous support.
 *
 * If allow_aysnc is true, the load will be asynchronous if possible.  This
 * requires that the animation basename can be found in the PartBundle's
 * preload table (see get_anim_preload()).
 *
 * In an asynchronous load, the animation file will be loaded and bound in a
 * sub-thread.  This means that the animation will not necessarily be
 * available at the time this method returns.  You may still use the returned
 * AnimControl immediately, though, but no visible effect will occur until the
 * animation eventually becomes available.
 *
 * You can test AnimControl::is_pending() to see if the animation has been
 * loaded yet, or wait for it to finish with AnimControl::wait_pending() or
 * even PartBundle::wait_pending().  You can also set an event to be triggered
 * when the animation finishes loading with
 * AnimControl::set_pending_done_event().
 */ 6 4 this 3 481  6 loader 1 572  8 filename 1 566  21 hierarchy_match_flags 1 442  6 subset 1 558  11 allow_async 1 477  
179 0 0 4 278 493 0 0 153 /**
 * Blocks the current thread until all currently-pending AnimControls, with a
 * nonzero control effect, have been loaded and are properly bound.
 */ 1 4 this 3 481  
180 0 0 6 279 477 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 5 4 this 3 481  10 joint_name 1 490  3 pos 1 510  3 hpr 1 510  5 scale 1 510  
181 0 0 6 279 477 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 481  10 joint_name 1 490  5 value 1 466  
182 0 0 6 279 477 0 0 373 /**
 * Specifies that the joint with the indicated name should be frozen with the
 * specified transform.  It will henceforth always hold this fixed transform,
 * regardless of any animations that may subsequently be bound to the joint.
 *
 * Returns true if the joint is successfully frozen, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 481  10 joint_name 1 490  9 transform 1 507  
183 0 0 6 280 477 0 0 396 /**
 * Specifies that the joint with the indicated name should be animated with
 * the transform on the indicated node.  It will henceforth always follow the
 * node's transform, regardless of any animations that may subsequently be
 * bound to the joint.
 *
 * Returns true if the joint is successfully controlled, or false if the named
 * child is not a joint (or slider) or does not exist.
 */ 3 4 this 3 481  10 joint_name 1 490  4 node 1 460  
184 0 0 6 281 477 0 0 342 /**
 * Releases the named joint from the effects of a previous call to
 * freeze_joint() or control_joint(). It will henceforth once again follow
 * whatever transforms are dictated by the animation.
 *
 * Returns true if the joint is released, or false if the named child was not
 * previously controlled or frozen, or it does not exist.
 */ 2 4 this 3 481  10 joint_name 1 490  
185 0 0 6 282 477 0 0 216 /**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame (as set in each of the AnimControls).
 *
 * Returns true if any part has changed as a result of this, or false
 * otherwise.
 */ 1 4 this 3 481  
186 0 0 6 283 477 0 0 131 /**
 * Updates all the parts in the bundle to reflect the data for the current
 * frame, whether we believe it needs it or not.
 */ 1 4 this 3 481  
187 0 0 7 284 497 0 0 0 0 
188 0 0 7 252 479 0 0 226 /**
 * The PartBundle and its node should be constructed together.  Generally, the
 * derived classes of PartBundleNode will automatically create a PartBundle of
 * the appropriate type, and pass it up to this constructor.
 */ 2 4 name 1 490  6 bundle 1 481  
189 0 0 6 253 442 0 0 10 /**
 *
 */ 1 4 this 3 576  
190 0 0 7 254 481 420 0 10 /**
 *
 */ 2 4 this 3 576  1 n 1 442  
191 0 0 7 256 482 0 0 204 /**
 * Returns the PartBundleHandle that wraps around the actual nth PartBundle.
 * While the PartBundle pointer might later change due to a future flatten
 * operation, the PartBundleHandle will not.
 */ 2 4 this 3 576  1 n 1 442  
192 0 0 7 270 497 0 0 0 0 
193 0 0 7 265 482 0 0 10 /**
 *
 */ 1 6 bundle 1 481  
194 0 0 7 265 482 0 0 0 1 6 param0 0 578  
195 0 0 7 266 481 420 0 68 /**
 * Returns the actual PartBundle embedded within the handle.
 */ 1 4 this 3 482  
196 0 0 4 267 493 0 0 68 /**
 * Changes the actual PartBundle embedded within the handle.
 */ 2 4 this 3 482  6 bundle 1 481  
197 0 0 6 287 442 0 0 310 /**
 * Returns the number of channels that might be bound to this PartGroup.  This
 * might not be the actual number of channels, since there might be holes in
 * the list; it is one more than the index number of the highest bound
 * channel.  Thus, it is called get_max_bound() instead of get_num_bound().
 */ 1 4 this 3 580  
198 0 0 7 288 514 282 0 371 /**
 * Returns the nth bound channel on this PartGroup.  n can be determined by
 * iterating from 0 to one less than get_max_bound(); or n might be
 * AnimControl::get_channel_index().
 *
 * This will return NULL if there is no channel bound on the indicated index.
 * It is an error to call this if n is less than zero or greater than or equal
 * to get_max_bound().
 */ 2 4 this 3 580  1 n 1 442  
199 0 0 4 289 493 0 0 0 2 4 this 3 580  3 out 1 494  
200 0 0 7 290 497 0 0 0 0 
201 0 0 7 298 497 0 0 0 0 
202 0 0 7 294 497 0 0 0 0 
203 0 0 7 295 526 0 0 0 1 4 this 3 582  
204 0 0 7 296 526 0 0 0 1 4 this 3 582  
205 0 0 7 305 497 0 0 0 0 
206 0 0 7 301 497 0 0 0 0 
207 0 0 6 302 466 0 0 0 1 4 this 3 584  
208 0 0 6 303 466 0 0 0 1 4 this 3 584  
209 0 0 4 205 493 0 0 0 3 9 root_node 1 460  8 controls 1 551  21 hierarchy_match_flags 1 442  
150
436 9 AnimGroup 0 26625 9 AnimGroup 9 AnimGroup 0 0 0 1 214 215 1 586 8 216 217 218 219 220 222 223 224 1 604 0 2 3 437 210 211 3 438 212 213 0 0 165
/**
 * This is the base class for AnimChannel and AnimBundle.  It implements a
 * hierarchy of AnimChannels.  The root of the hierarchy must be an
 * AnimBundle.
 */

437 27 TypedWritableReferenceCount 0 2048 27 TypedWritableReferenceCount 27 TypedWritableReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 414
/**
 * A base class for things which need to inherit from both TypedWritable and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedWritables and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

438 7 Namable 0 2048 7 Namable 7 Namable 0 0 0 0 0 0 0 0 0 0 0 0 125
/**
 * A base class for all things which can have a name.  The name is either
 * empty or nonempty, but it is never NULL.
 */

439 11 AnimGroup * 0 8576 11 AnimGroup * 11 AnimGroup * 0 0 436 0 0 0 0 0 0 0 0 0 0

440 10 AnimBundle 0 141313 10 AnimBundle 10 AnimBundle 0 0 0 1 225 230 2 587 588 4 226 227 228 229 0 0 1 0 436 0 0 0 0 169
/**
 * This is the root of an AnimChannel hierarchy.  It knows the frame rate and
 * number of frames of all the channels in the hierarchy (which must all
 * match).
 */

441 6 double 0 8194 6 double 6 double 0 3 0 0 0 0 0 0 0 0 0 0 0

442 3 int 0 8194 3 int 3 int 0 1 0 0 0 0 0 0 0 0 0 0 0

443 14 AnimBundleNode 0 141313 14 AnimBundleNode 14 AnimBundleNode 0 0 0 1 231 235 1 589 3 232 233 234 0 0 1 0 444 0 0 0 0 169
/**
 * This is a node that contains a pointer to an AnimBundle.  Like
 * PartBundleNode, it exists solely to make it easy to store AnimBundles in
 * the scene graph.
 */

444 9 PandaNode 0 2048 9 PandaNode 9 PandaNode 0 0 0 0 0 0 0 0 0 0 0 0 175
/**
 * A basic node of the scene graph or data graph.  This is the base class of
 * all specialized nodes, and also serves as a generic node with no special
 * properties.
 */

445 12 AnimBundle * 0 8576 12 AnimBundle * 12 AnimBundle * 0 0 440 0 0 0 0 0 0 0 0 0 0

446 9 PartGroup 0 26625 9 PartGroup 9 PartGroup 0 0 0 1 240 241 1 590 17 242 243 244 245 246 247 248 249 251 252 253 254 255 256 257 258 259 1 605 0 2 3 437 236 237 3 438 238 239 0 1 447 105
/**
 * This is the base class for PartRoot and MovingPart.  It defines a hierarchy
 * of MovingParts.
 */

447 19 HierarchyMatchFlags 0 794624 30 PartGroup::HierarchyMatchFlags 30 PartGroup::HierarchyMatchFlags 446 0 0 0 0 0 0 0 0 0 3 17 HMF_ok_part_extra 28 PartGroup::HMF_ok_part_extra 0
1 17 HMF_ok_anim_extra 28 PartGroup::HMF_ok_anim_extra 0
2 22 HMF_ok_wrong_root_name 33 PartGroup::HMF_ok_wrong_root_name 0
4 0 214
// This enum defines bits which may be passed into check_hierarchy() and
// PartBundle::bind_anim() to allow an inexact match of channel hierarchies.
// This specifies conditions that we don't care about enforcing.

448 11 PartGroup * 0 8576 11 PartGroup * 11 PartGroup * 0 0 446 0 0 0 0 0 0 0 0 0 0

449 11 AnimControl 0 26625 11 AnimControl 11 AnimControl 0 0 0 0 266 0 13 267 268 269 270 271 272 273 274 275 276 277 278 279 0 0 3 3 450 260 261 3 451 262 263 3 438 264 265 0 0 255
/**
 * Controls the timing of a character animation.  An AnimControl object is
 * created for each character/bundle binding and manages the state of the
 * animation: whether started, stopped, or looping, and the current frame
 * number and play rate.
 */

450 19 TypedReferenceCount 0 2048 19 TypedReferenceCount 19 TypedReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 410
/**
 * A base class for things which need to inherit from both TypedObject and
 * from ReferenceCount.  It's convenient to define this intermediate base
 * class instead of multiply inheriting from the two classes each time they
 * are needed, so that we can sensibly pass around pointers to things which
 * are both TypedObjects and ReferenceCounters.
 *
 * See also TypedObject for detailed instructions.
 */

451 13 AnimInterface 0 2048 13 AnimInterface 13 AnimInterface 0 0 0 0 0 0 0 0 0 0 0 0 226
/**
 * This is the fundamental interface for things that have a play/loop/stop
 * type interface for frame-based animation, such as animated characters.
 * This is the base class for AnimControl and other, similar classes.
 */

452 15 AnimChannelBase 0 141313 15 AnimChannelBase 15 AnimChannelBase 0 0 0 0 282 0 2 280 281 0 0 1 0 436 0 0 0 0 253
/**
 * Parent class for all animation channels.  An AnimChannel is an arbitrary
 * function that changes over time (actually, over frames), usually defined by
 * a table read from an egg file (but possibly computed or generated in any
 * other way).
 */

453 33 AnimChannel< ACMatrixSwitchType > 0 75777 33 AnimChannel< ACMatrixSwitchType > 33 AnimChannel< ACMatrixSwitchType > 0 0 0 0 282 0 9 283 284 285 286 287 288 289 290 291 0 0 1 0 452 0 0 0 1 454 0

454 8 LMatrix4 0 2105344 8 LMatrix4 8 LMatrix4 0 0 455 0 0 0 0 0 0 0 0 0 0

455 9 LMatrix4f 0 2048 9 LMatrix4f 9 LMatrix4f 0 0 0 0 0 0 0 0 0 0 0 0 45
/**
 * This is a 4-by-4 transform matrix.
 */

456 17 AnimChannelMatrix 0 2105345 17 AnimChannelMatrix 17 AnimChannelMatrix 0 0 453 0 0 0 0 0 0 0 0 0 0

457 33 AnimChannel< ACScalarSwitchType > 0 75777 33 AnimChannel< ACScalarSwitchType > 33 AnimChannel< ACScalarSwitchType > 0 0 0 0 282 0 9 292 293 294 295 296 297 298 299 300 0 0 1 0 452 0 0 0 0 0

458 17 AnimChannelScalar 0 2105345 17 AnimChannelScalar 17 AnimChannelScalar 0 0 457 0 0 0 0 0 0 0 0 0 0

459 24 AnimChannelMatrixDynamic 0 141313 24 AnimChannelMatrixDynamic 24 AnimChannelMatrixDynamic 0 0 0 0 306 1 591 5 301 302 303 304 305 0 0 1 0 453 0 0 0 0 393
/**
 * An animation channel that accepts a matrix each frame from some dynamic
 * input provided by code.
 *
 * This object operates in two modes: in explicit mode, the programmer should
 * call set_value() each frame to indicate the new value; in implicit mode,
 * the programmer should call set_value_node() to indicate the node whose
 * transform will be copied to the joint each frame.
 */

460 11 PandaNode * 0 8576 11 PandaNode * 11 PandaNode * 0 0 444 0 0 0 0 0 0 0 0 0 0

461 25 AnimChannelMatrixXfmTable 0 75777 25 AnimChannelMatrixXfmTable 25 AnimChannelMatrixXfmTable 0 0 0 1 307 282 1 592 7 308 309 310 311 312 313 315 0 0 1 0 453 0 0 0 0 263
/**
 * An animation channel that issues a matrix each frame, read from a table
 * such as might have been read from an egg file.  The table actually consists
 * of nine sub-tables, each representing one component of the transform:
 * scale, rotate, translate.
 */

462 13 CPTA_stdfloat 0 2105344 13 CPTA_stdfloat 13 CPTA_stdfloat 0 0 463 0 0 0 0 0 0 0 0 0 0

463 10 CPTA_float 0 2105344 10 CPTA_float 10 CPTA_float 0 0 464 0 0 0 0 0 0 0 0 0 0

464 28 ConstPointerToArray< float > 0 2048 28 ConstPointerToArray< float > 28 ConstPointerToArray< float > 0 0 0 0 0 0 0 0 0 0 0 0 0

465 24 AnimChannelScalarDynamic 0 141313 24 AnimChannelScalarDynamic 24 AnimChannelScalarDynamic 0 0 0 0 321 2 593 594 3 316 317 320 0 0 1 0 457 0 0 0 0 396
/**
 * An animation channel that accepts a scalar each frame from some dynamic
 * input provided by code.
 *
 * This object operates in two modes: in explicit mode, the programmer should
 * call set_value() each frame to indicate the new value; in implicit mode,
 * the programmer should call set_value_node() to indicate the node whose X
 * component will be copied to the scalar each frame.
 */

466 11 PN_stdfloat 0 2105344 11 PN_stdfloat 11 PN_stdfloat 0 0 467 0 0 0 0 0 0 0 0 0 0

467 5 float 0 8194 5 float 5 float 0 2 0 0 0 0 0 0 0 0 0 0 0

468 22 AnimChannelScalarTable 0 141313 22 AnimChannelScalarTable 22 AnimChannelScalarTable 0 0 0 0 327 1 595 5 322 323 324 325 326 0 0 1 0 457 0 0 0 0 132
/**
 * An animation channel that issues a scalar each frame, read from a table
 * such as might have been read from an egg file.
 */

469 21 AnimControlCollection 0 26625 21 AnimControlCollection 21 AnimControlCollection 0 0 0 1 328 329 0 21 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 2 606 607 0 0 0 0 356
/**
 * This is a named collection of AnimControl pointers.  An AnimControl may be
 * added to the collection by name.  While an AnimControl is associated, its
 * reference count is maintained; associating a new AnimControl with the same
 * name will decrement the previous control's reference count (and possibly
 * delete it, unbinding its animation).
 */

470 16 AnimPreloadTable 0 75777 16 AnimPreloadTable 16 AnimPreloadTable 0 0 0 1 351 0 0 12 352 353 354 355 356 357 358 359 360 361 362 363 0 0 1 0 471 0 0 0 0 260
/**
 * This table records data about a list of animations for a particular model,
 * such as number of frames and frame rate.  It's used for implementating
 * asynchronous binding.
 *
 * This table is normally built by an offline tool, such as egg-optchar.
 */

471 17 CopyOnWriteObject 0 2048 17 CopyOnWriteObject 17 CopyOnWriteObject 0 0 0 0 0 0 0 0 0 0 0 0 169
/**
 * This base class provides basic reference counting, but also can be used
 * with a CopyOnWritePointer to provide get_read_pointer() and
 * get_write_pointer().
 */

472 10 PartSubset 0 141313 10 PartSubset 10 PartSubset 0 0 0 1 365 374 0 8 366 367 368 369 370 371 372 373 0 0 0 0 0 190
/**
 * This class is used to define a subset of part names to apply to the
 * PartBundle::bind_anim() operation.  Only those part names within the subset
 * will be included in the bind.
 */

473 15 BindAnimRequest 0 141313 15 BindAnimRequest 15 BindAnimRequest 0 0 0 1 375 377 0 1 376 0 0 1 0 474 0 0 0 0 136
/**
 * This class object manages an asynchronous load-and-bind animation request,
 * as issued through PartBundle::load_bind_anim().
 */

474 16 ModelLoadRequest 0 2048 16 ModelLoadRequest 16 ModelLoadRequest 0 0 0 0 0 0 0 0 0 0 0 0 191
/**
 * A class object that manages a single asynchronous model load request.
 * Create a new ModelLoadRequest, and add it to the loader via load_async(),
 * to begin an asynchronous load.
 */

475 10 PartBundle 0 141313 10 PartBundle 10 PartBundle 0 0 0 1 378 420 5 596 597 598 599 600 30 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 407 408 409 410 411 412 413 414 415 416 417 418 419 1 608 0 1 0 446 0 0 0 1 476 134
/**
 * This is the root of a MovingPart hierarchy.  It defines the hierarchy of
 * moving parts that make up an animatable object.
 */

476 9 BlendType 0 794624 21 PartBundle::BlendType 21 PartBundle::BlendType 475 0 0 0 0 0 0 0 0 0 4 9 BT_linear 21 PartBundle::BT_linear 387
// BT_linear does a componentwise average of all blended matrices, which
// is a linear blend.  The result of this is that if a particular vertex
// would have been at point P in one animation and point Q in another one,
// it will end up on the line in between them in the resulting blend
// animation.  However, this tends to stretch and squash limbs in strange
// and disturbing ways.
0 20 BT_normalized_linear 32 PartBundle::BT_normalized_linear 452
// BT_normalized_linear is a compromise on BT_linear.  The matrix is
// blended linearly without the scale and shear components, and the
// blended scale and shear components are applied separately.  This keeps
// all of the character's body parts in the correct size and shape.
// However, if the hierarchy is disconnected, body parts can fly off.
// It's essential the skeleton hierarchy be completely connected to use
// this blend mode successully.
1 16 BT_componentwise 28 PartBundle::BT_componentwise 115
// BT_componentwise linearly blends all components separately, including
// H, P, and R, and recomposes the matrix.
2 21 BT_componentwise_quat 33 PartBundle::BT_componentwise_quat 124
// BT_componentwise_quat linearly blends all components separately, except
// for rotation which is blended as a quaternion.
3 0 240
// This is the parameter to set_blend_type() and specifies the kind of
// blending operation to be performed when multiple controls are in effect
// simultaneously (see set_control_effect()) or between sequential frames of
// the animation.

477 4 bool 0 8194 4 bool 4 bool 0 4 0 0 0 0 0 0 0 0 0 0 0

478 14 LMatrix4 const 0 8832 14 LMatrix4 const 14 LMatrix4 const 0 0 454 0 0 0 0 0 0 0 0 0 0

479 16 PartBundleNode * 0 8576 16 PartBundleNode * 16 PartBundleNode * 0 0 480 0 0 0 0 0 0 0 0 0 0

480 14 PartBundleNode 0 75777 14 PartBundleNode 14 PartBundleNode 0 0 0 1 396 0 2 601 602 4 397 398 399 405 2 609 610 0 1 0 444 0 0 0 0 342
/**
 * This is a node that contains a pointer to an PartBundle.  Like
 * AnimBundleNode, it exists to make it easy to store PartBundles in the scene
 * graph.
 *
 * (Unlike AnimBundleNode, however, PartBundleNode has an additional function:
 * it is also the base class of the Character node type, which adds additional
 * functionality.)
 */

481 12 PartBundle * 0 8576 12 PartBundle * 12 PartBundle * 0 0 475 0 0 0 0 0 0 0 0 0 0

482 18 PartBundleHandle * 0 8576 18 PartBundleHandle * 18 PartBundleHandle * 0 0 483 0 0 0 0 0 0 0 0 0 0

483 16 PartBundleHandle 0 75777 16 PartBundleHandle 16 PartBundleHandle 0 0 0 1 401 0 1 603 2 402 403 0 0 1 0 484 0 0 0 0 546
/**
 * This is a trivial class returned by PartBundleNode::get_bundle().  Its
 * purpose is to hold the actual PartBundle pointer contained within the
 * PartBundleNode, so that scene graph flatten operations can safely combine
 * or duplicate PartBundles as necessary without affecting high-level bundle
 * operations.
 *
 * The high-level Actor class defined in direct/src/actor, for instance, will
 * store a list of PartBundleHandles instead of on actual PartBundles, so that
 * it will be immune to changes from these flatten operations.
 */

484 14 ReferenceCount 0 2048 14 ReferenceCount 14 ReferenceCount 0 0 0 0 0 0 0 0 0 0 0 0 203
/**
 * A base class for all things that want to be reference-counted.
 * ReferenceCount works in conjunction with PointerTo to automatically delete
 * objects when the last pointer to them goes away.
 */

485 14 MovingPartBase 0 141313 14 MovingPartBase 14 MovingPartBase 0 0 0 0 425 0 4 421 422 423 424 0 0 1 0 446 0 0 0 0 332
/**
 * This is the base class for a single animatable piece that may be bound to
 * one channel (or more, if blending is in effect).  It corresponds to, for
 * instance, a single joint or slider of a character.
 *
 * MovingPartBase does not have a particular value type.  See the derived
 * template class, MovingPart, for this.
 */

486 16 MovingPartMatrix 0 75777 16 MovingPartMatrix 16 MovingPartMatrix 0 0 0 0 429 0 1 430 0 0 1 0 487 0 0 0 0 84
/**
 * This is a particular kind of MovingPart that accepts a matrix each frame.
 */

487 32 MovingPart< ACMatrixSwitchType > 0 141313 32 MovingPart< ACMatrixSwitchType > 32 MovingPart< ACMatrixSwitchType > 0 0 0 0 429 0 3 426 427 428 0 0 1 0 485 0 0 0 1 454 0

488 16 MovingPartScalar 0 75777 16 MovingPartScalar 16 MovingPartScalar 0 0 0 0 434 0 1 435 0 0 1 0 489 0 0 0 0 84
/**
 * This is a particular kind of MovingPart that accepts a scalar each frame.
 */

489 32 MovingPart< ACScalarSwitchType > 0 141313 32 MovingPart< ACScalarSwitchType > 32 MovingPart< ACScalarSwitchType > 0 0 0 0 434 0 3 431 432 433 0 0 1 0 485 0 0 0 0 0

490 13 atomic string 0 2 13 atomic string 13 atomic string 0 7 0 0 0 0 0 0 0 0 0 0 0

491 17 AnimGroup const * 0 8576 17 AnimGroup const * 17 AnimGroup const * 0 0 492 0 0 0 0 0 0 0 0 0 0

492 15 AnimGroup const 0 8832 15 AnimGroup const 15 AnimGroup const 0 0 436 0 0 0 0 0 0 0 0 0 0

493 4 void 0 8194 4 void 4 void 0 6 0 0 0 0 0 0 0 0 0 0 0

494 9 ostream * 0 8576 14 std::ostream * 14 std::ostream * 0 0 495 0 0 0 0 0 0 0 0 0 0

495 7 ostream 0 2048 12 std::ostream 12 std::ostream 0 0 0 0 0 0 0 0 0 0 0 0 0

496 10 TypeHandle 0 16779264 10 TypeHandle 10 TypeHandle 0 0 0 0 0 0 0 0 0 0 0 0 732
/**
 * TypeHandle is the identifier used to differentiate C++ class types.  Any
 * C++ classes that inherit from some base class, and must be differentiated
 * at run time, should store a static TypeHandle object that can be queried
 * through a static member function named get_class_type().  Most of the time,
 * it is also desirable to inherit from TypedObject, which provides some
 * virtual functions to return the TypeHandle for a particular instance.
 *
 * At its essence, a TypeHandle is simply a unique identifier that is assigned
 * by the TypeRegistry.  The TypeRegistry stores a tree of TypeHandles, so
 * that ancestry of a particular type may be queried, and the type name may be
 * retrieved for run-time display.
 */

497 12 TypeHandle * 0 8576 12 TypeHandle * 12 TypeHandle * 0 0 496 0 0 0 0 0 0 0 0 0 0

498 29 TypedWritableReferenceCount * 0 8576 29 TypedWritableReferenceCount * 29 TypedWritableReferenceCount * 0 0 437 0 0 0 0 0 0 0 0 0 0

499 9 Namable * 0 8576 9 Namable * 9 Namable * 0 0 438 0 0 0 0 0 0 0 0 0 0

500 18 AnimBundle const * 0 8576 18 AnimBundle const * 18 AnimBundle const * 0 0 501 0 0 0 0 0 0 0 0 0 0

501 16 AnimBundle const 0 8832 16 AnimBundle const 16 AnimBundle const 0 0 440 0 0 0 0 0 0 0 0 0 0

502 16 AnimBundleNode * 0 8576 16 AnimBundleNode * 16 AnimBundleNode * 0 0 443 0 0 0 0 0 0 0 0 0 0

503 22 AnimBundleNode const * 0 8576 22 AnimBundleNode const * 22 AnimBundleNode const * 0 0 504 0 0 0 0 0 0 0 0 0 0

504 20 AnimBundleNode const 0 8832 20 AnimBundleNode const 20 AnimBundleNode const 0 0 443 0 0 0 0 0 0 0 0 0 0

505 17 PartGroup const * 0 8576 17 PartGroup const * 17 PartGroup const * 0 0 506 0 0 0 0 0 0 0 0 0 0

506 15 PartGroup const 0 8832 15 PartGroup const 15 PartGroup const 0 0 446 0 0 0 0 0 0 0 0 0 0

507 22 TransformState const * 0 8576 22 TransformState const * 22 TransformState const * 0 0 508 0 0 0 0 0 0 0 0 0 0

508 20 TransformState const 0 8832 20 TransformState const 20 TransformState const 0 0 509 0 0 0 0 0 0 0 0 0 0

509 14 TransformState 0 16779264 14 TransformState 14 TransformState 0 0 0 0 0 0 0 0 0 0 0 0 734
/**
 * Indicates a coordinate-system transform on vertices.  TransformStates are
 * the primary means for storing transformations on the scene graph.
 *
 * Transforms may be specified in one of two ways: componentwise, with a pos-
 * hpr-scale, or with an arbitrary transform matrix.  If you specify a
 * transform componentwise, it will remember its original components.
 *
 * TransformState objects are managed very much like RenderState objects.
 * They are immutable and reference-counted automatically.
 *
 * You should not attempt to create or modify a TransformState object
 * directly.  Instead, call one of the make() functions to create one for you.
 * And instead of modifying a TransformState object, create a new one.
 */

510 17 LVecBase3 const * 0 8576 17 LVecBase3 const * 17 LVecBase3 const * 0 0 511 0 0 0 0 0 0 0 0 0 0

511 15 LVecBase3 const 0 8832 15 LVecBase3 const 15 LVecBase3 const 0 0 512 0 0 0 0 0 0 0 0 0 0

512 9 LVecBase3 0 2105344 9 LVecBase3 9 LVecBase3 0 0 513 0 0 0 0 0 0 0 0 0 0

513 10 LVecBase3f 0 2048 10 LVecBase3f 10 LVecBase3f 0 0 0 0 0 0 0 0 0 0 0 0 77
/**
 * This is the base class for all three-component vectors and points.
 */

514 17 AnimChannelBase * 0 8576 17 AnimChannelBase * 17 AnimChannelBase * 0 0 452 0 0 0 0 0 0 0 0 0 0

515 19 AnimControl const * 0 8576 19 AnimControl const * 19 AnimControl const * 0 0 516 0 0 0 0 0 0 0 0 0 0

516 17 AnimControl const 0 8832 17 AnimControl const 17 AnimControl const 0 0 449 0 0 0 0 0 0 0 0 0 0

517 13 AnimControl * 0 8576 13 AnimControl * 13 AnimControl * 0 0 449 0 0 0 0 0 0 0 0 0 0

518 16 BitArray const * 0 8576 16 BitArray const * 16 BitArray const * 0 0 519 0 0 0 0 0 0 0 0 0 0

519 14 BitArray const 0 8832 14 BitArray const 14 BitArray const 0 0 520 0 0 0 0 0 0 0 0 0 0

520 8 BitArray 0 2048 8 BitArray 8 BitArray 0 0 0 0 0 0 0 0 0 0 0 0 210
/**
 * A dynamic array with an unlimited number of bits.
 *
 * This is similar to a BitMask, except it appears to contain an infinite
 * number of bits.  You can use it very much as you would use a BitMask.
 */

521 21 TypedReferenceCount * 0 8576 21 TypedReferenceCount * 21 TypedReferenceCount * 0 0 450 0 0 0 0 0 0 0 0 0 0

522 15 AnimInterface * 0 8576 15 AnimInterface * 15 AnimInterface * 0 0 451 0 0 0 0 0 0 0 0 0 0

523 23 AnimChannelBase const * 0 8576 23 AnimChannelBase const * 23 AnimChannelBase const * 0 0 524 0 0 0 0 0 0 0 0 0 0

524 21 AnimChannelBase const 0 8832 21 AnimChannelBase const 21 AnimChannelBase const 0 0 452 0 0 0 0 0 0 0 0 0 0

525 35 AnimChannel< ACMatrixSwitchType > * 0 8576 35 AnimChannel< ACMatrixSwitchType > * 35 AnimChannel< ACMatrixSwitchType > * 0 0 453 0 0 0 0 0 0 0 0 0 0

526 10 LMatrix4 * 0 8576 10 LMatrix4 * 10 LMatrix4 * 0 0 454 0 0 0 0 0 0 0 0 0 0

527 11 LVecBase3 * 0 8576 11 LVecBase3 * 11 LVecBase3 * 0 0 512 0 0 0 0 0 0 0 0 0 0

528 13 LQuaternion * 0 8576 13 LQuaternion * 13 LQuaternion * 0 0 529 0 0 0 0 0 0 0 0 0 0

529 11 LQuaternion 0 2105344 11 LQuaternion 11 LQuaternion 0 0 530 0 0 0 0 0 0 0 0 0 0

530 12 LQuaternionf 0 2048 12 LQuaternionf 12 LQuaternionf 0 0 0 0 0 0 0 0 0 0 0 0 44
/**
 * This is the base quaternion class
 */

531 41 AnimChannel< ACMatrixSwitchType > const * 0 8576 41 AnimChannel< ACMatrixSwitchType > const * 41 AnimChannel< ACMatrixSwitchType > const * 0 0 532 0 0 0 0 0 0 0 0 0 0

532 39 AnimChannel< ACMatrixSwitchType > const 0 8832 39 AnimChannel< ACMatrixSwitchType > const 39 AnimChannel< ACMatrixSwitchType > const 0 0 453 0 0 0 0 0 0 0 0 0 0

533 35 AnimChannel< ACScalarSwitchType > * 0 8576 35 AnimChannel< ACScalarSwitchType > * 35 AnimChannel< ACScalarSwitchType > * 0 0 457 0 0 0 0 0 0 0 0 0 0

534 41 AnimChannel< ACScalarSwitchType > const * 0 8576 41 AnimChannel< ACScalarSwitchType > const * 41 AnimChannel< ACScalarSwitchType > const * 0 0 535 0 0 0 0 0 0 0 0 0 0

535 39 AnimChannel< ACScalarSwitchType > const 0 8832 39 AnimChannel< ACScalarSwitchType > const 39 AnimChannel< ACScalarSwitchType > const 0 0 457 0 0 0 0 0 0 0 0 0 0

536 26 AnimChannelMatrixDynamic * 0 8576 26 AnimChannelMatrixDynamic * 26 AnimChannelMatrixDynamic * 0 0 459 0 0 0 0 0 0 0 0 0 0

537 16 LMatrix4 const * 0 8576 16 LMatrix4 const * 16 LMatrix4 const * 0 0 478 0 0 0 0 0 0 0 0 0 0

538 32 AnimChannelMatrixDynamic const * 0 8576 32 AnimChannelMatrixDynamic const * 32 AnimChannelMatrixDynamic const * 0 0 539 0 0 0 0 0 0 0 0 0 0

539 30 AnimChannelMatrixDynamic const 0 8832 30 AnimChannelMatrixDynamic const 30 AnimChannelMatrixDynamic const 0 0 459 0 0 0 0 0 0 0 0 0 0

540 27 AnimChannelMatrixXfmTable * 0 8576 27 AnimChannelMatrixXfmTable * 27 AnimChannelMatrixXfmTable * 0 0 461 0 0 0 0 0 0 0 0 0 0

541 4 char 0 8194 4 char 4 char 0 5 0 0 0 0 0 0 0 0 0 0 0

542 21 CPTA_stdfloat const * 0 8576 21 CPTA_stdfloat const * 21 CPTA_stdfloat const * 0 0 543 0 0 0 0 0 0 0 0 0 0

543 19 CPTA_stdfloat const 0 8832 19 CPTA_stdfloat const 19 CPTA_stdfloat const 0 0 462 0 0 0 0 0 0 0 0 0 0

544 33 AnimChannelMatrixXfmTable const * 0 8576 33 AnimChannelMatrixXfmTable const * 33 AnimChannelMatrixXfmTable const * 0 0 545 0 0 0 0 0 0 0 0 0 0

545 31 AnimChannelMatrixXfmTable const 0 8832 31 AnimChannelMatrixXfmTable const 31 AnimChannelMatrixXfmTable const 0 0 461 0 0 0 0 0 0 0 0 0 0

546 15 CPTA_stdfloat * 0 8576 15 CPTA_stdfloat * 15 CPTA_stdfloat * 0 0 462 0 0 0 0 0 0 0 0 0 0

547 26 AnimChannelScalarDynamic * 0 8576 26 AnimChannelScalarDynamic * 26 AnimChannelScalarDynamic * 0 0 465 0 0 0 0 0 0 0 0 0 0

548 24 AnimChannelScalarTable * 0 8576 24 AnimChannelScalarTable * 24 AnimChannelScalarTable * 0 0 468 0 0 0 0 0 0 0 0 0 0

549 30 AnimChannelScalarTable const * 0 8576 30 AnimChannelScalarTable const * 30 AnimChannelScalarTable const * 0 0 550 0 0 0 0 0 0 0 0 0 0

550 28 AnimChannelScalarTable const 0 8832 28 AnimChannelScalarTable const 28 AnimChannelScalarTable const 0 0 468 0 0 0 0 0 0 0 0 0 0

551 23 AnimControlCollection * 0 8576 23 AnimControlCollection * 23 AnimControlCollection * 0 0 469 0 0 0 0 0 0 0 0 0 0

552 29 AnimControlCollection const * 0 8576 29 AnimControlCollection const * 29 AnimControlCollection const * 0 0 553 0 0 0 0 0 0 0 0 0 0

553 27 AnimControlCollection const 0 8832 27 AnimControlCollection const 27 AnimControlCollection const 0 0 469 0 0 0 0 0 0 0 0 0 0

554 18 AnimPreloadTable * 0 8576 18 AnimPreloadTable * 18 AnimPreloadTable * 0 0 470 0 0 0 0 0 0 0 0 0 0

555 24 AnimPreloadTable const * 0 8576 24 AnimPreloadTable const * 24 AnimPreloadTable const * 0 0 556 0 0 0 0 0 0 0 0 0 0

556 22 AnimPreloadTable const 0 8832 22 AnimPreloadTable const 22 AnimPreloadTable const 0 0 470 0 0 0 0 0 0 0 0 0 0

557 12 PartSubset * 0 8576 12 PartSubset * 12 PartSubset * 0 0 472 0 0 0 0 0 0 0 0 0 0

558 18 PartSubset const * 0 8576 18 PartSubset const * 18 PartSubset const * 0 0 559 0 0 0 0 0 0 0 0 0 0

559 16 PartSubset const 0 8832 16 PartSubset const 16 PartSubset const 0 0 472 0 0 0 0 0 0 0 0 0 0

560 19 GlobPattern const * 0 8576 19 GlobPattern const * 19 GlobPattern const * 0 0 561 0 0 0 0 0 0 0 0 0 0

561 17 GlobPattern const 0 8832 17 GlobPattern const 17 GlobPattern const 0 0 562 0 0 0 0 0 0 0 0 0 0

562 11 GlobPattern 0 2048 11 GlobPattern 11 GlobPattern 0 0 0 0 0 0 0 0 0 0 0 0 538
/**
 * This class can be used to test for string matches against standard Unix-
 * shell filename globbing conventions.  It serves as a portable standin for
 * the Posix fnmatch() call.
 *
 * A GlobPattern is given a pattern string, which can contain operators like
 * *, ?, and [].  Then it can be tested against any number of candidate
 * strings; for each candidate, it will indicate whether the string matches
 * the pattern or not.  It can be used, for example, to scan a directory for
 * all files matching a particular pattern.
 */

563 23 BindAnimRequest const * 0 8576 23 BindAnimRequest const * 23 BindAnimRequest const * 0 0 564 0 0 0 0 0 0 0 0 0 0

564 21 BindAnimRequest const 0 8832 21 BindAnimRequest const 21 BindAnimRequest const 0 0 473 0 0 0 0 0 0 0 0 0 0

565 17 BindAnimRequest * 0 8576 17 BindAnimRequest * 17 BindAnimRequest * 0 0 473 0 0 0 0 0 0 0 0 0 0

566 16 Filename const * 0 8576 16 Filename const * 16 Filename const * 0 0 567 0 0 0 0 0 0 0 0 0 0

567 14 Filename const 0 8832 14 Filename const 14 Filename const 0 0 568 0 0 0 0 0 0 0 0 0 0

568 8 Filename 0 2048 8 Filename 8 Filename 0 0 0 0 0 0 0 0 0 0 0 0 550
/**
 * The name of a file, such as a texture file or an Egg file.  Stores the full
 * pathname, and includes functions for extracting out the directory prefix
 * part and the file extension and stuff.
 *
 * A Filename is also aware of the mapping between the Unix-like filename
 * convention we use internally, and the local OS's specific filename
 * convention, and it knows how to perform basic OS-specific I/O, like testing
 * for file existence and searching a searchpath, as well as the best way to
 * open an fstream for reading or writing.
 */

569 21 LoaderOptions const * 0 8576 21 LoaderOptions const * 21 LoaderOptions const * 0 0 570 0 0 0 0 0 0 0 0 0 0

570 19 LoaderOptions const 0 8832 19 LoaderOptions const 19 LoaderOptions const 0 0 571 0 0 0 0 0 0 0 0 0 0

571 13 LoaderOptions 0 2048 13 LoaderOptions 13 LoaderOptions 0 0 0 0 0 0 0 0 0 0 0 0 65
/**
 * Specifies parameters that may be passed to the loader.
 */

572 8 Loader * 0 8576 8 Loader * 8 Loader * 0 0 573 0 0 0 0 0 0 0 0 0 0

573 6 Loader 0 2048 6 Loader 6 Loader 0 0 0 0 0 0 0 0 0 0 0 0 503
/**
 * A convenient class for loading models from disk, in bam or egg format (or
 * any of a number of other formats implemented by a LoaderFileType, such as
 * ptloader).
 *
 * This class supports synchronous as well as asynchronous loading.  In
 * asynchronous loading, the model is loaded in the background by a thread,
 * and an event will be generated when the model is available.  If threading
 * is not available, the asynchronous loading interface may be used, but it
 * loads synchronously.
 */

574 18 PartBundle const * 0 8576 18 PartBundle const * 18 PartBundle const * 0 0 575 0 0 0 0 0 0 0 0 0 0

575 16 PartBundle const 0 8832 16 PartBundle const 16 PartBundle const 0 0 475 0 0 0 0 0 0 0 0 0 0

576 22 PartBundleNode const * 0 8576 22 PartBundleNode const * 22 PartBundleNode const * 0 0 577 0 0 0 0 0 0 0 0 0 0

577 20 PartBundleNode const 0 8832 20 PartBundleNode const 20 PartBundleNode const 0 0 480 0 0 0 0 0 0 0 0 0 0

578 24 PartBundleHandle const * 0 8576 24 PartBundleHandle const * 24 PartBundleHandle const * 0 0 579 0 0 0 0 0 0 0 0 0 0

579 22 PartBundleHandle const 0 8832 22 PartBundleHandle const 22 PartBundleHandle const 0 0 483 0 0 0 0 0 0 0 0 0 0

580 22 MovingPartBase const * 0 8576 22 MovingPartBase const * 22 MovingPartBase const * 0 0 581 0 0 0 0 0 0 0 0 0 0

581 20 MovingPartBase const 0 8832 20 MovingPartBase const 20 MovingPartBase const 0 0 485 0 0 0 0 0 0 0 0 0 0

582 40 MovingPart< ACMatrixSwitchType > const * 0 8576 40 MovingPart< ACMatrixSwitchType > const * 40 MovingPart< ACMatrixSwitchType > const * 0 0 583 0 0 0 0 0 0 0 0 0 0

583 38 MovingPart< ACMatrixSwitchType > const 0 8832 38 MovingPart< ACMatrixSwitchType > const 38 MovingPart< ACMatrixSwitchType > const 0 0 487 0 0 0 0 0 0 0 0 0 0

584 40 MovingPart< ACScalarSwitchType > const * 0 8576 40 MovingPart< ACScalarSwitchType > const * 40 MovingPart< ACScalarSwitchType > const * 0 0 585 0 0 0 0 0 0 0 0 0 0

585 38 MovingPart< ACScalarSwitchType > const 0 8832 38 MovingPart< ACScalarSwitchType > const 38 MovingPart< ACScalarSwitchType > const 0 0 489 0 0 0 0 0 0 0 0 0 0

0
18
586 8 children 0 66 439 221 0 0 0 0 216 0 0 19 AnimGroup::children 0

587 15 base_frame_rate 0 2 441 227 0 0 0 0 0 0 0 27 AnimBundle::base_frame_rate 0

588 10 num_frames 0 2 442 228 0 0 0 0 0 0 0 22 AnimBundle::num_frames 0

589 6 bundle 0 2 445 232 0 0 0 0 0 0 0 22 AnimBundleNode::bundle 0

590 8 children 0 66 448 250 0 0 0 0 245 0 0 19 PartGroup::children 0

591 10 value_node 0 6 460 304 302 0 0 0 0 0 0 36 AnimChannelMatrixDynamic::value_node 0

592 6 tables 0 174 462 314 309 312 0 313 0 0 0 33 AnimChannelMatrixXfmTable::tables 0

593 5 value 0 6 466 318 316 0 0 0 0 0 0 31 AnimChannelScalarDynamic::value 0

594 10 value_node 0 6 460 319 317 0 0 0 0 0 0 36 AnimChannelScalarDynamic::value_node 0

595 5 table 0 30 462 323 322 324 325 0 0 0 0 29 AnimChannelScalarTable::table 0

596 10 blend_type 0 6 476 385 384 0 0 0 0 0 0 22 PartBundle::blend_type 0

597 15 anim_blend_flag 0 6 477 387 386 0 0 0 0 0 0 27 PartBundle::anim_blend_flag 0

598 16 frame_blend_flag 0 6 477 389 388 0 0 0 0 0 0 28 PartBundle::frame_blend_flag 0

599 10 root_xform 0 6 478 392 390 0 0 0 0 0 0 22 PartBundle::root_xform 0

600 5 nodes 0 66 479 406 0 0 0 0 394 0 0 17 PartBundle::nodes 0

601 7 bundles 0 66 481 400 0 0 0 0 397 0 0 23 PartBundleNode::bundles 0

602 14 bundle_handles 0 66 482 404 0 0 0 0 397 0 0 30 PartBundleNode::bundle_handles 0

603 6 bundle 0 6 481 402 403 0 0 0 0 0 0 24 PartBundleHandle::bundle 0

7
604 12 get_children 0 216 217 23 AnimGroup::get_children 0

605 12 get_children 0 245 246 23 PartGroup::get_children 0

606 9 get_anims 0 333 334 32 AnimControlCollection::get_anims 0

607 14 get_anim_names 0 333 335 37 AnimControlCollection::get_anim_names 0

608 9 get_nodes 0 394 395 21 PartBundle::get_nodes 0

609 11 get_bundles 0 397 398 27 PartBundleNode::get_bundles 0

610 18 get_bundle_handles 0 397 399 34 PartBundleNode::get_bundle_handles 0

